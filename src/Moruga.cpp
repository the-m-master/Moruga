/* Moruga file compressor based on PAQ8 by Matt Mahoney
 * Release by Marwijn Hessel, May., 2021
 *
 * Copyright (C) 2008 Matt Mahoney, Serge Osnach, Alexander Ratushnyak,
 * Bill Pettis, Przemyslaw Skibinski, Matthew Fite, wowtiger, Andrew Paterson,
 * Jan Ondrus, Andreas Morphis, Pavel L. Holoborodko, KZ., Simon Berger,
 * Neill Corlett, Marwijn Hessel, Mat Chartier
 *
 * We would like to express our gratitude for the endless support of many
 * contributors who encouraged PAQ8 development with ideas, testing,
 * compiling and debugging.
 *
 * Moruga is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moruga is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; see the file COPYING3.
 * If not, see <https://www.gnu.org/licenses/>
 *
 *  Usage: Moruga <command> <infile> <outfile>
 *
 *  <Commands>
 *    c       Compress
 *    d       Decompress
 *
 * Simplified build command using g++:
 * g++ -std=c++20 -s -m64 -Ofast -flto -mno-ms-bitfields -fomit-frame-pointer -march=native -mtune=native -Wall Moruga.cpp TxtPrep4.cpp CaseSpace.cpp Progress.cpp -o Moruga
 */
#include <algorithm>
#include <array>
#include <cassert>
#include <chrono>
#include <cinttypes>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <exception>
#include <new>
#include <string>
#include <utility>
#include "Buffer.h"
#include "File.h"
#include "IntegerXXL.h"
#include "Progress.h"
#include "TxtPrep4.h"
#include "filters/filter.h"
#include "iEncoder.h"
#include "iMonitor.h"

#if defined(_WIN32) || defined(_WIN64)
#include <processthreadsapi.h>
#include <psapi.h>
#endif

#if defined(__linux__) || defined(__CYGWIN__)
#define _aligned_malloc(size, alignment) std::aligned_alloc(alignment, size)
#define _aligned_free(memory) std::free(memory)
#endif  // __linux__

#ifndef DEFAULT_OPTION
#define DEFAULT_OPTION 4
#endif

static int32_t level{DEFAULT_OPTION};  // Compression level 0 to 9

static auto MEM() noexcept -> uint64_t {
  return UINT64_C(1) << (22 + level);  // 27,28,29 and 30 only on x64 platforms
}

// Global variables
static bool verbose{false};  // Set during application parameter parsing (not change during activity)
static uint32_t gC0{1};      // Last 0-7 bits of the partial byte with a leading 1 bit (1-255)
static uint32_t gC1{0};      // Last two higher 4-bit nibbles
static uint32_t gC2{0};      // Last two higher 4-bit nibbles
static uint32_t gC4{0};      // Last 4 whole bytes (buf(4)..buf(1)), packed
static uint32_t gC8{0};      // Another 4 bytes (buf(8)..buf(5))
static uint32_t gBcount{7};  // Bit processed (7..0) gBcount=7-bpos
static uint32_t gFails{0};
static uint32_t gTt{0};
static uint32_t gW5{0};
static uint32_t gX5{0};

// #define GENERATE_SQUASH_STRETCH

#if defined(GENERATE_SQUASH_STRETCH)
#include <cmath>

enum {
  NBITS = 12,        // Construct 12 bit tables
  TOP = 1 << NBITS,  // Top value
  HTOP = TOP / 2     // Half way value
};

[[nodiscard]] static auto inverf(const double x) noexcept -> double {
  double p;
  double t{log(fma(x, 0.0 - x, 1.0))};
  if (fabs(t) > 6.125) {
    // clang-format off
    p =            3.03697567e-10;
    p = fma(p, t,  2.93243101e-8);
    p = fma(p, t,  1.22150334e-6);
    p = fma(p, t,  2.84108955e-5);
    p = fma(p, t,  3.93552968e-4);
    p = fma(p, t,  3.02698812e-3);
    p = fma(p, t,  4.83185798e-3);
    p = fma(p, t, -2.64646143e-1);
    p = fma(p, t,  8.40016484e-1);
  } else {
    p =            5.43877832e-9;
    p = fma(p, t,  1.43286059e-7);
    p = fma(p, t,  1.22775396e-6);
    p = fma(p, t,  1.12962631e-7);
    p = fma(p, t, -5.61531961e-5);
    p = fma(p, t, -1.47697705e-4);
    p = fma(p, t,  2.31468701e-3);
    p = fma(p, t,  1.15392562e-2);
    p = fma(p, t, -2.32015476e-1);
    p = fma(p, t,  8.86226892e-1);
    // clang-format on
  }
  return p * x;
}

class Squash_t final {
public:
  explicit Squash_t(const double a = 756.1) {
    std::array<double, TOP> table{};
#if 1
    //
    // Sigmoid: y(x) = erf(0.5 * sqrt(pi) * x)
    //          y(x) = erf(x/a)
    //
    for (uint32_t n{0}; n < TOP; ++n) {
      const double in{(double(n) - (HTOP - 1)) / a};  // Best when a=756.1 on enwik9
      double tmp{std::erf(in)};
      table[n] = (1.0 + tmp) / 2.0;

#if !defined(NDEBUG)  // Small validation: 'inverf(erf(x)) = x'
      tmp = inverf(tmp);
      assert(std::fabs(tmp - in) < 1e-6);
#endif
    }
    const double offset{table[0]};
    const double scale{double(TOP - 1) / (table[(TOP - 1)] - offset)};
    for (uint32_t n{0}; n < TOP; ++n) {
      double tmp{(table[n] - offset) * scale};
      _squash[n] = uint16_t(std::lround(tmp));
    }
#elif 0
    //                      1
    // Sigmoid:  y(x) = ----------
    //                       -ax
    //                   1 + e
    //
    for (uint32_t n{0}; n < TOP; ++n) {
      table[n] = 1.0 / (1.0 + exp(((HTOP - 1) - double(n)) / double(a)));  // Best when a=315 on enwik9
    }
    const double offset{table[0]};
    const double scale{double(TOP - 1) / (table[(TOP - 1)] - offset)};
    for (uint32_t n{0}; n < TOP; ++n) {
      double tmp{(table[n] - offset) * scale};
      _squash[n] = uint16_t(std::lround(tmp));
    }
#else
    (void)a;  // Not adjustable

    static constexpr std::array<uint16_t, 33> ts{{1,    2,    3,    6,    10,   16,   27,   45,    //
                                                  73,   120,  194,  310,  488,  747,  1101, 1546,  //
                                                  2047, 2549, 2994, 3348, 3607, 3785, 3901, 3975,  //
                                                  4022, 4050, 4068, 4079, 4085, 4089, 4092, 4093, 4094}};
    for (int32_t n{-(HTOP - 1)}; n < HTOP; ++n) {
      const int32_t w{n & 127};
      const int32_t d{(n >> 7) + 16};
      _squash[n + 2047] = uint16_t((ts[d] * (128 - w) + ts[(d + 1)] * w + 64) >> 7);
    }
#endif

    File_t out("Squash.txt", "wb");
    for (uint32_t n{0}; n < TOP; ++n) {
      fprintf(out, "%d,", _squash[n]);
      if (!((n + 1) % 16)) {
        fprintf(out, "\n");
      }
    }
  }

  constexpr auto operator()(const int32_t d) const noexcept -> uint16_t {  // Conversion from -2048..2047 (clamped) into 0..4095
    // clang-format off
    if (d < ~0x7FF) { return 0x000; }
    if (d > 0x7FF) { return 0xFFF; }
    // clang-format on
    return _squash[uint32_t(d + HTOP)];
  }

  Squash_t(const Squash_t&) = delete;
  Squash_t(Squash_t&&) = delete;
  auto operator=(const Squash_t&) -> Squash_t& = delete;
  auto operator=(Squash_t&&) -> Squash_t& = delete;

private:
  std::array<uint16_t, TOP> _squash{};
};

static Squash_t* _squash{nullptr};

class Stretch_t final {
public:
  explicit Stretch_t(const double a = 756.1) {
#if 1
    // Inverse of sigmoid: y(x) = inverf(x)
    //
    std::array<double, TOP> table{};
    for (int32_t n{0}; n < TOP; ++n) {
      table[n] = inverf((double(n) - double(HTOP)) / 2048.0001) * a;
    }
    for (uint32_t n{0}; n < TOP; ++n) {
      int32_t tmp{std::lround(table[n])};
      _stretch[n] = int16_t(std::clamp(tmp, ~(HTOP - 1), (HTOP - 1)));
    }
#else
    (void)a;  // Not adjustable

    // Inverse of sigmoid
    //
    uint32_t pi{0};
    for (int32_t n{0}; n < TOP; ++n) {
      const uint32_t i{(*_squash)(n - HTOP)};  // Conversion from -2048..2047 into 0..4095
      for (uint32_t j{pi}; j <= i; ++j) {
        _stretch[j] = static_cast<int16_t>(n - HTOP);
      }
      pi = i + 1;
    }
    _stretch[TOP - 1] = HTOP - 1;
#endif

    File_t out("Stretch.txt", "wb");
    for (uint32_t n{0}; n < TOP; ++n) {
      fprintf(out, "%d,", _stretch[n]);
      if (!((n + 1) % 16)) {
        fprintf(out, "\n");
      }
    }
  }

  constexpr auto operator()(const uint32_t pr) const noexcept -> int16_t {  // Conversion from 0..4095 into -2048..2047
    assert(pr < TOP);
    return _stretch[pr];
  }

  Stretch_t(const Stretch_t&) = delete;
  Stretch_t(Stretch_t&&) = delete;
  auto operator=(const Stretch_t&) -> Stretch_t& = delete;
  auto operator=(Stretch_t&&) -> Stretch_t& = delete;

private:
  std::array<int16_t, TOP> _stretch{};
};

static Stretch_t* _stretch{nullptr};

static auto Squash(const int16_t d) noexcept -> uint16_t {  // Conversion from -2048..2047 (clamped) into 0..4095
  return (*_squash)(d);
}

static auto Stretch(const uint16_t pr) noexcept -> int16_t {  // Conversion from 0..4095 into -2048..2047
  return (*_stretch)(pr);
}

static auto Stretch256(const int32_t pr) noexcept -> int16_t {  // Conversion from 0..1048575 into -2048..2047
  return Stretch(uint16_t(pr / 256));
}

#else

static constexpr std::array<uint16_t, 0x1000> __squash{{
#include "Squash.txt"
}};

[[nodiscard]] ALWAYS_INLINE static constexpr auto Squash(const int16_t pr) noexcept -> uint16_t {  // Conversion from -2048..2047 (clamped) into 0..4095
  // clang-format off
  if (pr < ~0x7FF) { return 0x000; }
  if (pr >  0x7FF) { return 0xFFF; }
  // clang-format on
  return __squash[size_t(pr + 0x800)];
}

static constexpr std::array<int16_t, 0x1000> __stretch{{
#include "Stretch.txt"
}};

[[nodiscard]] ALWAYS_INLINE static constexpr auto Stretch(const uint16_t pr) noexcept -> int16_t {  // Conversion from 0..4095 into -2048..2047
  assert(pr < 0x1000);
  return __stretch[pr];
}

[[nodiscard]] ALWAYS_INLINE static constexpr auto Stretch256(const int32_t pr) noexcept -> int16_t {  // Conversion from 0..1048575 into -2048..2047
  const uint16_t d{uint16_t(uint32_t(pr) / 256)};
#if 0  // Does not help much, delta between stretch[d] and stretch[d+1] is around the edges small
  if (d < 0xFFF) {
    const int32_t w{pr & 0xFF};
    const int32_t v{(__stretch[d] * (256 - w)) + (__stretch[d + 1] * w)};
    return int16_t(((v > 0) ? (v + 128) : (v - 128)) / 256);
  }
#endif
  return Stretch(d);
}

#endif  // GENERATE_SQUASH_STRETCH

template <typename T>
[[nodiscard]] ALWAYS_INLINE static constexpr auto clamp12(T pr) noexcept -> int16_t {
  // clang-format off
  if (pr < ~0x7FF){ return ~0x7FF; }
  if (pr >  0x7FF){ return  0x7FF; }
  // clang-format on
  return int16_t(pr);
}

static int32_t DP_SHIFT{14};

static std::array<std::array<int32_t, 256>, 12> smt;
static std::array<uint32_t, 5> hh{{0, 0, 0, 0, 0}};

static constexpr std::array<std::array<uint8_t, 256>, 6> StateTableY0                     //
    {{{{1,   3,   4,   7,   8,   9,   11,  15,  16,  17,  18,  20,  21,  22,  26,  31,    //   0- 15 . . . . . . . . . . . . . . . .
        32,  32,  32,  32,  34,  34,  34,  34,  34,  34,  36,  36,  36,  36,  38,  41,    //  16- 31 . . . . . . . . . . . . . . . .
        42,  42,  44,  44,  46,  46,  48,  48,  50,  53,  54,  54,  56,  56,  58,  58,    //  32- 47   ! " # $ % & ' ( ) * + , - . /
        60,  60,  62,  62,  50,  67,  68,  68,  70,  70,  72,  72,  74,  74,  76,  76,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        62,  62,  64,  83,  84,  84,  86,  86,  44,  44,  58,  58,  60,  60,  76,  76,    //  64- 79 @ A B C D E F G H I J K L M N O
        78,  78,  80,  93,  94,  94,  96,  96,  48,  48,  88,  88,  80,  103, 104, 104,   //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        106, 106, 62,  62,  88,  88,  80,  113, 114, 114, 116, 116, 62,  62,  88,  88,    //  96-111 ` a b c d e f g h i j k l m n o
        90,  123, 124, 124, 126, 126, 62,  62,  98,  98,  90,  133, 134, 134, 136, 136,   // 112-127 p q r s t u v w x y z { | } ~ .
        62,  62,  98,  98,  90,  143, 144, 144, 68,  68,  62,  62,  98,  98,  100, 149,   // 128-143 . . . . . . . . . . . . . . . .
        150, 150, 108, 108, 100, 153, 154, 108, 100, 157, 158, 108, 100, 161, 162, 108,   // 144-159 . . . . . . . . . . . . . . . .
        110, 165, 166, 118, 110, 169, 170, 118, 110, 173, 174, 118, 110, 177, 178, 118,   // 160-175 . . . . . . . . . . . . . . . .
        110, 181, 182, 118, 120, 185, 186, 128, 120, 189, 190, 128, 120, 193, 194, 128,   // 176-191 . . . . . . . . . . . . . . . .
        120, 197, 198, 128, 120, 201, 202, 128, 120, 205, 206, 128, 120, 209, 210, 128,   // 192-207 . . . . . . . . . . . . . . . .
        130, 213, 214, 138, 130, 217, 218, 138, 130, 221, 222, 138, 130, 225, 226, 138,   // 208-223 . . . . . . . . . . . . . . . .
        130, 229, 230, 138, 130, 233, 234, 138, 130, 237, 238, 138, 130, 241, 242, 138,   // 224-239 . . . . . . . . . . . . . . . .
        130, 245, 246, 138, 140, 249, 250, 80,  140, 253, 254, 80,  140, 253, 254, 80}},  // 240-255 . . . . . . . . . . . . . . . .

      {{2,   2,   6,   5,   9,   13,  14,  11,  17,  25,  21,  27,  19,  29,  30,  23,     //   0- 15 . . . . . . . . . . . . . . . .
        33,  49,  37,  51,  41,  53,  45,  55,  35,  57,  43,  59,  39,  61,  62,  47,     //  16- 31 . . . . . . . . . . . . . . . .
        65,  97,  69,  99,  73,  101, 77,  103, 81,  105, 85,  107, 89,  109, 93,  111,    //  32- 47   ! " # $ % & ' ( ) * + , - . /
        67,  113, 75,  115, 83,  117, 91,  119, 71,  121, 87,  123, 79,  125, 126, 95,     //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        65,  97,  69,  99,  73,  101, 77,  103, 81,  105, 85,  107, 89,  109, 93,  111,    //  64- 79 @ A B C D E F G H I J K L M N O
        65,  97,  69,  99,  73,  101, 77,  103, 81,  105, 85,  107, 89,  109, 93,  111,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        67,  113, 75,  115, 83,  117, 91,  119, 67,  113, 75,  115, 83,  117, 91,  119,    //  96-111 ` a b c d e f g h i j k l m n o
        71,  121, 87,  123, 71,  121, 87,  123, 79,  125, 79,  125, 79,  130, 128, 95,     // 112-127 p q r s t u v w x y z { | } ~ .
        132, 95,  134, 79,  136, 95,  138, 79,  140, 95,  142, 79,  144, 95,  146, 79,     // 128-143 . . . . . . . . . . . . . . . .
        148, 95,  150, 79,  152, 95,  154, 79,  156, 95,  158, 79,  156, 95,  160, 79,     // 144-159 . . . . . . . . . . . . . . . .
        162, 103, 164, 103, 166, 103, 168, 103, 170, 103, 172, 103, 174, 103, 176, 103,    // 160-175 . . . . . . . . . . . . . . . .
        178, 103, 180, 103, 182, 103, 184, 103, 186, 103, 188, 103, 190, 103, 192, 103,    // 176-191 . . . . . . . . . . . . . . . .
        194, 103, 196, 103, 198, 103, 200, 103, 202, 115, 204, 115, 206, 115, 208, 115,    // 192-207 . . . . . . . . . . . . . . . .
        210, 115, 212, 115, 214, 115, 216, 115, 218, 115, 220, 115, 222, 115, 224, 115,    // 208-223 . . . . . . . . . . . . . . . .
        226, 115, 228, 115, 230, 115, 232, 115, 234, 115, 236, 115, 238, 115, 240, 115,    // 224-239 . . . . . . . . . . . . . . . .
        242, 115, 244, 115, 246, 115, 248, 115, 250, 115, 252, 115, 254, 115, 254, 115}},  // 240-255 . . . . . . . . . . . . . . . .

      {{1,   3,   5,   7,   9,   11,  13,  15,  17,  19,  21,  23,  25,  27,  29,  31,     //   0- 15 . . . . . . . . . . . . . . . .
        33,  35,  37,  39,  41,  43,  45,  47,  49,  51,  53,  55,  57,  59,  61,  63,     //  16- 31 . . . . . . . . . . . . . . . .
        65,  67,  69,  71,  73,  75,  77,  79,  81,  83,  85,  87,  89,  91,  93,  95,     //  32- 47   ! " # $ % & ' ( ) * + , - . /
        97,  99,  101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159,    //  64- 79 @ A B C D E F G H I J K L M N O
        161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223,    //  96-111 ` a b c d e f g h i j k l m n o
        225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 127,    // 112-127 p q r s t u v w x y z { | } ~ .
        129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159,    // 128-143 . . . . . . . . . . . . . . . .
        161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191,    // 144-159 . . . . . . . . . . . . . . . .
        193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223,    // 160-175 . . . . . . . . . . . . . . . .
        225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 189, 255,    // 176-191 . . . . . . . . . . . . . . . .
        129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159,    // 192-207 . . . . . . . . . . . . . . . .
        161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191,    // 208-223 . . . . . . . . . . . . . . . .
        193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223,    // 224-239 . . . . . . . . . . . . . . . .
        225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255}},  // 240-255 . . . . . . . . . . . . . . . .

      {{1,   3,   5,   6,   9,   8,   10,  13,  12,  14,  15,  18,  17,  20,  19,  21,     //   0- 15 . . . . . . . . . . . . . . . .
        24,  23,  26,  25,  27,  28,  31,  30,  33,  32,  35,  34,  36,  39,  38,  41,     //  16- 31 . . . . . . . . . . . . . . . .
        40,  43,  42,  44,  45,  48,  47,  50,  49,  52,  51,  54,  53,  55,  58,  57,     //  32- 47   ! " # $ % & ' ( ) * + , - . /
        60,  59,  62,  61,  64,  63,  65,  66,  69,  68,  71,  70,  73,  72,  75,  74,     //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        77,  76,  78,  81,  80,  83,  82,  85,  84,  87,  86,  89,  88,  90,  91,  94,     //  64- 79 @ A B C D E F G H I J K L M N O
        93,  96,  95,  98,  97,  100, 99,  102, 101, 104, 103, 105, 108, 107, 110, 109,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        112, 111, 114, 113, 116, 115, 118, 117, 119, 105, 121, 120, 123, 122, 125, 124,    //  96-111 ` a b c d e f g h i j k l m n o
        127, 126, 129, 128, 131, 130, 133, 132, 134, 137, 38,  139, 138, 141, 140, 143,    // 112-127 p q r s t u v w x y z { | } ~ .
        142, 145, 144, 147, 146, 148, 149, 39,  47,  152, 151, 154, 153, 156, 155, 158,    // 128-143 . . . . . . . . . . . . . . . .
        157, 160, 159, 162, 161, 163, 48,  59,  166, 49,  168, 167, 170, 169, 172, 171,    // 144-159 . . . . . . . . . . . . . . . .
        174, 173, 175, 176, 48,  59,  179, 178, 181, 180, 183, 182, 185, 184, 187, 186,    // 160-175 . . . . . . . . . . . . . . . .
        188, 58,  72,  191, 190, 193, 192, 195, 194, 197, 196, 198, 199, 58,  72,  202,    // 176-191 . . . . . . . . . . . . . . . .
        201, 204, 203, 206, 205, 208, 207, 209, 69,  86,  212, 211, 214, 213, 216, 215,    // 192-207 . . . . . . . . . . . . . . . .
        217, 218, 69,  86,  221, 220, 223, 222, 225, 224, 226, 81,  101, 229, 228, 231,    // 208-223 . . . . . . . . . . . . . . . .
        230, 232, 233, 81,  101, 236, 235, 238, 237, 239, 94,  117, 242, 241, 243, 244,    // 224-239 . . . . . . . . . . . . . . . .
        94,  117, 247, 246, 248, 108, 132, 250, 251, 108, 246, 253, 121, 255, 121, 255}},  // 240-255 . . . . . . . . . . . . . . . .

      {{1,   4,   3,   6,   8,   7,   11,  10,  13,  12,  15,  17,  16,  19,  18,  22,     //   0- 15 . . . . . . . . . . . . . . . .
        21,  24,  23,  26,  25,  28,  30,  29,  32,  31,  34,  33,  37,  36,  39,  38,     //  16- 31 . . . . . . . . . . . . . . . .
        41,  40,  43,  42,  45,  47,  46,  49,  48,  51,  50,  53,  52,  56,  55,  58,     //  32- 47   ! " # $ % & ' ( ) * + , - . /
        57,  60,  59,  62,  61,  64,  63,  66,  68,  67,  70,  69,  72,  71,  74,  73,     //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        76,  75,  79,  78,  81,  80,  83,  82,  85,  84,  87,  86,  89,  88,  91,  93,     //  64- 79 @ A B C D E F G H I J K L M N O
        92,  95,  94,  97,  96,  99,  98,  101, 100, 103, 102, 106, 105, 108, 107, 110,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        109, 112, 111, 114, 113, 116, 115, 118, 117, 120, 122, 121, 124, 123, 126, 125,    //  96-111 ` a b c d e f g h i j k l m n o
        128, 127, 130, 129, 132, 131, 118, 133, 135, 134, 137, 136, 139, 138, 141, 140,    // 112-127 p q r s t u v w x y z { | } ~ .
        143, 142, 41,  144, 147, 146, 149, 151, 150, 153, 152, 155, 154, 157, 156, 159,    // 128-143 . . . . . . . . . . . . . . . .
        158, 74,  160, 161, 52,  164, 163, 166, 165, 168, 167, 170, 169, 172, 171, 85,     // 144-159 . . . . . . . . . . . . . . . .
        173, 174, 52,  176, 178, 177, 180, 179, 182, 181, 184, 183, 97,  185, 186, 63,     // 160-175 . . . . . . . . . . . . . . . .
        189, 188, 191, 190, 193, 192, 195, 194, 97,  196, 197, 63,  199, 201, 200, 203,    // 176-191 . . . . . . . . . . . . . . . .
        202, 205, 204, 110, 206, 207, 75,  210, 209, 212, 211, 214, 213, 124, 215, 216,    // 192-207 . . . . . . . . . . . . . . . .
        75,  218, 220, 219, 222, 221, 124, 223, 224, 88,  227, 226, 229, 228, 137, 230,    // 208-223 . . . . . . . . . . . . . . . .
        231, 88,  233, 235, 234, 151, 236, 237, 102, 240, 239, 151, 241, 242, 102, 244,    // 224-239 . . . . . . . . . . . . . . . .
        164, 245, 246, 117, 176, 248, 249, 117, 244, 251, 133, 253, 133, 255, 148, 255}},  // 240-255 . . . . . . . . . . . . . . . .

      {{10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 14, 68, 70, 70, 70,      //   0- 15 . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      //  16- 31 . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      //  32- 47   ! " # $ % & ' ( ) * + , - . /
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        10, 10, 10, 10, 68, 70, 70, 70, 10, 10, 10, 10, 10, 10, 10, 10,      //  64- 79 @ A B C D E F G H I J K L M N O
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      //  96-111 ` a b c d e f g h i j k l m n o
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 112-127 p q r s t u v w x y z { | } ~ .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 128-143 . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 144-159 . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 160-175 . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 176-191 . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 192-207 . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 208-223 . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 224-239 . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10}}}};  // 240-255 . . . . . . . . . . . . . . . .

static constexpr std::array<std::array<uint8_t, 256>, 6> StateTableY1                      //
    {{{{2,   5,   6,   10,  12,  13,  14,  19,  23,  24,  25,  27,  28,  29,  30,  33,     //   0- 15 . . . . . . . . . . . . . . . .
        35,  35,  35,  35,  37,  37,  37,  37,  37,  37,  39,  39,  39,  39,  40,  43,     //  16- 31 . . . . . . . . . . . . . . . .
        45,  45,  47,  47,  49,  49,  51,  51,  52,  43,  57,  57,  59,  59,  61,  61,     //  32- 47   ! " # $ % & ' ( ) * + , - . /
        63,  63,  65,  65,  66,  55,  57,  57,  73,  73,  75,  75,  77,  77,  79,  79,     //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        81,  81,  82,  69,  71,  71,  73,  73,  59,  59,  61,  61,  49,  49,  89,  89,     //  64- 79 @ A B C D E F G H I J K L M N O
        91,  91,  92,  69,  87,  87,  45,  45,  99,  99,  101, 101, 102, 69,  87,  87,     //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        57,  57,  109, 109, 111, 111, 112, 85,  87,  87,  57,  57,  119, 119, 121, 121,    //  96-111 ` a b c d e f g h i j k l m n o
        122, 85,  97,  97,  57,  57,  129, 129, 131, 131, 132, 85,  97,  97,  57,  57,     // 112-127 p q r s t u v w x y z { | } ~ .
        139, 139, 141, 141, 142, 95,  97,  97,  57,  57,  81,  81,  147, 147, 148, 95,     // 128-143 . . . . . . . . . . . . . . . .
        107, 107, 151, 151, 152, 95,  107, 155, 156, 95,  107, 159, 160, 105, 107, 163,    // 144-159 . . . . . . . . . . . . . . . .
        164, 105, 117, 167, 168, 105, 117, 171, 172, 105, 117, 175, 176, 105, 117, 179,    // 160-175 . . . . . . . . . . . . . . . .
        180, 115, 117, 183, 184, 115, 127, 187, 188, 115, 127, 191, 192, 115, 127, 195,    // 176-191 . . . . . . . . . . . . . . . .
        196, 115, 127, 199, 200, 115, 127, 203, 204, 115, 127, 207, 208, 125, 127, 211,    // 192-207 . . . . . . . . . . . . . . . .
        212, 125, 137, 215, 216, 125, 137, 219, 220, 125, 137, 223, 224, 125, 137, 227,    // 208-223 . . . . . . . . . . . . . . . .
        228, 125, 137, 231, 232, 125, 137, 235, 236, 125, 137, 239, 240, 125, 137, 243,    // 224-239 . . . . . . . . . . . . . . . .
        244, 135, 137, 247, 248, 135, 69,  251, 252, 135, 69,  255, 252, 135, 69,  255}},  // 240-255 . . . . . . . . . . . . . . . .

      {{3,   3,   4,   7,   12,  10,  8,   15,  24,  18,  26,  22,  28,  20,  16,  31,     //   0- 15 . . . . . . . . . . . . . . . .
        48,  34,  50,  38,  52,  42,  54,  46,  56,  36,  58,  44,  60,  40,  32,  63,     //  16- 31 . . . . . . . . . . . . . . . .
        96,  66,  98,  70,  100, 74,  102, 78,  104, 82,  106, 86,  108, 90,  110, 94,     //  32- 47   ! " # $ % & ' ( ) * + , - . /
        112, 68,  114, 76,  116, 84,  118, 92,  120, 72,  122, 88,  124, 80,  64,  127,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        96,  66,  98,  70,  100, 74,  102, 78,  104, 82,  106, 86,  108, 90,  110, 94,     //  64- 79 @ A B C D E F G H I J K L M N O
        96,  66,  98,  70,  100, 74,  102, 78,  104, 82,  106, 86,  108, 90,  110, 94,     //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        112, 68,  114, 76,  116, 84,  118, 92,  112, 68,  114, 76,  116, 84,  118, 92,     //  96-111 ` a b c d e f g h i j k l m n o
        120, 72,  122, 88,  120, 72,  122, 88,  124, 80,  124, 80,  131, 80,  64,  129,    // 112-127 p q r s t u v w x y z { | } ~ .
        64,  133, 80,  135, 64,  137, 80,  139, 64,  141, 80,  143, 64,  145, 80,  147,    // 128-143 . . . . . . . . . . . . . . . .
        64,  149, 80,  151, 64,  153, 80,  155, 64,  157, 80,  159, 64,  157, 80,  161,    // 144-159 . . . . . . . . . . . . . . . .
        104, 163, 104, 165, 104, 167, 104, 169, 104, 171, 104, 173, 104, 175, 104, 177,    // 160-175 . . . . . . . . . . . . . . . .
        104, 179, 104, 181, 104, 183, 104, 185, 104, 187, 104, 189, 104, 191, 104, 193,    // 176-191 . . . . . . . . . . . . . . . .
        104, 195, 104, 197, 104, 199, 104, 201, 116, 203, 116, 205, 116, 207, 116, 209,    // 192-207 . . . . . . . . . . . . . . . .
        116, 211, 116, 213, 116, 215, 116, 217, 116, 219, 116, 221, 116, 223, 116, 225,    // 208-223 . . . . . . . . . . . . . . . .
        116, 227, 116, 229, 116, 231, 116, 233, 116, 235, 116, 237, 116, 239, 116, 241,    // 224-239 . . . . . . . . . . . . . . . .
        116, 243, 116, 245, 116, 247, 116, 249, 116, 251, 116, 253, 116, 255, 116, 255}},  // 240-255 . . . . . . . . . . . . . . . .

      {{2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24,  26,  28,  30,  32,     //   0- 15 . . . . . . . . . . . . . . . .
        34,  36,  38,  40,  42,  44,  46,  48,  50,  52,  54,  56,  58,  60,  62,  64,     //  16- 31 . . . . . . . . . . . . . . . .
        66,  68,  70,  72,  74,  76,  78,  80,  82,  84,  86,  88,  90,  92,  94,  96,     //  32- 47   ! " # $ % & ' ( ) * + , - . /
        98,  100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160,    //  64- 79 @ A B C D E F G H I J K L M N O
        162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,    //  96-111 ` a b c d e f g h i j k l m n o
        226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 128,    // 112-127 p q r s t u v w x y z { | } ~ .
        130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160,    // 128-143 . . . . . . . . . . . . . . . .
        162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,    // 144-159 . . . . . . . . . . . . . . . .
        194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,    // 160-175 . . . . . . . . . . . . . . . .
        226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 190, 192,    // 176-191 . . . . . . . . . . . . . . . .
        130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160,    // 192-207 . . . . . . . . . . . . . . . .
        162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,    // 208-223 . . . . . . . . . . . . . . . .
        194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,    // 224-239 . . . . . . . . . . . . . . . .
        226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 192}},  // 240-255 . . . . . . . . . . . . . . . .

      {{2,   5,   4,   8,   7,   9,   12,  11,  14,  13,  17,  16,  19,  18,  20,  23,     //   0- 15 . . . . . . . . . . . . . . . .
        22,  25,  24,  27,  26,  30,  29,  32,  31,  34,  33,  35,  38,  37,  40,  39,     //  16- 31 . . . . . . . . . . . . . . . .
        42,  41,  44,  43,  47,  46,  49,  48,  51,  50,  53,  52,  54,  57,  56,  59,     //  32- 47   ! " # $ % & ' ( ) * + , - . /
        58,  61,  60,  63,  62,  65,  64,  68,  67,  70,  69,  72,  71,  74,  73,  76,     //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        75,  77,  80,  79,  82,  81,  84,  83,  86,  85,  88,  87,  90,  89,  93,  92,     //  64- 79 @ A B C D E F G H I J K L M N O
        95,  94,  97,  96,  99,  98,  101, 100, 103, 102, 104, 107, 106, 109, 108, 111,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        110, 113, 112, 115, 114, 117, 116, 119, 118, 120, 106, 122, 121, 124, 123, 126,    //  96-111 ` a b c d e f g h i j k l m n o
        125, 128, 127, 130, 129, 132, 131, 133, 136, 135, 138, 39,  140, 139, 142, 141,    // 112-127 p q r s t u v w x y z { | } ~ .
        144, 143, 146, 145, 148, 147, 38,  150, 151, 48,  153, 152, 155, 154, 157, 156,    // 128-143 . . . . . . . . . . . . . . . .
        159, 158, 161, 160, 162, 47,  164, 165, 60,  167, 50,  169, 168, 171, 170, 173,    // 144-159 . . . . . . . . . . . . . . . .
        172, 175, 174, 47,  177, 178, 60,  180, 179, 182, 181, 184, 183, 186, 185, 187,    // 160-175 . . . . . . . . . . . . . . . .
        57,  189, 190, 73,  192, 191, 194, 193, 196, 195, 198, 197, 57,  200, 201, 73,     // 176-191 . . . . . . . . . . . . . . . .
        203, 202, 205, 204, 207, 206, 208, 68,  210, 211, 87,  213, 212, 215, 214, 217,    // 192-207 . . . . . . . . . . . . . . . .
        216, 68,  219, 220, 87,  222, 221, 224, 223, 225, 80,  227, 228, 102, 230, 229,    // 208-223 . . . . . . . . . . . . . . . .
        232, 231, 80,  234, 235, 102, 237, 236, 238, 93,  240, 241, 118, 243, 242, 93,     // 224-239 . . . . . . . . . . . . . . . .
        245, 246, 118, 247, 107, 249, 250, 133, 107, 252, 247, 120, 254, 120, 254, 134}},  // 240-255 . . . . . . . . . . . . . . . .

      {{2,   3,   5,   7,   6,   9,   10,  12,  11,  14,  16,  15,  18,  17,  20,  21,     //   0- 15 . . . . . . . . . . . . . . . .
        23,  22,  25,  24,  27,  29,  28,  31,  30,  33,  32,  35,  36,  38,  37,  40,     //  16- 31 . . . . . . . . . . . . . . . .
        39,  42,  41,  44,  46,  45,  48,  47,  50,  49,  52,  51,  54,  55,  57,  56,     //  32- 47   ! " # $ % & ' ( ) * + , - . /
        59,  58,  61,  60,  63,  62,  65,  67,  66,  69,  68,  71,  70,  73,  72,  75,     //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        74,  77,  78,  80,  79,  82,  81,  84,  83,  86,  85,  88,  87,  90,  92,  91,     //  64- 79 @ A B C D E F G H I J K L M N O
        94,  93,  96,  95,  98,  97,  100, 99,  102, 101, 104, 105, 107, 106, 109, 108,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        111, 110, 113, 112, 115, 114, 117, 116, 119, 121, 120, 123, 122, 125, 124, 127,    //  96-111 ` a b c d e f g h i j k l m n o
        126, 129, 128, 131, 130, 133, 132, 119, 134, 136, 135, 138, 137, 140, 139, 142,    // 112-127 p q r s t u v w x y z { | } ~ .
        141, 144, 143, 42,  145, 148, 150, 149, 152, 151, 154, 153, 156, 155, 158, 157,    // 128-143 . . . . . . . . . . . . . . . .
        160, 159, 75,  51,  162, 163, 165, 164, 167, 166, 169, 168, 171, 170, 173, 172,    // 144-159 . . . . . . . . . . . . . . . .
        86,  51,  175, 177, 176, 179, 178, 181, 180, 183, 182, 185, 184, 98,  62,  187,    // 160-175 . . . . . . . . . . . . . . . .
        188, 190, 189, 192, 191, 194, 193, 196, 195, 98,  62,  198, 200, 199, 202, 201,    // 176-191 . . . . . . . . . . . . . . . .
        204, 203, 206, 205, 111, 74,  208, 209, 211, 210, 213, 212, 215, 214, 125, 74,     // 192-207 . . . . . . . . . . . . . . . .
        217, 219, 218, 221, 220, 223, 222, 125, 87,  225, 226, 228, 227, 230, 229, 138,    // 208-223 . . . . . . . . . . . . . . . .
        87,  232, 234, 233, 236, 235, 152, 101, 238, 239, 241, 240, 152, 101, 243, 245,    // 224-239 . . . . . . . . . . . . . . . .
        244, 165, 116, 247, 248, 177, 116, 250, 245, 132, 252, 132, 254, 147, 254, 147}},  // 240-255 . . . . . . . . . . . . . . . .

      {{11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 13, 15, 69, 69, 69, 71,      //   0- 15 . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      //  16- 31 . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      //  32- 47   ! " # $ % & ' ( ) * + , - . /
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        11, 11, 11, 11, 69, 69, 69, 71, 11, 11, 11, 11, 11, 11, 11, 11,      //  64- 79 @ A B C D E F G H I J K L M N O
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      //  96-111 ` a b c d e f g h i j k l m n o
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 112-127 p q r s t u v w x y z { | } ~ .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 128-143 . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 144-159 . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 160-175 . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 176-191 . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 192-207 . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 208-223 . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 224-239 . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11}}}};  // 240-255 . . . . . . . . . . . . . . . .

static constexpr std::array<uint8_t, 256> WRT_mxr                        //
    {{0,  0,  0,  0,  0,  0,  10, 20, 0,  4,  28, 0,  0,  0,  0,  0,     //   0- 15 . . . . . . . . . . . . . . . .
      0,  0,  0,  0,  0,  0,  0,  0,  10, 0,  0,  0,  0,  0,  0,  0,     //  16- 31 . . . . . . . . . . . . . . . .
      4,  20, 26, 20, 22, 28, 26, 22, 30, 6,  28, 30, 6,  30, 24, 30,    //  32- 47   ! " # $ % & ' ( ) * + , - . /
      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  20, 30, 26, 22, 0,  30,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
      18, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,    //  64- 79 @ A B C D E F G H I J K L M N O
      10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 8,  20, 6,  28, 30,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
      20, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,    //  96-111 ` a b c d e f g h i j k l m n o
      10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 30, 20, 22, 30, 20,    // 112-127 p q r s t u v w x y z { | } ~ .
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,    // 128-143 . . . . . . . . . . . . . . . .
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,    // 144-159 . . . . . . . . . . . . . . . .
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,    // 160-175 . . . . . . . . . . . . . . . .
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,    // 176-191 . . . . . . . . . . . . . . . .
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,    // 192-207 . . . . . . . . . . . . . . . .
      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,    // 208-223 . . . . . . . . . . . . . . . .
      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,    // 224-239 . . . . . . . . . . . . . . . .
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16}};  // 240-255 . . . . . . . . . . . . . . . .

static constexpr std::array<uint8_t, 256> limits_15a              //
    {{0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 24, 24, 16, 16, 16, 16,   //   0- 15 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    //  16- 31 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    //  32- 47   ! " # $ % & ' ( ) * + , - . /
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
      0, 0, 0, 0, 2, 176, 176, 2, 0, 0, 0,  0,  0,  0,  0,  0,    //  64- 79 @ A B C D E F G H I J K L M N O
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    //  96-111 ` a b c d e f g h i j k l m n o
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 112-127 p q r s t u v w x y z { | } ~ .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 128-143 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 144-159 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 160-175 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 176-191 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 192-207 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 208-223 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 224-239 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0}};  // 240-255 . . . . . . . . . . . . . . . .

static constexpr std::array<uint8_t, 256> limits_15b              //
    {{0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 18, 18, 12, 12, 12, 12,   //   0- 15 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    //  16- 31 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    //  32- 47   ! " # $ % & ' ( ) * + , - . /
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
      0, 0, 0, 0, 1, 168, 168, 1, 0, 0, 0,  0,  0,  0,  0,  0,    //  64- 79 @ A B C D E F G H I J K L M N O
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    //  96-111 ` a b c d e f g h i j k l m n o
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 112-127 p q r s t u v w x y z { | } ~ .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 128-143 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 144-159 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 160-175 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 176-191 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 192-207 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 208-223 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 224-239 . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0}};  // 240-255 . . . . . . . . . . . . . . . .

#if 0

class APM_t final {
public:
  explicit APM_t(uint32_t n, uint32_t)
      : N{n * 24},  //
        _mask{n - 1},
        _hashtable{new uint32_t[N]},
        _ctx{0} {
    assert(ISPOWEROF2(n));
    for (uint32_t i{0}; i < N; ++i) {
      int32_t p{((int32_t(i % 24) * 4096) / (24 - 1)) - 2048};
      _hashtable[i] = (Squash(p) * (1U << 20)) & -16U;  // Conversion from -2048..2047 (clamped) into 0..4095
    }
  }

  virtual ~APM_t() noexcept;

  uint16_t p1(const bool bit, const int16_t pr, const uint32_t cx) noexcept {
    return Next(bit, pr, cx, 0x9776666665555554);
  }

  uint16_t p2(const bool bit, const int16_t pr, const uint32_t cx) noexcept {
    return Next(bit, pr, cx, 0x9887777776666664);
  }

private:
  APM_t(const APM_t&) = delete;
  APM_t(APM_t&&) = delete;
  APM_t& operator=(const APM_t&) = delete;
  APM_t& operator=(APM_t&&) = delete;

  uint16_t Next(const bool bit, int32_t pr, uint32_t cx, const uint64_t speedTable) noexcept {
    uint32_t prediction{_hashtable[_ctx]};
    uint32_t speedIndex{0xF & prediction};
    const uint32_t speed{uint32_t(0xF & (speedTable >> (speedIndex * 4)))};
    if (bit) {
      prediction += ~prediction >> speed;
    } else {
      prediction -= prediction >> speed;
    }
    if (speedIndex < 0xF) {
      ++speedIndex;
    }
    _hashtable[_ctx] = (prediction & -16U) | speedIndex;

    pr = (pr + 2048) * (24 - 1);
    uint32_t wt = pr & 0xFFF;  // interpolation weight of next element
    cx = ((cx & _mask) * 24) + uint32_t(pr >> 12);
    assert(cx < (N - 1));
    _ctx = cx + (wt >> 11);
    uint32_t vx{_hashtable[cx]};
    uint32_t vy{_hashtable[cx + 1]};
    uint32_t vz{(vy >> 12) - (vx >> 12)};
    uint16_t px{uint16_t(((vz * wt) + vx) >> 20)};
    assert(px < 0x1000);
    return px;
  }

  const uint32_t N;      // Number of contexts
  const uint32_t _mask;  // ctx limit
  uint32_t* _hashtable;  // ctx -> prediction
  uint32_t _ctx;         // Context of last prediction
};
APM_t::~APM_t() noexcept {
  delete[] _hashtable;
  _hashtable = nullptr;
}

#else

class APM_t final {
public:
  explicit APM_t(uint32_t n, uint32_t start)
      : N{(n * 24) + 1},  //
        _mask{n - 1},
        _table{static_cast<uint32_t*>(std::calloc(N, sizeof(uint32_t)))},
        _t{_table} {
    assert(ISPOWEROF2(n));
    if (verbose) {
      fprintf(stdout, "%" PRId64 " KiB for APM_t\n", (N * sizeof(uint32_t)) / INT64_C(1024));
    }

    for (uint32_t i{0}; i < N; ++i) {
      const auto p{int16_t(((int32_t(i % 24) * 4096) / (24 - 1)) - 2048)};
      _table[i] = (Squash(p)) * (1U << 20) + start;  // Conversion from -2048..2047 (clamped) into 0..4095
    }

    for (size_t j{0}; j < _dt.size(); ++j) {
      _dt[j] = (40 * 128) / (int32_t(j) + 4);   // 40 is based on enwik9
      _dta[j] = (32 * 128) / (int32_t(j) + 4);  // 32 is based on enwik9
    }
  }

  virtual ~APM_t() noexcept;

  APM_t() = delete;
  APM_t(const APM_t&) = delete;
  APM_t(APM_t&&) = delete;
  auto operator=(const APM_t&) -> APM_t& = delete;
  auto operator=(APM_t&&) -> APM_t& = delete;

  [[nodiscard]] auto p1(const bool bit, int32_t pr, uint32_t cx) noexcept -> uint16_t {
    const auto count{*_t & 0x3FF};
    const auto prediction{int32_t(*_t >> 12)};
    *_t += (uint32_t(((bit << 20) - prediction) * _dt[count] + 0x380) & -0x400U) + (count < 0x3FF);  // (896) 28*32 is based on enwik9
    return Next(pr, cx);
  }

  [[nodiscard]] auto p2(const bool bit, int32_t pr, uint32_t cx) noexcept -> uint16_t {
    const auto count{*_t & 0x3FF};
    const auto prediction{int32_t(*_t >> 12)};
    *_t += (uint32_t(((bit << 20) - prediction) * _dta[count] + 0x180) & -0x400U) + (count < 0x3FF);  // (384) 11*32 is based on enwik9
    return Next(pr, cx);
  }

private:
  [[nodiscard]] auto Next(int32_t pr, uint32_t cx) noexcept -> uint16_t {
    pr = (24 - 1) * (pr + 2048);          // Conversion from -2048..2047 into 0..94185
    const auto wt{uint16_t(0xFFF & pr)};  // interpolation weight of next element
    cx = (24 * (cx & _mask)) + uint32_t(pr >> 12);
    assert(cx < (N - 1));
    _t = &_table[cx];
    const uint64_t vx{_t[0]};
    const uint64_t vy{_t[1]};
    _t += wt >> 11;
    const auto px{uint16_t(((vx << 12) + ((vy - vx) * wt)) >> 32)};
    assert(px < 0x1000);
    return px;
  }

  const uint32_t N;      // Number of contexts
  const uint32_t _mask;  // ctx limit
  uint32_t* __restrict _table;
  uint32_t* __restrict _t;
  std::array<int32_t, 1024> _dt;
  std::array<int32_t, 1024> _dta;
};
APM_t::~APM_t() noexcept {
  std::free(_table);
  _table = nullptr;
}

#endif

class APM final {
public:
  explicit APM(uint32_t n)
      : N{n - 1},  //
        _table{static_cast<uint16_t*>(std::calloc(n * 33, sizeof(uint16_t)))},
        _t{_table} {
    if (verbose) {
      fprintf(stdout, "%" PRId64 " KiB for APM\n", (n * 33 * sizeof(uint16_t)) / INT64_C(1024));
    }
    for (uint32_t j{0}; j < 33; ++j) {
      _table[j] = uint16_t(Squash(int16_t((int32_t(j) - 16) * 128)) * 16);  // Conversion from -2048..2047 (clamped) into 0..4095
    }
    for (uint32_t i{33}; i < (n * 33); ++i) {
      _table[i] = _table[i - 33];
    }
  }

  virtual ~APM() noexcept;

  APM() = delete;
  APM(const APM&) = delete;
  APM(APM&&) = delete;
  auto operator=(const APM&) -> APM& = delete;
  auto operator=(APM&&) -> APM& = delete;

  [[nodiscard]] auto Predict(const bool bit, const uint16_t px, const uint32_t cx, const int32_t rate) noexcept -> uint16_t {
    const auto g{(bit << 16) + (bit << rate) - bit - bit};

    _t[0] = uint16_t(_t[0] + ((g - _t[0]) >> rate));
    _t[1] = uint16_t(_t[1] + ((g - _t[1]) >> rate));

    const auto pr{Stretch(px)};          // Conversion from 0..4095 into -2048..2047
    const auto wt{uint16_t(pr & 0x7F)};  // interpolation weight (33 points)

    const auto ctx{uint32_t((pr + 2048) >> 7) + (cx & N) * 33};
    _t = &_table[ctx];

    const auto vx{_t[0]};
    const auto vy{_t[1]};
    const auto py{uint16_t(((vx << 7) - ((vx - vy) * wt)) >> 11)};
    assert(py < 0x1000);
    return py;
  }

private:
  const uint32_t N;             // number of contexts
  int32_t : 32;                 // Padding
  uint16_t* __restrict _table;  // [N][33]:  p, context -> p
  uint16_t* __restrict _t;      //
};
APM::~APM() noexcept {
  std::free(_table);
  _table = nullptr;
}

[[nodiscard]] static auto safe_add(const int32_t a, const int32_t b) noexcept -> int32_t {
  if (a >= 0) {
    if (b > (INT_MAX - a)) {
      return INT_MAX;  // handle overflow
    }
  } else {
    if (b < (INT_MIN - a)) {
      return INT_MIN;  // handle underflow
    }
  }
  return a + b;
}

// Mixer - combines models using neural networks
class Mixer_t final {
public:
  static constexpr uint32_t N_LAYERS{9};  // Number of neurons in the input layer

  Mixer_t() : mxr_ctx{&_wx[0]} {
    _tx.fill(0);
    _wx.fill(0xA00);
  }

  ~Mixer_t() noexcept = default;

  Mixer_t(const Mixer_t&) = delete;
  Mixer_t(Mixer_t&&) = delete;
  auto operator=(const Mixer_t&) -> Mixer_t& = delete;
  auto operator=(Mixer_t&&) -> Mixer_t& = delete;

  static std::array<int16_t, N_LAYERS> _tx;
  static std::array<int32_t, N_LAYERS * 1280> _wx;

  void Update(const int16_t err) noexcept {  // train ...
    for (auto i{N_LAYERS}; i--;) {
#if 1
      mxr_ctx[i] += ((_tx[i] * err) + (1 << (14 - 1))) >> 14;
#else
      mxr_ctx[i] = safe_add(mxr_ctx[i], ((_tx[i] * err) + (1 << (14 - 1))) >> 14);
#endif
    }
  }

  [[nodiscard]] auto Predict() noexcept -> int16_t {  // dot product ...
    auto sum{0};
    for (uint32_t i{N_LAYERS}; i--;) {
      sum += mxr_ctx[i] * _tx[i];
    }
    const auto pr{sum / (1 << DP_SHIFT)};
    return clamp12(pr);
  }

  void Context(int32_t* __restrict ctx) noexcept {
    mxr_ctx = ctx;
  }

private:
  int32_t* __restrict mxr_ctx;
};

std::array<int16_t, Mixer_t::N_LAYERS> Mixer_t::_tx;
std::array<int32_t, Mixer_t::N_LAYERS * 1280> Mixer_t::_wx;

template <const auto N_LAYERS>
class Blend_t final {
public:
  explicit Blend_t(const uint32_t n)
      : _mask{n - 1},  //
        _weights{static_cast<int32_t*>(std::calloc(n * N_LAYERS, sizeof(int32_t)))},
        _wt{_weights} {
    assert(ISPOWEROF2(n));
    if (verbose) {
      fprintf(stdout, "%" PRId64 " KiB for Blend_t\n", (n * N_LAYERS * sizeof(int32_t)) / INT64_C(1024));
    }
    for (auto i{n * N_LAYERS}; i--;) {
      _weights[i] = 1 << 23;
    }
  }

  virtual ~Blend_t() noexcept {
    std::free(_weights);
    _weights = nullptr;
  }

  Blend_t() = delete;
  Blend_t(const Blend_t&) = delete;
  Blend_t(Blend_t&&) = delete;
  auto operator=(const Blend_t&) -> Blend_t& = delete;
  auto operator=(Blend_t&&) -> Blend_t& = delete;

  [[nodiscard]] auto Set() const noexcept -> int16_t* {
    return _new;
  }

  [[nodiscard]] auto Predict(const bool bit, const uint32_t lastpr, const uint32_t ctx, const int32_t rate) noexcept -> int16_t {
    assert(lastpr < 4096);

    const auto err{(bit << 12) - int32_t(lastpr) - bit};

    for (auto i{N_LAYERS}; i--;) {  // train ...
#if 1
      _wt[i] += (_prev[i] * err) >> rate;
#else
      _wt[i] = safe_add(_wt[i], (_prev[i] * err) >> rate);
#endif
    }

    _wt = &_weights[(ctx & _mask) * N_LAYERS];

    int64_t pr{0};
    for (auto i{N_LAYERS}; i--;) {  // dot product ...
      pr += int64_t(_wt[i]) * int64_t(_new[i]);
    }

    std::swap(_new, _prev);

    return int16_t(pr >> 25);
  }

private:
  const uint32_t _mask;                       // n-1
  int32_t : 32;                               // Padding
  int32_t* __restrict _weights;               // weights, scaled 24 bits
  int32_t* __restrict _wt;                    // weights, scaled 24 bits
  std::array<int16_t, 2 * N_LAYERS> _pi{};    // Prediction inputs
  int16_t* __restrict _new{&_pi[0]};          // New Inputs (alternating between _pi[0] and _pi[N_LAYERS])
  int16_t* __restrict _prev{&_pi[N_LAYERS]};  // Previous Inputs (alternating between _pi[0] and _pi[N_LAYERS])
};

class HashTable final {
public:
  explicit HashTable(const uint64_t max_size)
      : N{(max_size > mem_limit) ? mem_limit : max_size},  //
        NB{uint32_t((N / B) - 1)},
        _ptr{static_cast<uint8_t*>(_aligned_malloc(N, 64))},
        _hashtable{_ptr + 1} {
    assert(ISPOWEROF2(N));
    assert(_ptr);
    if (verbose) {
      fprintf(stdout, "%" PRId64 " KiB for HashTable\n", N / INT64_C(1024));
    }
    memset(_ptr, 0, N);
  }

  virtual ~HashTable() noexcept;

  HashTable(const HashTable&) = delete;
  HashTable(HashTable&&) = delete;
  auto operator=(const HashTable&) -> HashTable& = delete;
  auto operator=(HashTable&&) -> HashTable& = delete;

  [[nodiscard]] auto get(const uint32_t i) const noexcept -> uint8_t* {
    const auto chk{uint8_t(i >> 24)};  // 8 bits
    const auto idx{uint64_t(i & NB) * B};

    auto p{&_hashtable[idx]};
    if (chk == *(p - 1)) {  // idx+0 ?
      return p;
    }
    auto const q{&_hashtable[idx ^ B]};
    if (chk == *(q - 1)) {  // idx^4 ?
      return q;
    }

    if (*p > *q) {
      p = q;
    }

    *(p - 1) = chk;
    *(p + 0) = 0;
    *(p + 1) = 0;
    *(p + 2) = 0;
    return p;
  }

  [[nodiscard]] auto get1x(const uint8_t o, const uint32_t i) const noexcept -> uint8_t* {
    const auto chk{uint8_t(o | (i >> 27))};  // 3 + 5 bits
    const auto idx{uint64_t(i & NB) * B};

    auto p{&_hashtable[idx]};
    if (chk == *(p - 1)) {  // idx+0 ?
      return p;
    }
    auto const q{&_hashtable[idx ^ B]};
    if (chk == *(q - 1)) {  // idx^4 ?
      return q;
    }

    if (*p > *q) {
      p = q;
    }

    *(p - 1) = chk;
    *(p + 0) = 0;
    *(p + 1) = 0;
    *(p + 2) = 0;
    return p;
  }

  [[nodiscard]] auto get3a(const uint8_t o, const uint32_t i) const noexcept -> uint8_t* {
    const auto chk{uint8_t(o | (i >> 27))};  // 3 + 5 bits
    const auto idx{uint64_t(i & NB) * B};

    auto p{&_hashtable[idx]};
    if (chk == *(p - 1)) {  // idx+0 ?
      return p;
    }
    auto const q{&_hashtable[idx ^ (B + B + B)]};
    if (chk == *(q - 1)) {  // idx^12 ?
      return q;
    }
    auto const r{&_hashtable[idx ^ (B + B)]};
    if (chk == *(r - 1)) {  // idx^8 ?
      return r;
    }
    auto const s{&_hashtable[idx ^ B]};
    if (chk == *(s - 1)) {  // idx^4 ?
      return s;
    }

    // clang-format off
    if (*p > *q) { p = q; }
    if (*p > *r) { p = r; }
    if (*p > *s) { p = s; }
    // clang-format on

    *(p - 1) = chk;
    *(p + 0) = 0;
    *(p + 1) = 0;
    *(p + 2) = 0;
    return p;
  }

  [[nodiscard]] auto get3b(const uint8_t o, const uint32_t i) const noexcept -> uint8_t* {
    const auto chk{uint8_t(o | (i >> 27))};  // 3 + 5 bits
    const auto idx{uint64_t(i & NB) * B};

    auto p{&_hashtable[idx]};
    if (chk == *(p - 1)) {  // idx+0 ?
      return p;
    }
    auto const q{&_hashtable[idx ^ (B + B)]};
    if (chk == *(q - 1)) {  // idx^8 ?
      return q;
    }
    auto const r{&_hashtable[idx ^ (B + B + B)]};
    if (chk == *(r - 1)) {  // idx^12 ?
      return r;
    }
    auto const s{&_hashtable[idx ^ B]};
    if (chk == *(s - 1)) {  // idx^4 ?
      return s;
    }

    // clang-format off
    if (*p > *q) { p = q; }
    if (*p > *r) { p = r; }
    if (*p > *s) { p = s; }
    // clang-format on

    *(p - 1) = chk;
    *(p + 0) = 0;
    *(p + 1) = 0;
    *(p + 2) = 0;
    return p;
  }

private:
  static constexpr auto B{4};
  static constexpr auto mem_limit{UINT64_C(0x400000000)};  // 16 GiB

  const uint64_t N;
  const uint32_t NB;
  int32_t : 32;  // Padding
  uint8_t* const __restrict _ptr;
  uint8_t* const __restrict _hashtable;
};
HashTable::~HashTable() noexcept {
  _aligned_free(_ptr);
}

static std::array<uint8_t*, 5> cp{{nullptr, nullptr, nullptr, nullptr, nullptr}};

// Golden ratio of 2^32 (not a prime)
static constexpr auto PHI32{UINT32_C(0x9E3779B9)};  // 2654435769

// Golden ratio of 2^64 (not a prime)
static constexpr auto PHI64{UINT64_C(0x9E3779B97F4A7C15)};  // 11400714819323198485

// Some more arbitrary magic (prime) numbers
static constexpr auto MUL64_01{UINT64_C(0x993DDEFFB1462949)};
static constexpr auto MUL64_02{UINT64_C(0xE9C91DC159AB0D2D)};
// static constexpr auto MUL64_03{UINT64_C(0x83D6A14F1B0CED73)};
// static constexpr auto MUL64_04{UINT64_C(0xA14F1B0CED5A841F)};
// static constexpr auto MUL64_05{UINT64_C(0xC0E51314A614F4EF)};
// static constexpr auto MUL64_06{UINT64_C(0xDA9CC2600AE45A27)};
// static constexpr auto MUL64_07{UINT64_C(0x826797AA04A65737)};
// static constexpr auto MUL64_08{UINT64_C(0x2375BE54C41A08ED)};
// static constexpr auto MUL64_09{UINT64_C(0xD39104E950564B37)};
// static constexpr auto MUL64_10{UINT64_C(0x3091697D5E685623)};
// static constexpr auto MUL64_11{UINT64_C(0x20EB84EE04A3C7E1)};
// static constexpr auto MUL64_12{UINT64_C(0xF501F1D0944B2383)};
// static constexpr auto MUL64_13{UINT64_C(0xE3E4E8AA829AB9B5)};

[[nodiscard]] ALWAYS_INLINE static constexpr auto hash(const uint64_t x0) noexcept -> uint64_t {
  uint64_t ctx{(x0 + 1) * PHI64};
  return ((ctx << 32) | (ctx >> 32));
}

[[nodiscard]] ALWAYS_INLINE static constexpr auto hash(const uint64_t x0, const uint64_t x1) noexcept -> uint64_t {
  uint64_t ctx{hash(x0)};
  ctx += (x1 + 1) * MUL64_01;
  return (ctx << 32) | (ctx >> 32);
}

[[nodiscard]] ALWAYS_INLINE static constexpr auto hash(const uint64_t x0, const uint64_t x1, const uint64_t x2) noexcept -> uint64_t {
  uint64_t ctx{hash(x0, x1)};
  ctx += (x2 + 1) * MUL64_02;
  return (ctx << 32) | (ctx >> 32);
}

[[nodiscard]] ALWAYS_INLINE static constexpr auto combine64(const uint64_t seed, const uint64_t x) noexcept -> uint64_t {
  return hash(seed + x);
}

[[nodiscard]] ALWAYS_INLINE static constexpr auto finalize64(const uint64_t hash, const uint32_t hashbits) noexcept -> uint32_t {
  assert(hashbits <= 64);
  return uint32_t(hash >> (64 - hashbits));
}

template <const uint32_t SIZE>
class StateMap_t final {
  static_assert(ISPOWEROF2(SIZE), "Size of state map must a power of two");

public:
  StateMap_t() {
    _smt.fill(0x7FFF);  // No prediction
  }
  virtual ~StateMap_t() noexcept = default;

  StateMap_t(const StateMap_t&) = delete;
  StateMap_t(StateMap_t&&) = delete;
  auto operator=(const StateMap_t&) -> StateMap_t& = delete;
  auto operator=(StateMap_t&&) -> StateMap_t& = delete;

  [[nodiscard]] constexpr auto operator[](const uint32_t i) noexcept -> uint16_t& {
    return _smt[i];
  }

  [[nodiscard]] auto Update(const bool bit, const uint32_t ctx, const int32_t rate) noexcept -> int16_t {
    uint16_t& balz{_smt[_ctx]};
    balz = uint16_t(bit ? (balz + (uint16_t(~balz) >> rate)) : (balz - (balz >> rate)));
    _ctx = ctx & (SIZE - 1);
    return Stretch(_smt[_ctx] / 16);  // Conversion from 0..4095 into -2048..2047
  }

private:
  uint32_t _ctx{0};
  std::array<uint16_t, SIZE> _smt;
  int32_t : 32;  // Padding
};

template <const uint32_t SIZE>
class RunContextMap_t final {
public:
  explicit RunContextMap_t() = default;
  virtual ~RunContextMap_t() = default;

  RunContextMap_t(const RunContextMap_t&) = delete;
  RunContextMap_t(RunContextMap_t&&) = delete;
  auto operator=(const RunContextMap_t&) -> RunContextMap_t& = delete;
  auto operator=(RunContextMap_t&&) -> RunContextMap_t& = delete;

  void Set(const uint32_t cx) noexcept {  // update count
    if ((0 == _cp[0]) || ((0xFF & gC4) != _cp[1])) {
      _cp[0] = 1;
      _cp[1] = 0xFF & gC4;
    } else if (_cp[0] < 255) {
      ++_cp[0];
    }
    _cp = &_t[cx & (SIZE - 1)][0];
  }

  [[nodiscard]] auto Predict() noexcept -> int16_t {  // predict next bit
    const uint8_t counts{_cp[0]};
    if (0 != counts) {
      const uint8_t expected_byte{_cp[1]};
      if ((expected_byte | 0x100u) >> (1 + gBcount) == gC0) {
        const auto expected_bit{1 & (expected_byte >> gBcount)};
        return int16_t(_ctp[counts] * ((expected_bit * 2) - 1));
      }
    }

    return 0;  // No or misprediction
  }

private:
  std::array<std::array<uint8_t, 2>, SIZE> _t{};
  uint8_t* __restrict _cp{&_t[0][0]};

#if 0
    const double a = 4.0
    std::array<double, 0x100> t;
    for (uint32_t n = 0; n < 256; ++n) {
      t[n] = std::log(((double(n) * a) + 1.0));
    }
    const double scale{2047.0 / t[255]};
    for (uint32_t n = 0; n < 256; ++n) {
      t[n] *= scale;
    }
    for (uint32_t n = 0; n < 256; ++n) {
      _ctp[n] = int16_t(std::lround(t[n]));
    }
#endif
  // Counts to prediction
  static constexpr std::array<int16_t, 0x100> _ctp{{0,    475,  649,  758,  837,  899,  951,  995,  1033, 1067, 1097, 1125, 1150, 1173, 1194, 1215,  //
                                                    1233, 1251, 1268, 1283, 1298, 1313, 1326, 1339, 1352, 1364, 1375, 1386, 1397, 1407, 1417, 1426,  //
                                                    1436, 1445, 1454, 1462, 1470, 1478, 1486, 1494, 1501, 1509, 1516, 1523, 1529, 1536, 1542, 1549,  //
                                                    1555, 1561, 1567, 1573, 1578, 1584, 1589, 1595, 1600, 1605, 1610, 1616, 1620, 1625, 1630, 1635,  //
                                                    1639, 1644, 1649, 1653, 1657, 1662, 1666, 1670, 1674, 1678, 1682, 1686, 1690, 1694, 1698, 1701,  //
                                                    1705, 1709, 1712, 1716, 1720, 1723, 1726, 1730, 1733, 1737, 1740, 1743, 1746, 1749, 1753, 1756,  //
                                                    1759, 1762, 1765, 1768, 1771, 1774, 1777, 1780, 1782, 1785, 1788, 1791, 1794, 1796, 1799, 1802,  //
                                                    1804, 1807, 1810, 1812, 1815, 1817, 1820, 1822, 1825, 1827, 1830, 1832, 1834, 1837, 1839, 1841,  //
                                                    1844, 1846, 1848, 1850, 1853, 1855, 1857, 1859, 1862, 1864, 1866, 1868, 1870, 1872, 1874, 1876,  //
                                                    1878, 1880, 1882, 1884, 1886, 1888, 1890, 1892, 1894, 1896, 1898, 1900, 1902, 1904, 1906, 1908,  //
                                                    1909, 1911, 1913, 1915, 1917, 1919, 1920, 1922, 1924, 1926, 1927, 1929, 1931, 1933, 1934, 1936,  //
                                                    1938, 1939, 1941, 1943, 1944, 1946, 1947, 1949, 1951, 1952, 1954, 1955, 1957, 1959, 1960, 1962,  //
                                                    1963, 1965, 1966, 1968, 1969, 1971, 1972, 1974, 1975, 1977, 1978, 1980, 1981, 1983, 1984, 1985,  //
                                                    1987, 1988, 1990, 1991, 1992, 1994, 1995, 1997, 1998, 1999, 2001, 2002, 2003, 2005, 2006, 2007,  //
                                                    2009, 2010, 2011, 2013, 2014, 2015, 2017, 2018, 2019, 2020, 2022, 2023, 2024, 2025, 2027, 2028,  //
                                                    2029, 2030, 2032, 2033, 2034, 2035, 2036, 2038, 2039, 2040, 2041, 2042, 2044, 2045, 2046, 2047}};
};

template <const uint32_t SIZE, const int32_t RATE0, const int32_t RATE1, const int32_t RATE2>
class ContextMap_t final {
public:
  explicit ContextMap_t() = default;
  virtual ~ContextMap_t() = default;

  ContextMap_t(const ContextMap_t&) = delete;
  ContextMap_t(ContextMap_t&&) = delete;
  auto operator=(const ContextMap_t&) -> ContextMap_t& = delete;
  auto operator=(ContextMap_t&&) -> ContextMap_t& = delete;

  void Set(const uint32_t ctx) {
    _ctx = ctx << 8;
    _rc.Set(ctx);
  }

  void Predict(int16_t* __restrict& pr, const bool bit) noexcept {
    const auto& st{bit ? StateTableY1 : StateTableY0};

    _cs[0] = st[0][_cs[0]];
    _cs[1] = st[1][_cs[1]];
    _cs[2] = st[2][_cs[2]];

    const auto ctx{(7 == gBcount) ? (0xFF & gC4) : gC0};
    _cs = &_st[(_ctx | ctx) & _mask][0];

    *pr++ = _stp[0].Update(bit, _cs[0], RATE0);
    *pr++ = _stp[1].Update(bit, _cs[1], RATE1);
    *pr++ = _stp[2].Update(bit, _cs[2], RATE2);
    *pr++ = _rc.Predict();
  }

private:
  std::array<std::array<uint8_t, 3>, (SIZE * 256)> _st{};
  std::array<StateMap_t<0x100>, 3> _stp{};  // states to prediction

  uint8_t* __restrict _cs{&_st[0][0]};
  const uint32_t _mask{(SIZE * 256) - 1};
  uint32_t _ctx{0};

  RunContextMap_t<SIZE> _rc{};
};

class DynamicMarkovCmp_t final {
public:
  explicit DynamicMarkovCmp_t(const uint64_t max_size)
      : _max_size_bytes{(max_size > mem_limit) ? mem_limit : max_size},
        _max_nodes{uint32_t(_max_size_bytes / sizeof(Node))},
        _nodes{reinterpret_cast<Node*>(std::calloc(_max_size_bytes, sizeof(int8_t)))} {
    assert(0 == (_max_nodes >> 28));  // the top 4 bits must be unused by nx0 and nx1 for storing the 4+4 bits of the bit history state byte
    if (verbose) {
      fprintf(stdout, "%" PRId64 " KiB for DMC_t\n", (_max_size_bytes * sizeof(int8_t)) / INT64_C(1024));
    }
    Flush();
  }
  ~DynamicMarkovCmp_t() noexcept;
  DynamicMarkovCmp_t() = delete;
  DynamicMarkovCmp_t(const DynamicMarkovCmp_t&) = delete;
  DynamicMarkovCmp_t(DynamicMarkovCmp_t&&) = delete;
  auto operator=(const DynamicMarkovCmp_t&) -> DynamicMarkovCmp_t& = delete;
  auto operator=(DynamicMarkovCmp_t&&) -> DynamicMarkovCmp_t& = delete;

#define INCREMENT(x, increment, rate) uint16_t(((((x) << (rate)) - (x)) >> (rate)) + ((increment) << (16 - (rate))))

  void Predict(const bool bit) noexcept {
    Node& curr{_nodes[_curr]};

    const auto n{curr.count[bit]};

    if (bit) {
      curr.count[0] = INCREMENT(curr.count[0], 0, 6);
      curr.count[1] = INCREMENT(curr.count[1], 1, 6);

      curr.state = StateTableY1[0][curr.state];
    } else {
      curr.count[0] = INCREMENT(curr.count[0], 1, 6);
      curr.count[1] = INCREMENT(curr.count[1], 0, 6);

      curr.state = StateTableY0[0][curr.state];
    }

    if (n > _threshold) {
      const auto next{uint32_t(bit ? curr.nx1 : curr.nx0)};
      auto n0{_nodes[next].count[0]};
      auto n1{_nodes[next].count[1]};
      const auto nn{uint32_t(n0 + n1)};

      if (nn > (n + _threshold)) {
        const auto top_count0{MulDiv(n0, n, nn)};  // 16+16-16
        assert(n0 >= top_count0);

        const auto top_count1{MulDiv(n1, n, nn)};
        assert(n1 >= top_count1);

        n0 -= top_count0;
        n1 -= top_count1;

        assert((n0 + n1) > 0);

        _nodes[_top].count[0] = top_count0;
        _nodes[_top].count[1] = top_count1;

        _nodes[next].count[0] = n0;
        _nodes[next].count[1] = n1;

        _nodes[_top].all = _nodes[next].all;  // Clone nx0,nx1 and state

        if (bit) {
          curr.nx1 = 0x0FFFFFFFu & _top;
        } else {
          curr.nx0 = 0x0FFFFFFFu & _top;
        }

        if (++_top > _max_nodes) {
          Flush();
        }

        if (_threshold < (47 * 256)) {  // Threshold of 47 is based on enwik9
          _threshold = ++_threshold_fine >> 11;
        }
      }
    }

    _curr = uint32_t(bit ? curr.nx1 : curr.nx0);

    int16_t* const __restrict pr = _blend.Set();
    pr[0] = Predict();                                 // DMC prediction -2048..2047
    pr[1] = _sm2.Update(bit, _nodes[_curr].state, 6);  // Rate of 6 is based on enwik9

    // Little improvements of DMC predictions
    pr[2] = _sm3.Update(bit, (gC4 << 8) | gC0, 2);  // Rate of 2 is based on enwik9
    pr[3] = _sm4.Update(bit, (gTt << 8) | gC0, 1);  // Rate of 1 is based on enwik9
    pr[4] = _sm5.Update(bit, /*  */ gC2 | gC0, 1);  // Rate of 1 is based on enwik9
    pr[5] = _sm6.Update(bit, (gX5 << 8) | gC0, 2);  // Rate of 2 is based on enwik9

    const auto last_pr{Squash(Mixer_t::_tx[7])};  // Conversion from -2048..2047 (clamped) into 0..4095
    const auto ctx{(gW5 << 3) | gBcount};
    const auto px{_blend.Predict(bit, last_pr, ctx, 2)};  // Rate of 2 is based on enwik9
    Mixer_t::_tx[7] = clamp12(px);
  }

private:
  [[nodiscard]] auto Predict() const noexcept -> int16_t {
    const auto n0{_nodes[_curr].count[0]};
    if (!n0) {
      return 0x7FF;
    }
    const auto n1{_nodes[_curr].count[1]};
    if (!n1) {
      return ~0x7FF;
    }
    const auto pr{MulDiv(0xFFFu, n1, n0 + n1)};  // (0xFFFu * n1) / (n0 + n1)
    return Stretch(pr);                          // Conversion from 0..4095 into -2048..2047
  }

#pragma pack(push, 1)
  struct Node {
    union {
      uint64_t all;
      struct {
        uint64_t nx0 : 28;
        uint64_t nx1 : 28;
        uint64_t state : 8;
      };
    };
    std::array<uint16_t, 2> count;
  };
#pragma pack(pop)
  static_assert(0 == offsetof(Node, all), "Alignment failure in DMC node");
  static_assert(8 == offsetof(Node, count), "Alignment failure in DMC node");
  static_assert(12 == sizeof(Node), "Alignment failure in DMC node");

  static constexpr auto mem_limit{(UINT64_C(1) << 28) * sizeof(Node)};  // 3 GiB

  static constexpr uint32_t init_count{509};  // Initial value of counter, preferably a prime number
  static constexpr uint32_t threshold{1205};  // Threshold of when to clone (based on enwik9 with INIT_COUNT=509)

  // Does '(x * y) / z' with rounding
  [[nodiscard]] ALWAYS_INLINE static constexpr auto MulDiv(const uint32_t x, const uint32_t y, const uint32_t z) noexcept -> uint16_t {
    assert(z > 0);
    return uint16_t(((2 * (x * y)) + z) / (z + z));
  }

  void Flush() noexcept {
    _threshold = threshold;
    _threshold_fine = threshold << 11;
    _top = 0;
    _curr = 0;
    for (uint32_t j{0}; j < 256; ++j) {                                     // 256 trees
      for (uint32_t i{0}; i < 255; ++i) {                                   // 255 nodes in each tree
        if (i < 127) {                                                      // Internal tree nodes
          _nodes[_top].nx0 = ((1u << 28) - 1) & (_top + i + 1);             // Left node
          _nodes[_top].nx1 = ((1u << 28) - 1) & (_top + i + 2);             // Right node
        } else {                                                            // 128 leaf nodes - they each references a root node of tree(i)
          const uint32_t linked_tree_root{(i - 127) * 2 * 255};             //
          _nodes[_top].nx0 = ((1u << 28) - 1) & linked_tree_root;           // Left node -> root of tree 0,2,4,...
          _nodes[_top].nx1 = ((1u << 28) - 1) & (linked_tree_root + 255u);  // Right node -> root of tree 1,3,5,...
        }
        _nodes[_top].state = 0;
        _nodes[_top].count[0] = init_count;
        _nodes[_top].count[1] = init_count;
        _top++;
      }
    }
  }

  const uint64_t _max_size_bytes;
  const uint32_t _max_nodes;
  uint32_t _top{0};
  Node* __restrict _nodes;
  uint32_t _curr{0};
  uint32_t _threshold{0};
  uint32_t _threshold_fine{0};
  int32_t : 32;                // Padding
  StateMap_t<0x100> _sm2{};    // state
  StateMap_t<0x1000> _sm3{};   // gC4
  StateMap_t<0x1000> _sm4{};   // gTt
  StateMap_t<0x10000> _sm5{};  // gC2
  StateMap_t<0x40000> _sm6{};  // gX5
  Blend_t<6> _blend{0x40000};  // gW5
};
DynamicMarkovCmp_t::~DynamicMarkovCmp_t() noexcept {
  std::free(_nodes);
  _nodes = nullptr;
}

class LempelZivPredict_t final {  // MatchModel
  enum : uint32_t {
    MINLEN = 7,           // Minimum required match length
    MAXLEN = MINLEN + 63  // Longest allowed match (max 6 bits, after subtraction of minimum length)
  };

  [[nodiscard]] static auto countbits(uint64_t x) noexcept -> uint32_t {
    uint32_t n{0};
    while (x) {
      ++n;
      x >>= 1;
    }
    return n;
  }

public:
  explicit LempelZivPredict_t(const Buffer_t& __restrict buf, const uint64_t max_size)
      : _buf{buf},  //
        _hashbits{countbits(((max_size > mem_limit) ? mem_limit : max_size) - UINT64_C(1))},
        _ht{static_cast<uint32_t*>(std::calloc((UINT64_C(1) << _hashbits) + UINT64_C(1), sizeof(uint32_t)))} {
    assert(ISPOWEROF2(max_size));
    if (verbose) {
      fprintf(stdout, "%" PRId64 " KiB for LZP_t\n", (((UINT64_C(1) << _hashbits) + UINT64_C(1)) * sizeof(uint32_t)) / INT64_C(1024));
    }
  }

  virtual ~LempelZivPredict_t() noexcept;

  LempelZivPredict_t() = delete;
  LempelZivPredict_t(const LempelZivPredict_t&) = delete;
  LempelZivPredict_t(LempelZivPredict_t&&) = delete;
  auto operator=(const LempelZivPredict_t&) -> LempelZivPredict_t& = delete;
  auto operator=(LempelZivPredict_t&&) -> LempelZivPredict_t& = delete;

  void Update() noexcept {
    uint64_t h{0};
    for (auto n{MINLEN + 2}; n--;) {
      h = combine64(h, _buf(n + 1));
    }
    const auto idx{finalize64(h, _hashbits)};

    if (_match_length >= MINLEN) {
      _match_length += _match_length < MAXLEN;
      ++_match;
    } else {
      _match_length = 0;
      _match = _ht[idx];
      if (_match) {
        while ((_match_length < MAXLEN) && (_buf(_match_length + 1) == _buf[_match - _match_length - 1])) {
          ++_match_length;
        }
      }
    }
    _ht[idx] = _buf.Pos();

    _expected_byte = _buf[_match];

    _rc.Set((_match_length << 8) | gC1);
  }

  [[nodiscard]] auto Predict(const bool bit) noexcept -> uint32_t {
    if ((_match_length >= MINLEN) && (((_expected_byte | 0x100U) >> (1 + gBcount)) != gC0)) {
      _match_length = 0;
    }

    uint32_t order;

    int16_t* const __restrict pr = _blend.Set();

    if (_match_length >= MINLEN) {
      const auto length{_match_length - MINLEN};
      const auto expected_bit{1u & (_expected_byte >> gBcount)};

      const auto sign{int16_t((2 * expected_bit) - 1)};
      pr[0] = int16_t(sign * int16_t(length * 32));

      const auto ctx0{(length << 9) | (expected_bit << 8) | gC1};
      pr[1] = _sm.Update(bit, ctx0, 5);  // Rate of 5 is based on enwik9

      // Length to order, based on enwik9 (value must start with 9 and end with 4)
      const auto l2o{(7 == gBcount) ? UINT64_C(0x9999988888776654) : UINT64_C(0x9999998888776654)};
      order = uint32_t(0xF & (l2o >> (4 * (length / 4))));
    } else {
      pr[0] = 0;
      pr[1] = _sm.Update(bit, gC0, 2) / 2;  // Rate of 2 is based on enwik9

      order = 0;
      if (*cp[1]) {
        order = 1;
        if (*cp[2]) {
          order = 2;
          if (*cp[3]) {
            order = 3;
          }
        }
      }
    }

    pr[2] = _rc.Predict();

    const auto last_pr{Squash(Mixer_t::_tx[0])};  // Conversion from -2048..2047 (clamped) into 0..4095
    const auto ctx{(gW5 << 3) | gBcount};
    const auto px{_blend.Predict(bit, last_pr, ctx, 1)};  // Rate of 1 is based on enwik9
    Mixer_t::_tx[0] = clamp12(px);

    return order;
  }

private:
  static constexpr auto mem_limit{UINT64_C(0x100000000)};  // 4 GiB

  const Buffer_t& __restrict _buf;
  const uint32_t _hashbits;
  int32_t : 32;  // Padding
  uint32_t* __restrict _ht;
  uint32_t _match{0};
  uint32_t _match_length{0};
  uint32_t _expected_byte{0};
  int32_t : 32;                   // Padding
  StateMap_t<0x8000> _sm{};       // 6+1+8=15 bits
  RunContextMap_t<0x4000> _rc{};  // 6+8 bits
  Blend_t<3> _blend{0x40000};     // gW5
};
LempelZivPredict_t::~LempelZivPredict_t() noexcept {
  std::free(_ht);
  _ht = nullptr;
}

class SparseMatchModel_t final {
  enum {
    NBITS = 15,  // Size of look-up table (< 32)
    MINLEN = 2,  // Minimum required match length
    MAXLEN = 63  // Longest allowed match (max 6 bits)
  };

public:
  explicit SparseMatchModel_t(const Buffer_t& __restrict buf)
      : _buf{buf},  //
        _ht{static_cast<uint32_t*>(std::calloc((UINT64_C(1) << NBITS) + UINT64_C(1), sizeof(uint32_t)))} {}

  virtual ~SparseMatchModel_t() noexcept;
  SparseMatchModel_t() = delete;
  SparseMatchModel_t(const SparseMatchModel_t&) = delete;
  SparseMatchModel_t(SparseMatchModel_t&&) = delete;
  auto operator=(const SparseMatchModel_t&) -> SparseMatchModel_t& = delete;
  auto operator=(SparseMatchModel_t&&) -> SparseMatchModel_t& = delete;

  void Update() noexcept {
    const auto idx{((UINT32_C(1) << NBITS) - 1) & gC4};

    if (_match_length >= MINLEN) {
      _match_length += _match_length < MAXLEN;
      ++_match;
    } else {
      _match_length = 0;
      _match = _ht[idx];
      if (_match) {
        while ((_match_length < MAXLEN) && (_buf(_match_length + 1) == _buf[_match - _match_length - 1])) {
          ++_match_length;
        }
      }
    }
    _ht[idx] = _buf.Pos();

    _expected_byte = _buf[_match] | 0x100U;

    _cm0.Set(0);
    _cm1.Set(gTt);
    _cm2.Set(gX5);
  }

  void Predict(const bool bit) noexcept {
    if ((_match_length >= MINLEN) && ((_expected_byte >> (1 + gBcount)) != gC0)) {
      _match_length = 0;
    }

    int16_t* __restrict pr = _blend.Set();

    if (_match_length >= MINLEN) {
      const auto expected_bit{1 & (_expected_byte >> gBcount)};

      const auto sign{int16_t((2 * expected_bit) - 1)};
      *pr++ = int16_t(sign * int16_t(_match_length * 32));

      const auto ctx0{(_match_length << 9) | (expected_bit << 8) | gC1};
      *pr++ = _sm0.Update(bit, ctx0, 5);  // Rate of 5 is based on enwik9

      const auto ctx1{(_expected_byte << 11) | (gBcount << 8) | _buf(1)};
      *pr++ = _sm1.Update(bit, ctx1, 9);  // Rate of 9 is based on enwik9
    } else {
      *pr++ = 0;
      *pr++ = _sm0.Update(bit, gC1, 5) / 4;      // Rate of 5 is based on enwik9
      *pr++ = _sm1.Update(bit, _buf(1), 4) / 8;  // Rate of 4, division of 8 are based on enwik9
    }

    _cm0.Predict(pr, bit);
    _cm1.Predict(pr, bit);
    _cm2.Predict(pr, bit);

    const auto last_pr{Squash(Mixer_t::_tx[8])};  // Conversion from -2048..2047 (clamped) into 0..4095
    const auto ctx{(gW5 * 8u) | gBcount};
    const auto px{_blend.Predict(bit, last_pr, ctx, 3)};  // Rate of 3 is based on enwik9
    Mixer_t::_tx[8] = clamp12(px);
  }

private:
  const Buffer_t& __restrict _buf;
  uint32_t* const __restrict _ht;
  uint32_t _match{0};
  uint32_t _match_length{0};
  uint32_t _expected_byte{};
  int32_t : 32;                               // Padding
  ContextMap_t<0x001, 0xC, 0xA, 0xD> _cm0{};  //     gC0  Rate of 12/10/13 are based on enwik9
  ContextMap_t<0x100, 0xE, 0xD, 0x7> _cm1{};  // gTt|gC0  Rate of 14/13/ 7 are based on enwik9
  ContextMap_t<0x100, 0xC, 0x6, 0xE> _cm2{};  // gX5|gC0  Rate of 12/ 6/14 are based on enwik9
  StateMap_t<0x8000> _sm0{};                  // 6+1+8=15 bits
  StateMap_t<0x80000> _sm1{};                 // 8+3+8=19 bits
  Blend_t<3 + (3 * 4)> _blend{0x10000};
};
SparseMatchModel_t::~SparseMatchModel_t() noexcept {
  std::free(_ht);
}

/**
 * @class Txt_t
 * This is not really a prediction model. It is more of a state machine that
 * can follow the sequence of text preparation.
 * If the text preparation fails or is ineffective, this model does nothing.
 * If the text preparation is successful, it can follow the byte order of the
 * text preparation. It can predict single bits with 100% accuracy.
 * When a debug version is created, this accuracy is tested by means of an assert.
 * Therefore the function 'Predict' has a parameter 'bit',
 * normally (release build) it is not used.
 * This model is not "super" effective, but does not claim memory or heavy CPU usage.
 * It is very lightweight and small.
 * If the model is active, it predicts a few bits (2, 5 or 10), in line
 * with text preparation.
 */
class Txt_t final {
public:
  explicit Txt_t() = default;
  ~Txt_t() noexcept = default;

  Txt_t(const Txt_t&) = delete;
  Txt_t(Txt_t&&) = delete;
  auto operator=(const Txt_t&) -> Txt_t& = delete;
  auto operator=(Txt_t&&) -> Txt_t& = delete;

  /**
   * Skip a few bytes till the text-preparation sequence starts.
   */
  void Update() noexcept {
    if (_skip_bytes > 0) {
      --_skip_bytes;
    }
  }

  /**
   * Forecast a few bits with 100% accuracy
   * @param bit List bit seen
   * @param prediction Reference to the forecast (if any)
   * @return True when there is a forecast otherwise false (prediction is untouched!)
   */
  [[nodiscard]] auto Predict(const bool bit, uint16_t& prediction) noexcept -> bool {
    (void)bit;  // bit is only used for verification
    assert((0x7FF == _pr) || (bit && (0xFFF == _pr)) || (!bit && (0x000 == _pr)));

    if (!_start || (_skip_bytes > 0)) {
      _pr = 0x7FF;  // No prediction
      return false;
    }

    if (_value) {
      _prdct += _prdct;
      _value += _value;

      if (1 & (_value >> 31)) {
        if (1 & (_prdct >> 31)) {
          _pr = 0xFFF;  // Predict 1
          prediction = 0xFFF;
        } else {
          _pr = 0x000;  // Predict 0
          prediction = 0x000;
        }
        return true;
      }
    } else {
      if ((3 == gBcount) && (ESCAPE_CHAR != (0xFF & gC4)) && (0xC == (0xC & gC0))) {
        if (0xC == (0xE & gC0)) {
          // < MID --> 2 bits prediction
          //         C0      80
          //       0b110xxxxx10xxxxxx
          //         ^^^     pp
          _prdct = 0b00000000100000000000000000000000U << 4;
          _value = 0b00000000110000000000000000000000U << 4;
        } else if (0xE == (0xF & gC0)) {
          // < HIGH --> 5 bits prediction
          //         E0      C0      80
          //       0b1110xxxx110xxxxx10xxxxxx
          //         ^^^^    ppp     pp
          _prdct = 0b00000000110000001000000000000000U << 4;
          _value = 0b00000000111000001100000000000000U << 4;
        } else {
          assert(0xF == (0xF & gC0));
          // >= HIGH --> 10 bits prediction
          //         F0      E0      C0      80
          //       0b11110xxx1110xxxx110xxxxx10xxxxxx
          //         ^^^^p   pppp    ppp     pp
          _prdct = 0b00000000111000001100000010000000U << 4;
          _value = 0b00001000111100001110000011000000U << 4;
        }
      }
    }

    _pr = 0x7FF;  // No prediction
    return false;
  }

  void SetDataPos(const int64_t data_pos) noexcept {
    _skip_bytes = data_pos;
  }

  void SetStart(const bool state) noexcept {
    _start = state;
  }

private:
  static constexpr int32_t ESCAPE_CHAR{4};

  int64_t _skip_bytes{0};
  uint32_t _prdct{0};
  uint32_t _value{0};
  uint16_t _pr{0x7FF};  // Prediction 0..4095
  bool _start{false};
  int32_t : 8;   // Padding
  int32_t : 32;  // Padding
};

// 2 bits markers at 0x0F, 0x66 and 0x67
[[nodiscard]] static constexpr auto pref(uint8_t c) noexcept -> uint32_t {
  // clang-format off
  if (0x0F == c) { return 1; }
  if (0x66 == c) { return 2; }
  if (0x67 == c) { return 3; }
  return 0;
  // clang-format on
}

// Get context relevant to parsing 32-bit x86 code
[[nodiscard]] static auto exectx(const Buffer_t& buf) noexcept -> uint32_t {
  auto ctx{0xC7u & buf(2)};          // Mod and r/m fields
  ctx = (ctx * 256) | buf(3);        // Opcode
  ctx = (ctx * 256) | pref(buf(4));  // Prefix
  ctx = (ctx * 4) | pref(buf(5));    // Prefix
  return ctx;
}

template <typename T>
[[nodiscard]] constexpr auto Balance(const T weight, const T px, const T py) noexcept -> T {
  return T((((16 * px) - ((16 - weight) * (px - py))) + 8) / 16);
}

class SSE_t final {
public:
  SSE_t() {
    for (uint32_t pr{0x000}; pr <= 0xFFF; ++pr) {
      const uint32_t n0{0xFFF - pr};
      const uint32_t n1{pr};
      _sse[pr] = (n0 << 16) | n1;
      assert(pr == ((0xFFF * n1) / (n0 + n1)));
    }
  }
  ~SSE_t() noexcept = default;
  SSE_t(const SSE_t&) = delete;
  SSE_t(SSE_t&&) = delete;
  auto operator=(const SSE_t&) -> SSE_t& = delete;
  auto operator=(SSE_t&&) -> SSE_t& = delete;

  [[nodiscard]] auto Predict16(const uint32_t pr12, const bool bit) noexcept -> uint32_t {
    assert(pr12 < 0x1000);

    // Update
    uint32_t n0{*_t >> 16};
    uint32_t n1{*_t & 0xFFFFu};
    if (bit) {
      ++n1;
    } else {
      ++n0;
    }
    if ((n0 | n1) >> 16) {  // shift needed
      n0 >>= 1;
      n1 >>= 1;
    }
    *_t = (n0 << 16) | n1;

    // Predict
    _t = &_sse[pr12];
    n0 = *_t >> 16;
    if (!n0) {
      return 0xFFFFu;
    }

    n1 = *_t & 0xFFFFu;
    if (!n1) {
      return 1u;
    }
    n0 += n0 + 1;
    n1 += n1 + 1;
    const uint32_t pr16_sse{MulDiv(0xFFFFu, n1, n0 + n1)};
    return pr16_sse + (0u == pr16_sse);
  }

private:
  std::array<uint32_t, 4096> _sse;
  uint32_t* _t{&_sse[0]};

  // Does '(x * y) / z' with rounding
  [[nodiscard]] ALWAYS_INLINE static constexpr auto MulDiv(const uint64_t x, const uint64_t y, const uint64_t z) noexcept -> uint32_t {
    assert(z > 0);
    return uint32_t(((2 * (x * y)) + z) / (z + z));
  }
};

// Main model - predicts next bit probability from previous data
class Predict_t final {
public:
  explicit Predict_t(Buffer_t& __restrict buf) : _buf{buf} {
    cp[0] = cp[1] = cp[2] = cp[3] = cp[4] = &_t0[0];

    for (uint32_t i{0}; i < 8192; ++i) {
      uint8_t v;
      const auto e{(std::abs)(int32_t(i) - 4096)};
      // clang-format off
      v = 0; if (e > (50*32)) { v = 1; } if (e > ( 97*32)) { v = 3; } _calcfails[0][i] = v; // 013: 50  97
      v = 0; if (e > (39*32)) { v = 1; } if (e > ( 80*32)) { v = 3; } _calcfails[1][i] = v; // 013: 39  80
      v = 0; if (e > (47*32)) { v = 1; }                              _calcfails[2][i] = v; // 01 : 47
      v = 0; if (e > ( 3*32)) { v = 1; } if (e > ( 51*32)) { v = 3; } _calcfails[3][i] = v; // 013:  3  51
      v = 0; if (e > (52*32)) { v = 1; } if (e > (104*32)) { v = 3; } _calcfails[4][i] = v; // 013: 52 104
      v = 0; if (e > (30*32)) { v = 1; } if (e > ( 98*32)) { v = 3; } _calcfails[5][i] = v; // 013: 30  98
                                v = 1;   if (e > ( 11*32)) { v = 3; } _calcfails[6][i] = v; //  13:     11
      v = 0; if (e > (45*32)) { v = 1; } if (e > ( 79*32)) { v = 3; } _calcfails[7][i] = v; // 013: 45  79
      // clang-format on
    }
  }

  virtual ~Predict_t() noexcept;

  Predict_t() = delete;
  Predict_t(const Predict_t&) = delete;
  Predict_t(Predict_t&&) = delete;
  auto operator=(const Predict_t&) -> Predict_t& = delete;
  auto operator=(Predict_t&&) -> Predict_t& = delete;

  [[nodiscard]] auto Next(const bool bit) noexcept -> uint32_t {
    if (_fails & 0x80) {
      --_failcount;
    }
    _fails += _fails;
    _failz += _failz;
    auto pr{int16_t(_pr)};
    if (bit) {
      pr ^= 0xFFF;
    }
    if (pr >= 750) {
      ++_failz;
      if (pr >= 1950) {
        ++_fails;
        ++_failcount;
      }
    }

    // Filter the context model with APMs
    const auto p0{Predict(bit)};
    const auto p1{Balance(uint16_t(3), _a1.Predict(bit, p0, gC0, 3), p0)};  // Weight of 3 is based on enwik9

#if 0
    uint32_t cz{(1 & _fails) ? 9u : 1u};
    cz += 0xF & (0x9440U >> (4 * (3 & (_fails >> 5))));  // 0x7340, 0x9440 is based on enwik8
    cz += 0xF & (0xFAA0U >> (4 * (3 & (_fails >> 3))));  // 0xC660, 0xFAA0 is based on enwik8
    cz += 0xF & (0xFC60U >> (4 * (3 & (_fails >> 1))));  // 0xC660, 0xFC60 is based on enwik8
    cz = (std::min)(9U, (_failcount + cz) / 2);
#else
    static constexpr std::array<uint8_t, 128> Table{{0x01, 0x09, 0x07, 0x0F, 0x0D, 0x12, 0x10, 0x12, 0x0B, 0x12, 0x11, 0x12, 0x12, 0x12, 0x12, 0x12,  //
                                                     0x0B, 0x12, 0x11, 0x12, 0x12, 0x12, 0x12, 0x12, 0x10, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,  //
                                                     0x05, 0x0D, 0x0B, 0x12, 0x11, 0x12, 0x12, 0x12, 0x0F, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,  //
                                                     0x0F, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,  //
                                                     0x05, 0x0D, 0x0B, 0x12, 0x11, 0x12, 0x12, 0x12, 0x0F, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,  //
                                                     0x0F, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,  //
                                                     0x0A, 0x12, 0x10, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,  //
                                                     0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12}};
    const auto cz{(std::min)(9U, (_failcount + Table[0x7F & _fails]) / 2)};
#endif

    const auto pos{_buf.Pos()};
    const auto rate{6 + ((pos > (15 * 256 * 1024)) ? 1 : 0) + ((pos > (56 * 256 * 1024)) ? 1 : 0)};

    // clang-format off
    const auto p2{_a2.Predict(bit, p0,           finalize64(hash(   8 * gC0, 0x7FF & _failz                         ), 27), rate+1)}; // 15 bits APM, hash bits of 27 is based on enwik9
    const auto p3{_a3.Predict(bit, p0,           finalize64(hash(  32 * gC0, 0x80FFFF & gX5                         ), 25), rate  )}; // 15 bits APM, hash bits of 25 is based on enwik9
    const auto p4{_a4.Predict(bit, p1, (2*gC0) ^ finalize64(hash(0xFF & gC4, 0xFF & (gX5 >> 8), 0x80FF & (gX5 >> 16)), 57), rate  )}; // 17 bits APM, hash bits of 57 is based on enwik9
    const auto p5{_a5.Predict(bit, p2,           finalize64(hash(       gC0, gW5                                    ), 24), rate  )}; // 16 bits APM, hash bits of 24 is based on enwik9
    const auto p6{_a6.Predict(bit, p4, (4*gC0) ^ finalize64(hash(       cz, 0x0080FF & gX5                          ), 57), rate  )}; // 16 bits APM, hash bits of 57 is based on enwik9
    // clang-format on

    int16_t* const __restrict px = _blend.Set();
    px[0] = Stretch(p3);  // Conversions from 0..4095 into -2048..2047
    px[1] = Stretch(p4);
    px[2] = Stretch(p5);
    px[3] = Stretch(p6);

    const auto ctx{(gW5 << 1) | ((0xFF & _fails) ? 1 : 0)};
    pr = _blend.Predict(bit, _pr, ctx, 5);  // Rate of 5 is based on enwik9

    uint16_t p7;
    if (_pt_predicts) {
      assert((0 == _pt) || (0xFFF == _pt));  // Predicts only 0 or 1 with certainty of 100%
      p7 = _pt;
    } else {
      p7 = Squash(pr);  // Conversion from -2048..2047 (clamped) into 0..4095
    }

    const uint32_t pr16{_sse.Predict16(p7, bit)};
    _pr = uint16_t(pr16 / 16);
    return pr16;
  }

  void SetBinary(const bool is_binary) noexcept {
    _is_binary = is_binary;
  }

  void SetDataPos(const int64_t data_pos) noexcept {
    if (nullptr != _txt) {
      _txt->SetDataPos(data_pos);
    }
  }

  void SetStart(const bool state) noexcept {
    if (nullptr != _txt) {
      _txt->SetStart(state);
    }
  }

private:
  Buffer_t& __restrict _buf;
  Mixer_t _mixer{};
  DynamicMarkovCmp_t* __restrict _dmc{new DynamicMarkovCmp_t(MEM())};
  LempelZivPredict_t* __restrict _lzp{new LempelZivPredict_t(_buf, MEM() / 4)};
  SparseMatchModel_t* __restrict _smm{new SparseMatchModel_t(_buf)};
  Txt_t* __restrict _txt{new Txt_t()};
  APM_t _ax1{0x10000, 18};
  APM_t _ax2{0x800, 40};
  APM _a1{0x100};
  APM _a2{0x8000};
  APM _a3{0x8000};
  APM _a4{0x20000};
  APM _a5{0x10000};
  APM _a6{0x10000};
  uint16_t _mxr_pr{0x7FF};
  uint16_t _pr{0x7FF};  // Prediction 0..4095
  uint16_t _pt{0x7FF};
  int32_t : 16;  // Padding
  int32_t* __restrict _add2order{&Mixer_t::_wx[0]};
  HashTable* __restrict _t4a{new HashTable(MEM() * 2)};
  HashTable* __restrict _t4b{new HashTable(MEM() * 2)};
  Blend_t<4> _blend{0x20000};
  std::array<std::array<uint8_t, 8192>, 8> _calcfails;
  std::array<uint8_t, 0x10000> _t0{};
  uint8_t* __restrict _t0c1{&_t0[0]};
  uint32_t _ctx1{0};
  uint32_t _ctx2{0};
  uint32_t _ctx3{0};
  uint32_t _ctx4{0};
  uint32_t _ctx5{0};
  int32_t : 32;  // Padding
  int32_t* _ctx6{&smt[0][0]};
  uint64_t _word{0};
  uint32_t _pw{0};
  uint32_t _bc4cp0{0};  // Range 0,1,2 or 3
  uint32_t _fails{0};
  uint32_t _failz{0};
  uint32_t _failcount{0};
  bool _pt_predicts{false};
  bool _is_binary{false};
  int32_t : 16;  // Padding
  SSE_t _sse{};

  [[nodiscard]] auto Predict_not32(const bool bit) noexcept -> uint16_t {
    auto y2o{(bit << 20) - bit};

    const auto len{_lzp->Predict(bit)};       // len --> 0..9
    _mixer.Context(_add2order + (64 * len));  // len --> 0..576 --> 10800+576+(9*8)
    _ctx6[0] += (y2o - _ctx6[0]) >> 6;        // (6) 6 is based on enwik9 (little influence)
    _ctx6 = &smt[_bc4cp0][_t0c1[gC0]];        // smt[0,1,2 or 3][...]

    smt[0x5][_ctx5] += (y2o - smt[0x5][_ctx5]) * limits_15a[_ctx5] >> 9;  // P5
    y2o += 384;                                                           //
    smt[0x4][_ctx1] += (y2o - smt[0x4][_ctx1]) >> 9;                      // P1
    smt[0x6][_ctx2] += (y2o - smt[0x6][_ctx2]) >> 9;                      // P2
    smt[0x8][_ctx3] += (y2o - smt[0x8][_ctx3]) >> 10;                     // P3
    smt[0xA][_ctx4] += (y2o - smt[0xA][_ctx4]) >> 10;                     // P4

    _ctx1 = *cp[0x0];
    _ctx2 = *cp[0x1];
    _ctx3 = *cp[0x2];
    _ctx4 = *cp[0x3];
    _ctx5 = *cp[0x4];

    Mixer_t::_tx[1] = Stretch256(smt[0x4][_ctx1]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[2] = Stretch256(smt[0x6][_ctx2]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[3] = Stretch256(smt[0x8][_ctx3]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[4] = Stretch256(smt[0xA][_ctx4]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[5] = Stretch256(smt[0x5][_ctx5]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[6] = Stretch256(_ctx6[0]);         // Conversion from 0..1048575 into -2048..2047

    const auto pr{_mixer.Predict()};
    _mxr_pr = _ax1.p1(bit, pr, gC2 | gC0);
    const auto px = Balance(uint16_t(3), Squash(pr), _mxr_pr);  // Conversion from -2048..2047 (clamped) into 0..4095, Weight of 3 is based on enwik9

    const auto py{_ax2.p2(bit, Stretch(px), (gFails * 8) + gBcount)};  // Conversion from 0..4095 into -2048..2047
    const auto pz = Balance(uint16_t(4), _mxr_pr, py);                 // Weight of 4 is based on enwik9
    assert(pz < 0x1000);
    return pz;
  }

  [[nodiscard]] auto Predict_not32s(const bool bit) noexcept -> uint16_t {
    auto y2o{(bit << 20) - bit};

    const auto len{_lzp->Predict(bit)};       // len --> 0..9
    _mixer.Context(_add2order + (64 * len));  // len --> 0..576 --> 10800+576+(9*8)
    _ctx6[0] += (y2o - _ctx6[0]) >> 6;        // (6) 6 is based on enwik9 (little influence)
    _ctx6 = &smt[_bc4cp0][_t0c1[1]];          // smt[0,1,2 or 3][...] with gC0=1

    smt[0x4][_ctx1] += (y2o - smt[0x4][_ctx1]) >> 9;                      // P1
    smt[0x5][_ctx5] += (y2o - smt[0x5][_ctx5]) * limits_15a[_ctx5] >> 9;  // P5

    if (0x2000 == (0xFF00 & gC4)) {
      y2o += 768;
      smt[0x7][_ctx2] += (y2o - smt[0x7][_ctx2]) >> 10;  // P2
      smt[0x9][_ctx3] += (y2o - smt[0x9][_ctx3]) >> 11;  // P3
      smt[0xB][_ctx4] += (y2o - smt[0xB][_ctx4]) >> 11;  // P4
    } else {
      y2o += 384;
      smt[0x6][_ctx2] += (y2o - smt[0x6][_ctx2]) >> 9;   // P2
      smt[0x8][_ctx3] += (y2o - smt[0x8][_ctx3]) >> 10;  // P3
      smt[0xA][_ctx4] += (y2o - smt[0xA][_ctx4]) >> 9;   // P4
    }

    _ctx1 = *cp[0x0];
    _ctx2 = *cp[0x1];
    _ctx3 = *cp[0x2];
    _ctx4 = *cp[0x3];
    _ctx5 = *cp[0x4];

    Mixer_t::_tx[1] = Stretch256(smt[0x4][_ctx1]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[2] = Stretch256(smt[0x6][_ctx2]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[3] = Stretch256(smt[0x8][_ctx3]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[4] = Stretch256(smt[0xA][_ctx4]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[5] = Stretch256(smt[0x5][_ctx5]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[6] = Stretch256(_ctx6[0]);         // Conversion from 0..1048575 into -2048..2047

    const auto pr{_mixer.Predict()};
    const auto px{_ax1.p1(bit, pr, gC2 | gC0)};
    _mxr_pr = Balance(uint16_t(2), Squash(pr), px);  // Conversion from -2048..2047 (clamped) into 0..4095, Weight of 2 is based on enwik9

    const auto py{_ax2.p2(bit, Stretch(px), (gFails * 8) + gBcount)};  // Conversion from 0..4095 into -2048..2047
    const auto pz = Balance(uint16_t(8), _mxr_pr, py);                 // Weight of 8 is based on enwik9
    assert(pz < 0x1000);
    return pz;
  }

  [[nodiscard]] auto Predict_was32(const bool bit) noexcept -> uint16_t {
    auto y2o{(bit << 20) - bit};

    const auto len{_lzp->Predict(bit)};       // len --> 0..9
    _mixer.Context(_add2order + (64 * len));  // len --> 0..576 --> 10800+576+(9*8)
    _ctx6[0] += (y2o - _ctx6[0]) >> 7;        // (8) 7 is based on enwik9 (little influence)
    _ctx6 = &smt[1][_t0c1[gC0]];

    smt[0x5][_ctx5] += (y2o - smt[0x5][_ctx5]) * limits_15b[_ctx5] >> 10;  // P5
    y2o += 768;                                                            //
    smt[0x4][_ctx1] += (y2o - smt[0x4][_ctx1]) >> 14;                      // P1
    smt[0x7][_ctx2] += (y2o - smt[0x7][_ctx2]) >> 10;                      // P2
    smt[0x9][_ctx3] += (y2o - smt[0x9][_ctx3]) >> 11;                      // P3
    smt[0xB][_ctx4] += (y2o - smt[0xB][_ctx4]) >> 10;                      // P4

    _ctx1 = *cp[0x0];
    _ctx2 = *cp[0x1];
    _ctx3 = *cp[0x2];
    _ctx4 = *cp[0x3];
    _ctx5 = *cp[0x4];

    Mixer_t::_tx[1] = Stretch256(smt[0x4][_ctx1]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[2] = Stretch256(smt[0x7][_ctx2]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[3] = Stretch256(smt[0x9][_ctx3]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[4] = Stretch256(smt[0xB][_ctx4]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[5] = Stretch256(smt[0x5][_ctx5]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[6] = Stretch256(_ctx6[0]);         // Conversion from 0..1048575 into -2048..2047

    const auto pr{_mixer.Predict()};
    _mxr_pr = _ax1.p1(bit, pr, gC2 | gC0);
    const auto px{Balance(uint16_t(12), Squash(pr), _mxr_pr)};              // Conversion from -2048..2047 (clamped) into 0..4095, Weight of 12 is based on enwik9
    const auto py{_ax2.p2(bit, Stretch(_mxr_pr), (gFails * 8) + gBcount)};  // Conversion from 0..4095 into -2048..2047
    const auto pz{Balance(uint16_t(6), px, py)};                            // Weight of 6 is based on enwik9
    assert(pz < 0x1000);
    return pz;
  }

  [[nodiscard]] auto Predict_was32s(const bool bit) noexcept -> uint16_t {
    auto y2o{(bit << 20) - bit};

    const auto len{_lzp->Predict(bit)};       // len --> 0..9
    _mixer.Context(_add2order + (64 * len));  // len --> 0..576 --> 10800+576+(9*8)
    _ctx6[0] += (y2o - _ctx6[0]) >> 13;       // (12) 13 is based on enwik9 (little influence)
    _ctx6 = &smt[1][_t0c1[1]];                // gC0=1

    smt[0x5][_ctx5] += (y2o - smt[0x5][_ctx5]) * limits_15b[_ctx5] >> 14;  // P5
    y2o += 6144;                                                           //
    smt[4][_ctx1] += (y2o - smt[4][_ctx1]) >> 14;                          // P1

    if (0x2000 == (0xFF00 & gC4)) {
      smt[0x7][_ctx2] += (y2o - smt[0x7][_ctx2]) >> 13;  // P2
      smt[0x9][_ctx3] += (y2o - smt[0x9][_ctx3]) >> 14;  // P3
      smt[0xB][_ctx4] += (y2o - smt[0xB][_ctx4]) >> 13;  // P4
    } else {
      smt[0x6][_ctx2] += (y2o - smt[0x6][_ctx2]) >> 13;  // P2
      smt[0x8][_ctx3] += (y2o - smt[0x8][_ctx3]) >> 14;  // P3
      smt[0xA][_ctx4] += (y2o - smt[0xA][_ctx4]) >> 13;  // P4
    }

    _ctx1 = *cp[0x0];
    _ctx2 = *cp[0x1];
    _ctx3 = *cp[0x2];
    _ctx4 = *cp[0x3];
    _ctx5 = *cp[0x4];

    Mixer_t::_tx[1] = Stretch256(smt[0x4][_ctx1]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[2] = Stretch256(smt[0x6][_ctx2]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[3] = Stretch256(smt[0x8][_ctx3]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[4] = Stretch256(smt[0xA][_ctx4]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[5] = Stretch256(smt[0x5][_ctx5]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::_tx[6] = Stretch256(_ctx6[0]);         // Conversion from 0..1048575 into -2048..2047

    const auto pr{_mixer.Predict()};
    const auto px{_ax1.p1(bit, pr, gC2 | gC0)};
    _mxr_pr = Balance(uint16_t(6), Squash(pr), px);  // Conversion from -2048..2047 (clamped) into 0..4095, Weight of 6 is based on enwik9

    const auto py{_ax2.p2(bit, Stretch(px), (gFails * 8) + gBcount)};  // Conversion from 0..4095 into -2048..2047
    const auto pz = Balance(uint16_t(12), _mxr_pr, py);                // Weight of 12 is based on enwik9
    assert(pz < 0x1000);
    return pz;
  }

  [[nodiscard]] auto Predict(const bool bit) noexcept -> uint16_t {
    gFails += gFails;
#if 1
    // const auto MU{int8_t(INT64_C(0x091A1B14181C232E) >> (8 * gBcount))};  // based on lpaq9m
    // const auto MU{int8_t(INT64_C(0x0117081224254D3B) >> (8 * gBcount))};  // based on enwik8
    const auto MU{int8_t(INT64_C(0x01190E131717261C) >> (8 * gBcount))};  // based on enwik9
#else
    //                                 2E  23  1C  18  14  1B  1A  9
    // static constexpr int8_t flaw[8]{46, 35, 28, 24, 20, 27, 26, 9};  // based on lpaq9m

    //                                 3B  4D  25  24  12  8  17  1
    // static constexpr int8_t flaw[8]{59, 77, 37, 36, 18, 8, 23, 1};  // based on enwik8

    //                              1C  26  17  17  13  0E  19  1
    static constexpr int8_t flaw[8]{28, 38, 23, 23, 19, 14, 25, 1};  // based on enwik9
    const int8_t MU{flaw[gBcount]};
#endif
    const auto err{int16_t((bit << 12) - int32_t(_mxr_pr) - bit)};
    if ((err <= -MU) || (err >= MU)) {
      assert((err + 4096) < 8192);
      gFails |= _calcfails[(gBcount - 1) & 7][uint16_t(err + 4096)];
      _mixer.Update(err);
    }
    auto cx{gC0};
    gC0 += gC0 + uint32_t(bit);
    gBcount = 7 & (gBcount - 1);
    // bpos = (bpos + 1) & 7;
    _add2order += Mixer_t::N_LAYERS;

    if (0 != (1 & gBcount)) {
      const auto& p{bit ? StateTableY1 : StateTableY0};
      int32_t j = 1 & cx;
      const auto& q{j ? StateTableY1 : StateTableY0};

      uint8_t* __restrict a{_t0c1};
      a[cx] = p[2][a[cx]];
      cx >>= 1;
      a[cx] = q[2][a[cx]];
      j = j ^ ~0;  // 0 --> -1    1 --> -2

      a = cp[0];
      a[0] = p[1][a[0]];
      a[j] = q[1][a[j]];
      a = cp[1];
      a[0] = p[0][a[0]];  // in lpaq9m 4 for was32
      a[j] = q[0][a[j]];
      a = cp[2];
      a[0] = p[3][a[0]];
      a[j] = q[3][a[j]];
      a = cp[3];
      a[0] = p[4][a[0]];
      a[j] = q[4][a[j]];
      a = cp[4];
      a[0] = p[5][a[0]];
      a[j] = q[5][a[j]];
    }

    switch (gBcount) {
      case 6:
      case 4:
      case 2:
      case 0: {
        const auto z{bit ? 2 : 1};
        cp[0] += z;
        cp[1] += z;
        cp[2] += z;
        cp[3] += z;
        cp[4] += z;
      } break;

      case 5: {
        auto zq{2 + (gC0 & 0x03) * 2};          // gC0 contains 2 bits
        cp[0] = _t4b->get1x(0x00, zq + hh[0]);  // 000 (0)
        cp[1] = _t4a->get1x(0x80, zq + hh[1]);  // 100 (4)
        cp[4] = _t4b->get1x(0x00, zq + hh[4]);  // 000 (0)
        zq *= 2;
        cp[2] = _t4a->get3a(0x00, zq + hh[2]);  // 000 (0)
        cp[3] = _t4b->get3a(0x80, zq + hh[3]);  // 100 (4)
      } break;

      case 1: {
        auto zq{2 + (gC0 & 0x3F) * 2};          // gC0 contains 6 bits
        cp[0] = _t4b->get1x(0xC0, zq + hh[0]);  // 110 (6)
        cp[1] = _t4a->get1x(0x40, zq + hh[1]);  // 010 (2)
        cp[4] = _t4b->get1x(0xC0, zq + hh[4]);  // 110 (6)
        zq *= 2;
        cp[2] = _t4a->get3b(0xC0, zq + hh[2]);  // 110 (6)
        cp[3] = _t4b->get3b(0x40, zq + hh[3]);  // 010 (2)
      } break;

      case 3: {
        const auto zq{2 + (gC0 & 0x0F) * 2};  // gC0 contains 4 bits
        const auto blur{PHI32 * zq};
        hh[0] = finalize64(hash(zq - hh[0]), 32);
        hh[1] ^= blur;
        hh[2] = finalize64(hash(zq, gC4, gC8 & 0x000080FF), 32);
        hh[3] = finalize64(hash(zq, gC4, gC8 & 0x00FFFFFF), 32);
        hh[4] ^= blur;
        cp[0] = _t4b->get1x(0xA0, hh[0]);  // 101 (5)
        cp[1] = _t4a->get1x(0x20, hh[1]);  // 001 (1)
        cp[2] = _t4a->get3b(0xA0, hh[2]);  // 101 (5)
        cp[3] = _t4b->get3b(0x20, hh[3]);  // 001 (1)
        cp[4] = _t4b->get1x(0xA0, hh[4]);  // 101 (5)
      } break;

      case 7:
      default: {
        const auto c{uint8_t(gC0)};
        gC0 = c;
        const auto idx{Mixer_t::N_LAYERS * 10u * 4u * WRT_mxr[c]};  // 9*10*4*(0..30) --> 10800
        assert(idx < Mixer_t::_wx.size());
        _add2order = &Mixer_t::_wx[idx];

        static constexpr std::array<uint8_t, 256> WRT_mtt{{0, 4, 4, 5, 0, 5, 3, 7, 0, 2, 4, 0, 0, 0, 0, 0,    //   0- 15 . . . . . . . . . . . . . . . .
                                                           0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,    //  16- 31 . . . . . . . . . . . . . . . .
                                                           2, 4, 3, 3, 4, 6, 6, 7, 5, 4, 0, 4, 3, 4, 0, 1,    //  32- 47   ! " # $ % & ' ( ) * + , - . /
                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 3, 3, 4, 3, 4,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
                                                           0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,    //  64- 79 @ A B C D E F G H I J K L M N O
                                                           5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 4, 3, 4, 4,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
                                                           0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,    //  96-111 ` a b c d e f g h i j k l m n o
                                                           5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4,    // 112-127 p q r s t u v w x y z { | } ~ .
                                                           6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,    // 128-143 . . . . . . . . . . . . . . . .
                                                           6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,    // 144-159 . . . . . . . . . . . . . . . .
                                                           6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,    // 160-175 . . . . . . . . . . . . . . . .
                                                           6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,    // 176-191 . . . . . . . . . . . . . . . .
                                                           6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,    // 192-207 . . . . . . . . . . . . . . . .
                                                           7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,    // 208-223 . . . . . . . . . . . . . . . .
                                                           7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,    // 224-239 . . . . . . . . . . . . . . . .
                                                           7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7}};  // 240-255 . . . . . . . . . . . . . . . .
        if (!(0xFF & _pw)) {
          gC1 = (uint32_t(WRT_mtt[c]) << 2) + 33u;  // 0..61
        } else {
          gC1 = (uint32_t(WRT_mtt[c]) << 5) | (0x1F & _pw);
          if (gC1 < 64) {
            static constexpr std::array<uint8_t, 64> WRT_chc1{{0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,    //   0- 15 . . . . . . . . . . . . . . . .
                                                               16, 1,  18, 19, 20, 5,  22, 23, 24, 9,  26, 27, 28, 13, 30, 31,    //  16- 31 . . . . . . . . . . . . . . . .
                                                               32, 17, 34, 35, 36, 21, 38, 39, 40, 25, 42, 43, 44, 29, 46, 47,    //  32- 47   ! " # $ % & ' ( ) * + , - . /
                                                               48, 17, 50, 51, 52, 21, 54, 55, 56, 25, 58, 59, 60, 29, 62, 63}};  //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
            gC1 = WRT_chc1[gC1];
          }
        }
        gC2 = gC1 * 256;

        _buf.Add(c);
        gC8 = (gC8 << 8) + (gC4 >> 24);
        gC4 = gC4 << 8 | c;
        _t0c1 = &_t0[c * 256];

        if (c < 128) {
#if defined(__SIZEOF_INT128__)
          static constexpr auto TxtFilter{0x28000001D00000000000C14000000400_xxl};
          static constexpr auto ExeFilter{0x00000000000000000000000000008002_xxl};

          const auto filter{_is_binary ? ExeFilter : TxtFilter};
          if (1 & (filter >> c)) {
#else
          // \n & ( . / \ ^ _ ' { }                            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F                0 1 2 3 4 5 6 7 8 9 A B C D E F
          static constexpr std::array<uint8_t, 128> TxtFilter{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,    //   0- 15 . . . . . . . . . . . . . . . .
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  16- 31 . . . . . . . . . . . . . . . .
                                                               0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1,    //  32- 47   ! " # $ % & ' ( ) * + , - . /
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  64- 79 @ A B C D E F G H I J K L M N O
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
                                                               1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  96-111 ` a b c d e f g h i j k l m n o
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0}};  // 112-127 p q r s t u v w x y z { | } ~ .

          // 01 0F                                             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F                0 1 2 3 4 5 6 7 8 9 A B C D E F
          static constexpr std::array<uint8_t, 128> ExeFilter{{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,    //   0- 15 . . . . . . . . . . . . . . . .
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  16- 31 . . . . . . . . . . . . . . . .
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  32- 47   ! " # $ % & ' ( ) * + , - . /
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  64- 79 @ A B C D E F G H I J K L M N O
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  96-111 ` a b c d e f g h i j k l m n o
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};  // 112-127 p q r s t u v w x y z { | } ~ .

          const auto& filter{_is_binary ? ExeFilter : TxtFilter};
          if (filter[c]) {
#endif
            gTt = (gTt & UINT32_C(-8)) + 1;
            gW5 = (gW5 << 8) | 0x3FF;
            gX5 = (gX5 << 8) + c;
          }
        }

        gTt = (gTt * 8) + WRT_mtt[c];
        gW5 = (gW5 * 4) + uint32_t(0xF & (UINT64_C(0x0000111111233444) >> (4 * (c >> 4))));  // WRT_mpw
        gX5 = (gX5 << 8) + c;

        static constexpr std::array<uint8_t, 256> WRT_wrd{{0, 0, 0, 1, 0, 1, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0,    //   0- 15 . . . . . . . . . . . . . . . .
                                                           0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,    //  16- 31 . . . . . . . . . . . . . . . .
                                                           0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,    //  32- 47   ! " # $ % & ' ( ) * + , - . /
                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 2, 0, 2, 0,    //  48- 63 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
                                                           0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    //  64- 79 @ A B C D E F G H I J K L M N O
                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 3, 0, 0, 0,    //  80- 95 P Q R S T U V W X Y Z [ \ ] ^ _
                                                           0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    //  96-111 ` a b c d e f g h i j k l m n o
                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,    // 112-127 p q r s t u v w x y z { | } ~ .
                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,    // 128-143 . . . . . . . . . . . . . . . .
                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,    // 144-159 . . . . . . . . . . . . . . . .
                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,    // 160-175 . . . . . . . . . . . . . . . .
                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,    // 176-191 . . . . . . . . . . . . . . . .
                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,    // 192-207 . . . . . . . . . . . . . . . .
                                                           3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,    // 208-223 . . . . . . . . . . . . . . . .
                                                           3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,    // 224-239 . . . . . . . . . . . . . . . .
                                                           3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3}};  // 240-255 . . . . . . . . . . . . . . . .
        _bc4cp0 = WRT_wrd[c];
        _pw += _pw + (_bc4cp0 ? 1 : 0);

        if ((c > 127) || ((c >= 'a') && (c <= 'z'))) {
          _word = combine64(_word, c);
        } else if ((c >= 'A') && (c <= 'Z')) {
          _word = combine64(_word, c + 'a' - 'A');
        } else {
          _word = 0;
        }

        const auto ctx{_is_binary ? exectx(_buf) : (gC4 & 0x0080FFFF)};
        hh[0] = finalize64(hash(ctx), 32);
        hh[1] = finalize64(hash(gC4, WRT_mxr[gC4 >> 24]), 32);
        hh[2] = finalize64(hash(gC4, gC8 & 0x0000C0FF), 32);
        hh[3] = finalize64(hash(gC4, gC8 & 0x00FEFFFF, WRT_mxr[gC8 >> 24]), 32);
        hh[4] = finalize64(combine64(_word, WRT_mxr[c]), 32);
        cp[0] = _t4b->get1x(0xE0, hh[0]);  // 111 (7)
        cp[1] = _t4a->get1x(0x60, hh[1]);  // 011 (3)
        cp[2] = _t4a->get3a(0xE0, hh[2]);  // 111 (7)
        cp[3] = _t4b->get3a(0x60, hh[3]);  // 011 (3)
        cp[4] = _t4b->get1x(0xE0, hh[4]);  // 111 (7)

        _lzp->Update();
        _smm->Update();
        _txt->Update();

        const auto pos{_buf.Pos()};
        if (0 == (pos & (256 * 1024 - 1))) {
          if (((16 == DP_SHIFT) && (pos == (25 * 256 * 1024))) ||  // 22 or 25 based on enwik9 (little influence)
              ((15 == DP_SHIFT) && (pos == (4 * 256 * 1024))) ||   // 2 or 4 based on enwik9 (little influence)
              (14 == DP_SHIFT)) {
            DP_SHIFT++;
            for (size_t q{Mixer_t::_wx.size()}; q--;) {
#if 0
              Mixer_t::_wx[q] *= 2;
#else
              Mixer_t::_wx[q] = safe_add(Mixer_t::_wx[q], Mixer_t::_wx[q]);
#endif
            }
          }
        }

        gC0 = 1;
      } break;
    }

    _dmc->Predict(bit);
    _smm->Predict(bit);

    uint16_t pr;

    if (32 == (0xFF & gC4)) {
      pr = (7 == gBcount) ? Predict_was32s(bit) : Predict_was32(bit);
    } else {
      pr = (7 == gBcount) ? Predict_not32s(bit) : Predict_not32(bit);
    }

    _pt_predicts = _txt->Predict(bit, _pt);
    if (_pt_predicts) {
      assert((0x000 == _pt) || (0xFFF == _pt));  // Predicts only 0 or 1 with certainty of 100%
      pr = _pt;
    }
    return pr;
  }
};
Predict_t::~Predict_t() noexcept {
  delete _t4b;
  _t4b = nullptr;
  delete _t4a;
  _t4a = nullptr;
  delete _txt;
  _txt = nullptr;
  delete _smm;
  _smm = nullptr;
  delete _lzp;
  _lzp = nullptr;
  delete _dmc;
  _dmc = nullptr;
}

// Encoder - Arithmetic coding
class Encoder_t final : public iEncoder_t {
public:
  explicit Encoder_t(Buffer_t& __restrict buf, bool encode, File_t& file) : _stream{file}, _predict{new Predict_t(buf)} {
    if (!encode) {
      _x = _stream.get32();
    }

    for (uint32_t i{12}; i--;) {
      for (uint32_t j{256}; j--;) {
        smt[i][j] = 0x07FFFF;
      }
    }

    for (uint32_t i{6}; i--;) {
      int32_t* j{&smt[0xF & (0x578046 >> (i * 4))][0]};
      uint8_t p1{StateTableY0[i][0]};
      uint8_t p2{StateTableY0[i][0]};
      uint8_t p3{StateTableY1[i][0]};
      uint8_t p4{StateTableY1[i][0]};
      p1 = StateTableY0[i][p1];
      j[p1] = (0xFFFFF * 1) / 4;
      p2 = StateTableY1[i][p2];
      j[p2] = (0xFFFFF * 2) / 4;
      p3 = StateTableY0[i][p3];
      j[p3] = (0xFFFFF * 2) / 4;
      p4 = StateTableY1[i][p4];
      j[p4] = (0xFFFFF * 3) / 4;
      uint8_t p5{p4};
      uint8_t p6{p1};
      for (auto z{5}; z < 70; ++z) {
        uint8_t px;
        // clang-format off
        px = p1; p1 = StateTableY0[i][p1];                           if (p1 != px) { j[p1] = (0xFFFFF * (    1)) / z; }
        px = p2; p2 = StateTableY1[i][p2];                           if (p2 != px) { j[p2] = (0xFFFFF * (z - 2)) / z; }
        px = p3; p3 = StateTableY0[i][p3];                           if (p3 != px) { j[p3] = (0xFFFFF * (    2)) / z; }
        px = p4; p4 = StateTableY1[i][p4];                           if (p4 != px) { j[p4] = (0xFFFFF * (z - 1)) / z; }
        px = p5; p5 = StateTableY0[i][p5]; if (p5 < px) { p5 = px; } if (p5 != px) { j[p5] = (0xFFFFF * (    3)) / z; }
        px = p6; p6 = StateTableY1[i][p6]; if (p6 < px) { p6 = px; } if (p6 != px) { j[p6] = (0xFFFFF * (z - 3)) / z; }
        // clang-format on
      }
    }

    memcpy(&smt[0x1], &smt[0x0], smt[0x0].size());
    memcpy(&smt[0x2], &smt[0x0], smt[0x0].size());
    memcpy(&smt[0x3], &smt[0x0], smt[0x0].size());
    memcpy(&smt[0x9], &smt[0x8], smt[0x8].size());
    memcpy(&smt[0xA], &smt[0x7], smt[0x7].size());
    memcpy(&smt[0xB], &smt[0x7], smt[0x7].size());
  }
  ~Encoder_t() noexcept override;

  Encoder_t() = delete;
  Encoder_t(const Encoder_t&) = delete;
  Encoder_t(Encoder_t&&) = delete;
  auto operator=(const Encoder_t&) -> Encoder_t& = delete;
  auto operator=(Encoder_t&&) -> Encoder_t& = delete;

  void Compress(int32_t c) noexcept final {
    for (auto n{8}; n--;) {
      Code((c >> n) & 1);
    }
  }

  [[nodiscard]] auto Decompress() noexcept -> int32_t final {
    auto c{0};
    for (auto n{8}; n--;) {
      c += c + Code();
    }
    return c;
  }

  void CompressN(const int32_t N, int64_t c) noexcept final {
    for (auto n{N}; n--;) {
      Code((c >> n) & 1);
    }
  }

  [[nodiscard]] auto DecompressN(const int32_t N) noexcept -> int64_t final {
    int64_t c{0};
    for (auto n{N}; n--;) {
      c += c + Code();
    }
    return c;
  }

  void Flush() noexcept final {
    // Flush first unequal byte of range
    _stream.putc(int32_t(_low >> 24));
    fflush(_stream);
  }

  void SetBinary(const bool is_binary) noexcept final {
    if (nullptr != _predict) {
      _predict->SetBinary(is_binary);
    }
  }

  void SetDataPos(const int64_t data_pos) noexcept final {
    if (nullptr != _predict) {
      _predict->SetDataPos(data_pos);
    }
  }

  void SetStart(const bool state) noexcept final {
    if (nullptr != _predict) {
      _predict->SetStart(state);
    }
  }

private:
  File_t& _stream;
  Predict_t* _predict;
  uint32_t _high{~0U};
  uint32_t _low{0};
  uint32_t _x{0};
  uint32_t _pr{0x7FFF};  // Prediction 0x0000..0xFFFF

  [[nodiscard]] ALWAYS_INLINE constexpr auto Rescale() const noexcept -> uint32_t {
    assert(_pr < 0x10000);
    assert(_high > _low);
    const uint32_t mid{_low + uint32_t((uint64_t(_pr) * uint64_t(_high - _low)) / 0x10000)};
    assert(_high > mid);
    assert(mid >= _low);
    return mid;
  }

  void Code(const bool bit) noexcept {
    const auto mid{Rescale()};
    if (bit) {
      _high = mid;
    } else {
      _low = mid + 1;
    }
    while ((_low ^ _high) < 0x01000000u) {  // Shift out identical leading bytes
      _stream.putc(int32_t(_high >> 24));
      _high = (_high << 8) | 0xFF;
      _low <<= 8;
    }
    _pr = _predict->Next(bit);  // Update models and Predict next bit probability
  }

  [[nodiscard]] auto Code() noexcept -> bool {
    bool bit;
    const auto mid{Rescale()};
    if (_x <= mid) {
      _high = mid;
      bit = true;
    } else {
      _low = mid + 1;
      bit = false;
    }
    while ((_low ^ _high) < 0x01000000u) {  // Shift out identical leading bytes
      _high = (_high << 8) | 0xFF;
      _low <<= 8;
      _x = (_x << 8) | (_stream.getc() & 0xFF);  // EOF is OK
    }
    _pr = _predict->Next(bit);  // Update models and Predict next bit probability
    return bit;
  }
};
Encoder_t::~Encoder_t() noexcept {
  delete _predict;
  _predict = nullptr;
}
iEncoder_t::~iEncoder_t() noexcept = default;

class Monitor_t final : public iMonitor_t {
public:
  explicit Monitor_t(const File_t& in, const File_t& out, const int64_t workLength, const int64_t layoutLength)
      : _in{in},  //
        _out{out},
        _workLength{workLength},
        _layoutLength{layoutLength} {}
  ~Monitor_t() noexcept override;

  Monitor_t(const Monitor_t&) = delete;
  Monitor_t(Monitor_t&&) = delete;
  auto operator=(const Monitor_t&) -> Monitor_t& = delete;
  auto operator=(Monitor_t&&) -> Monitor_t& = delete;

  [[nodiscard]] auto inputLength() const noexcept -> int64_t final {
    return _in.Position();
  }
  [[nodiscard]] auto outputLength() const noexcept -> int64_t final {
    return _out.Position();
  }
  [[nodiscard]] auto workLength() const noexcept -> int64_t final {
    return _workLength;
  }
  [[nodiscard]] auto layoutLength() const noexcept -> int64_t final {
    return _layoutLength;
  }

private:
  const File_t& _in;
  const File_t& _out;
  const int64_t _workLength;
  const int64_t _layoutLength;
};
Monitor_t::~Monitor_t() noexcept = default;

static auto checksum(const uint8_t* __restrict data, size_t len) noexcept -> uint8_t {
  uint8_t sum{0};
  while (len--) {
    sum = uint8_t(sum + *data++);
  }
  return sum;
}

auto main(int32_t argc, char* const argv[]) -> int32_t {
  // clang-format off
  std::set_terminate  ([]() { fprintf(stderr, "\nUnhandled exception");        std::abort(); });
  std::set_new_handler([]() { fprintf(stderr, "\nFailed to allocate memory!"); std::abort(); });
  // clang-format on

#if defined(GENERATE_SQUASH_STRETCH)
  const double value{atof(argv[5])};
  argc--;
  fprintf(stdout, "\nValue : %g\n", value);

  _squash = new Squash_t();
  _stretch = new Stretch_t();
#elif 0
  if ((6 == argc) && !strnicmp(argv[5], "--XX", 4)) {
    extern int32_t XX;
    XX = std::strtol(4 + argv[5], nullptr, 16);
    argc--;
    fprintf(stdout, "\nXX : %02" PRIX32 "\n", XX);
  }
#endif

  fprintf(stdout,
          "Moruga v1.00 compressor (C) 2021, M.W. Hessel.\n"
          "Based on PAQ compressor series by M. Mahoney.\n"
          "Free under GPL, https://www.gnu.org/licenses/");

  level = DEFAULT_OPTION;
  bool compress{false};
  const char* inFileName{nullptr};
  const char* outFileName{nullptr};

  static const std::string verbose_str{"--verbose"};

  for (auto n{1}; n < argc; ++n) {
    if (!verbose_str.compare(argv[n])) {
      verbose = true;
    } else if ((1 == strnlen(argv[n], 3)) && ('c' == argv[n][0])) {
      compress = true;
    } else if ((1 == strnlen(argv[n], 3)) && ('d' == argv[n][0])) {
      compress = false;
    } else if ((2 <= strnlen(argv[n], 3)) && ('-' == argv[n][0])) {
      if ((argv[n][1] >= '0') && (argv[n][1] <= '9')) {
        level = std::clamp(std::abs(std::stoi(argv[n], nullptr, 10)), 0, 12);
      }
    } else {
      if (nullptr != inFileName) {
        outFileName = argv[n];
      } else {
        inFileName = argv[n];
      }
    }
  }

  if (!((argc >= 4) && (argc <= 6)) || (nullptr == inFileName) || (nullptr == outFileName)) {
    static constexpr std::array<uint32_t, 11> use{{74, 102, 158, 270, 494, 943, 1841, 3636, 7228, 13383, 24669}};  // TODO verify this
    fprintf(stderr,
            "\nUsage: Moruga <command> <infile> <outfile>\n"
            "\n<Commands>\n"
            "  c\t\tCompress a file\n"
            "  d\t\tDecompress a file\n"
            "  -0 to -10\tUse %" PRIu32 ", %" PRIu32 ", %" PRIu32 ", %" PRIu32 ", %" PRIu32 ", %" PRIu32 ", %" PRIu32 ", %" PRIu32 ", %" PRIu32 ", %" PRIu32 " or %" PRIu32
            " MiB memory\n\t\tDefault %" PRIu32 ", %" PRIu32 " MiB memory",
            use[0], use[1], use[2], use[3], use[4], use[5], use[6], use[7], use[8], use[9], use[10], DEFAULT_OPTION, use[DEFAULT_OPTION]);
    return EXIT_FAILURE;
  }

#if defined(__linux__) || defined(_MSC_VER)
  if (!strcmp(inFileName, outFileName)) {
#else
  if (!strcasecmp(inFileName, outFileName)) {
#endif
    fprintf(stderr, "\n<infile> and <outfile> can not be identical!");
    return EXIT_FAILURE;
  }

  File_t infile{inFileName, "rb"};
  File_t outfile{outFileName, "wb+"};  // write/read otherwise decode will fail

  const auto originalLength{infile.Size()};

  const auto start_time{std::chrono::high_resolution_clock::now()};

  static constexpr auto coding_length{int64_t(6 * 8)};  // Limits file length to 2^48 bytes

  if (compress) {
    fprintf(stdout, "\nEncoding file '%s' ... with memory option %d\n", inFileName, level);

#if 1
    File_t tmp;  // ("_tmp_.txt", "wb+");
    const auto iLen{infile.Size()};
    if (iLen <= 0) {
      fprintf(stderr, "\nFile '%s' has no length, encoding not possible!", inFileName);
      return EXIT_FAILURE;
    }
    const auto data_pos{encode_txt(infile, tmp)};
    assert((data_pos > 0) && (data_pos < 0x07FFFFFF));
    const auto oLen{tmp.Size()};
    // At least 25% reduction, otherwise it will perform worse
    if (oLen < (iLen - (iLen / INT64_C(4)))) {
      infile.Close();
      infile = tmp;
      tmp = nullptr;
    } else {
      fprintf(stdout, "<binary file>\n");
      tmp.Close();
    }
#else
    const auto data_pos{INT64_C(0)};
    const int64_t iLen{infile.Size()};
    if (iLen <= 0) {
      fprintf(stderr, "\nFile '%s' has no length, encoding not possible!", inFileName);
      return EXIT_FAILURE;
    }
#endif
    infile.Rewind();

    assert((level >= 0) && (level <= 12));
    outfile.putc(level);  // Write memory level

    Buffer_t _buf{MEM()};
    Encoder_t en{_buf, true, outfile};

    // Original file length
    en.CompressN(coding_length, iLen);

    // File length after text preparation (successful or not)
    const auto len{infile.Size()};
    en.CompressN(coding_length, len);

    // Start point text preparation (successful or not)
    en.CompressN(coding_length, data_pos);

    const bool is_txtprep{iLen != len};  // Set if there was text preparation done

    uint8_t csum{checksum(reinterpret_cast<const uint8_t*>(&originalLength), sizeof(originalLength))};
    csum = uint8_t(csum + checksum(reinterpret_cast<const uint8_t*>(&len), sizeof(len)));
    en.Compress(csum);

    Monitor_t monitor{infile, outfile, len, iLen};
    Progress_t progress{"ENC", true, monitor};

    en.SetBinary(!is_txtprep);
    en.SetDataPos(data_pos);
    en.SetStart(is_txtprep);

    if (is_txtprep) {
      for (int32_t ch; EOF != (ch = infile.getc());) {
        en.Compress(ch);
      }
    } else {
      Filter_t filter{_buf, len, infile, &en};

      int64_t pos{0};
      for (int32_t ch; EOF != (ch = infile.getc()); ++pos) {
        if (filter.Scan(ch)) {
          continue;
        }
        en.Compress(ch);
      }
    }
    en.Flush();
  } else {
    if (infile.Size() <= 0) {
      fprintf(stderr, "\nFile '%s' has no length, decoding not possible!", inFileName);
      return EXIT_FAILURE;
    }

    level = infile.getc();  // Read memory level
    if (!((level >= 0) && (level <= 12))) {
      fprintf(stderr, "\nFile '%s' is damaged, decoding not possible!", inFileName);
      return EXIT_FAILURE;
    }

    fprintf(stdout, "\nDecoding file '%s' ... with memory option %d\n", inFileName, level);

    Buffer_t _buf{MEM()};
    Encoder_t en{_buf, false, infile};

    // Original file length
    const auto iLen{en.DecompressN(coding_length)};

    // File length after text preparation (successful or not)
    auto len{en.DecompressN(coding_length)};

    // Start point text preparation (successful or not)
    const int64_t data_pos{en.DecompressN(coding_length)};
    assert((data_pos >= 0) && (data_pos < 0x07FFFFFF));

    const bool is_txtprep{iLen != len};  // Set if there was text preparation done

    uint8_t csum{checksum(reinterpret_cast<const uint8_t*>(&iLen), sizeof(iLen))};
    csum = uint8_t(csum + checksum(reinterpret_cast<const uint8_t*>(&len), sizeof(len)));
    const auto valid{uint8_t(en.Decompress())};
    if (csum != valid) {
      fprintf(stderr, "\nFile '%s' is damaged, decoding not possible!", inFileName);
      return EXIT_FAILURE;
    }

    Monitor_t monitor{infile, outfile, len, iLen};

    {
      Progress_t progress{"DEC", false, monitor};

      en.SetBinary(!is_txtprep);
      en.SetDataPos(uint32_t(data_pos));
      en.SetStart(is_txtprep);

      if (is_txtprep) {
        for (int64_t pos{0}; pos < len; ++pos) {
          auto ch{en.Decompress()};
          outfile.putc(ch);
        }
      } else {
        Filter_t filter{_buf, len, outfile, nullptr};

        for (int64_t pos{0}; pos < len; ++pos) {
          auto ch{en.Decompress()};
          if (filter.Scan(ch, pos)) {
            continue;
          }
          assert(outfile.Position() == pos);
          outfile.putc(ch);
        }
      }
    }

#if 1
    if (iLen != len) {
      outfile.Rewind();
      File_t tmp;  // ("_TMP_.txt", "wb+");
      const auto oLen{decode_txt(outfile, tmp)};
      if (oLen > len) {
        tmp.Rewind();
        outfile.Rewind();

        auto i{oLen};
        while (i--) {
          outfile.putc(tmp.getc());
        }
        len = oLen;
      }
      tmp.Close();
    }
#endif
  }

  int64_t bytes_done{0};
  if (compress) {
    bytes_done = originalLength;
    fprintf(stdout, "\nEncoded from %" PRId64 " bytes to %" PRId64 " bytes.", bytes_done, outfile.Size());
#if 1                                             // TODO clean-up
    if (INT64_C(1000000000) == originalLength) {  // enwik9
      const auto improvement = INT64_C(138365990) - outfile.Size();
      fprintf(stdout, "\nImprovement %" PRId64 " bytes\n", improvement);
    } else if (INT64_C(100000000) == originalLength) {  // enwik8
      const auto improvement = INT64_C(17486266) - outfile.Size();
      fprintf(stdout, "\nImprovement %" PRId64 " bytes\n", improvement);
    }
#endif
  } else {
    bytes_done = outfile.Size();
    fprintf(stdout, "\nDecoded from %" PRId64 " bytes to %" PRId64 " bytes.", originalLength, bytes_done);
  }
  fprintf(stdout, "\nMaximum memory used: %" PRIu32 " KiB", Progress_t::PeakMemoryUse());

  const auto end_time{std::chrono::high_resolution_clock::now()};
  const std::chrono::high_resolution_clock::time_point delta_time{end_time - start_time};
  const auto duration_ns = double(std::chrono::duration_cast<std::chrono::nanoseconds>(delta_time.time_since_epoch()).count());

  fprintf(stdout, "\nTotal time %3.1f sec (%3.0f ns/byte)\n\n", duration_ns / 1e9, round(duration_ns / double(bytes_done)));

  return EXIT_SUCCESS;
}
