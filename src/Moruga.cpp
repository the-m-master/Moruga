/* Moruga file compressor based on PAQ8 by Matt Mahoney
 * Release by Marwijn Hessel, May., 2022
 *
 * Copyright (C) 2008 Matt Mahoney, Serge Osnach, Alexander Ratushnyak,
 * Bill Pettis, Przemyslaw Skibinski, Matthew Fite, wowtiger, Andrew Paterson,
 * Jan Ondrus, Andreas Morphis, Pavel L. Holoborodko, KZ., Simon Berger,
 * Neill Corlett, Marwijn Hessel, Mat Chartier
 *
 * We would like to express our gratitude for the endless support of many
 * contributors who encouraged PAQ8 development with ideas, testing,
 * compiling and debugging.
 *
 * Moruga is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moruga is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; see the file LICENSE.
 * If not, see <https://www.gnu.org/licenses/>
 *
 * https://github.com/the-m-master/Moruga
 */
#include <algorithm>
#include <array>
#include <cassert>
#include <chrono>
#include <cinttypes>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <exception>
#include <memory>
#include <new>
#include <string>
#include <utility>
#include "Buffer.h"
#include "File.h"
#include "IntegerXXL.h"
#include "Progress.h"
#include "TxtPrep4.h"
#include "Utilities.h"
#include "filters/filter.h"
#include "iEncoder.h"
#include "iMonitor.h"

#if defined(_WIN32) || defined(_WIN64)
#  include <processthreadsapi.h>
#  include <psapi.h>
#endif

#ifndef DEFAULT_OPTION
#  define DEFAULT_OPTION 4
#endif

static int32_t level_{DEFAULT_OPTION};  // Compression level 0 to 12

static auto MEM(const int32_t offset = 22) noexcept -> uint64_t {
  return UINT64_C(1) << (offset + level_);
}

// Global variables
static bool verbose_{false};  // Set during application parameter parsing (not change during activity)
static uint32_t bcount_{7};   // Bit processed (7..0) bcount_=7-bpos
static uint32_t c0_{1};       // Last 0-7 bits of the partial byte with a leading 1 bit (1-255)
static uint32_t c1_{0};       // Last two higher 4-bit nibbles
static uint32_t c2_{0};       // Last two higher 4-bit nibbles
static uint64_t cx_{0};       // Last 8 whole bytes (buf(8)..buf(1)), packed
static uint64_t word_{0};     // checksum of last 0..9, a..z and A..Z, reset to zero otherwise
static uint32_t fails_{0};    //
static uint32_t tt_{0};       //
static uint32_t w5_{0};       //
static uint32_t x5_{0};       //

//#define DEBUG_WRITE_ANALYSIS_ENCODER
//#define GENERATE_SQUASH_STRETCH

#if defined(GENERATE_SQUASH_STRETCH)

enum {
  NBITS = 12,        // Construct 12 bit tables
  TOP = 1 << NBITS,  // Top value
  HTOP = TOP / 2     // Half way value
};

[[nodiscard]] static auto inverf(const double x) noexcept -> double {
  double p;
  double t{log(fma(x, 0.0 - x, 1.0))};
  if (fabs(t) > 6.125) {
    // clang-format off
    p =            3.03697567e-10;
    p = fma(p, t,  2.93243101e-8);
    p = fma(p, t,  1.22150334e-6);
    p = fma(p, t,  2.84108955e-5);
    p = fma(p, t,  3.93552968e-4);
    p = fma(p, t,  3.02698812e-3);
    p = fma(p, t,  4.83185798e-3);
    p = fma(p, t, -2.64646143e-1);
    p = fma(p, t,  8.40016484e-1);
  } else {
    p =            5.43877832e-9;
    p = fma(p, t,  1.43286059e-7);
    p = fma(p, t,  1.22775396e-6);
    p = fma(p, t,  1.12962631e-7);
    p = fma(p, t, -5.61531961e-5);
    p = fma(p, t, -1.47697705e-4);
    p = fma(p, t,  2.31468701e-3);
    p = fma(p, t,  1.15392562e-2);
    p = fma(p, t, -2.32015476e-1);
    p = fma(p, t,  8.86226892e-1);
    // clang-format on
  }
  return p * x;
}

class Squash_t final {
public:
  explicit Squash_t(const double a = 756.1) noexcept {
    std::array<double, TOP> table{};
#  if 1
    //
    // Sigmoid: y(x) = erf(0.5 * sqrt(pi) * x)
    //          y(x) = erf(x/a)
    //
    for (uint32_t n{0}; n < TOP; ++n) {
      const double in{(double(n) - (HTOP - 1)) / a};  // Best when a=756.1 on enwik9
      double tmp{std::erf(in)};
      table[n] = (1.0 + tmp) / 2.0;

#    if !defined(NDEBUG)  // Small validation: 'inverf(erf(x)) = x'
      tmp = inverf(tmp);
      assert(std::fabs(tmp - in) < 1e-6);
#    endif
    }
    const double offset{table[0]};
    const double scale{double(TOP - 1) / (table[(TOP - 1)] - offset)};
    for (uint32_t n{0}; n < TOP; ++n) {
      double tmp{(table[n] - offset) * scale};
      _squash[n] = static_cast<uint16_t>(std::lround(tmp));
    }
#  elif 0
    //                      1
    // Sigmoid:  y(x) = ----------
    //                       -ax
    //                   1 + e
    //
    for (uint32_t n{0}; n < TOP; ++n) {
      table[n] = 1.0 / (1.0 + exp(((HTOP - 1) - double(n)) / double(a)));  // Best when a=315 on enwik9
    }
    const double offset{table[0]};
    const double scale{double(TOP - 1) / (table[(TOP - 1)] - offset)};
    for (uint32_t n{0}; n < TOP; ++n) {
      double tmp{(table[n] - offset) * scale};
      _squash[n] = static_cast<uint16_t>(std::lround(tmp));
    }
#  else
    (void)a;  // Not adjustable

    static constexpr std::array<uint16_t, 33> ts{{1,    2,    3,    6,    10,   16,   27,   45,    //
                                                  73,   120,  194,  310,  488,  747,  1101, 1546,  //
                                                  2047, 2549, 2994, 3348, 3607, 3785, 3901, 3975,  //
                                                  4022, 4050, 4068, 4079, 4085, 4089, 4092, 4093, 4094}};
    for (int32_t n{-(HTOP - 1)}; n < HTOP; ++n) {
      const int32_t w{n & 127};
      const int32_t d{(n >> 7) + 16};
      _squash[n + 2047] = static_cast<uint16_t>((ts[d] * (128 - w) + ts[(d + 1)] * w + 64) >> 7);
    }
#  endif

    File_t out("Squash.txt", "wb");
    for (uint32_t n{0}; n < TOP; ++n) {
      fprintf(out, "%d,", _squash[n]);
      if (!((n + 1) % 16)) {
        fprintf(out, "\n");
      }
    }
  }

  constexpr auto operator()(const int32_t d) const noexcept -> uint16_t {  // Conversion from -2048..2047 (clamped) into 0..4095
    // clang-format off
    if (d < ~0x7FF) { return 0x000; }
    if (d >  0x7FF) { return 0xFFF; }
    // clang-format on
    return _squash[static_cast<uint32_t>(d + HTOP)];
  }

  Squash_t(const Squash_t&) = delete;
  Squash_t(Squash_t&&) = delete;
  auto operator=(const Squash_t&) -> Squash_t& = delete;
  auto operator=(Squash_t&&) -> Squash_t& = delete;

private:
  std::array<uint16_t, TOP> _squash{};
};

static Squash_t* _squash{nullptr};

class Stretch_t final {
public:
  explicit Stretch_t(const double a = 756.1) noexcept {
#  if 1
    // Inverse of sigmoid: y(x) = inverf(x)
    //
    std::array<double, TOP> table{};
    for (uint32_t n{0}; n < TOP; ++n) {
      table[n] = inverf((double(n) - double(HTOP)) / 2048.0001) * a;
    }
    for (uint32_t n{0}; n < TOP; ++n) {
      int32_t tmp{std::lround(table[n])};
      _stretch[n] = static_cast<int16_t>(std::clamp(tmp, ~(HTOP - 1), (HTOP - 1)));
    }
#  else
    (void)a;  // Not adjustable

    // Inverse of sigmoid
    //
    uint32_t pi{0};
    for (int32_t n{0}; n < TOP; ++n) {
      const uint32_t i{(*_squash)(n - HTOP)};  // Conversion from -2048..2047 into 0..4095
      for (uint32_t j{pi}; j <= i; ++j) {
        _stretch[j] = static_cast<int16_t>(n - HTOP);
      }
      pi = i + 1;
    }
    _stretch[TOP - 1] = HTOP - 1;
#  endif

    File_t out("Stretch.txt", "wb");
    for (uint32_t n{0}; n < TOP; ++n) {
      fprintf(out, "%d,", _stretch[n]);
      if (!((n + 1) % 16)) {
        fprintf(out, "\n");
      }
    }
  }

  constexpr auto operator()(const uint32_t pr) const noexcept -> int16_t {  // Conversion from 0..4095 into -2048..2047
    assert(pr < TOP);
    return _stretch[pr];
  }

  Stretch_t(const Stretch_t&) = delete;
  Stretch_t(Stretch_t&&) = delete;
  auto operator=(const Stretch_t&) -> Stretch_t& = delete;
  auto operator=(Stretch_t&&) -> Stretch_t& = delete;

private:
  std::array<int16_t, TOP> _stretch{};
};

static Stretch_t* _stretch{nullptr};

static auto Squash(const int32_t d) noexcept -> uint16_t {  // Conversion from -2048..2047 (clamped) into 0..4095
  return (*_squash)(d);
}

static auto Stretch(const uint32_t pr) noexcept -> int16_t {  // Conversion from 0..4095 into -2048..2047
  return (*_stretch)(pr);
}

static auto Stretch256(const int32_t pr) noexcept -> int16_t {  // Conversion from 0..1048575 into -2048..2047
  return Stretch(static_cast<uint32_t>(pr) / 256);
}

#else

static constexpr std::array<uint16_t, 0x1000> __squash{{
#  include "Squash.txt"
}};

[[nodiscard]] ALWAYS_INLINE static constexpr auto Squash(const int32_t pr) noexcept -> uint16_t {  // Conversion from -2048..2047 (clamped) into 0..4095
  // clang-format off
  if (pr < ~0x7FF) { return 0x000; }
  if (pr >  0x7FF) { return 0xFFF; }
  // clang-format on
  return __squash[static_cast<size_t>(pr + 0x800)];
}

static constexpr std::array<int16_t, 0x1000> __stretch{{
#  include "Stretch.txt"
}};

[[nodiscard]] ALWAYS_INLINE static constexpr auto Stretch(const uint32_t pr) noexcept -> int16_t {  // Conversion from 0..4095 into -2048..2047
  assert(pr < 0x1000);
  return __stretch[pr];
}

[[nodiscard]] ALWAYS_INLINE static constexpr auto Stretch256(const int32_t pr) noexcept -> int16_t {  // Conversion from 0..1048575 into -2048..2047
  const auto d{static_cast<uint32_t>(pr) / 256};
#  if 0  // Does not help much, delta between stretch[d] and stretch[d+1] is around the edges small
  assert(d < 0x1000);
  const int32_t w{pr & 0xFF};
  const int32_t v{(__stretch[d] * (256 - w)) + (__stretch[d + 1] * w)};
  return static_cast<int16_t>(((v > 0) ? (v + 128) : (v - 128)) / 256);
#  else
  return Stretch(d);
#  endif
}

#endif  // GENERATE_SQUASH_STRETCH

template <typename T>
[[nodiscard]] ALWAYS_INLINE static constexpr auto clamp12(T val) noexcept -> int16_t {
  constexpr T lo{~0x7FF};
  constexpr T hi{0x7FF};
  return static_cast<int16_t>((val < lo) ? lo : (hi < val) ? hi : val);
}

static auto getDimension(size_t size) noexcept -> std::string {
  std::string size_dim{"Byte"};
  if (size > 9999) {
    size_dim = "KiB";
    size = ((size / 512) + 1) / 2;
    if (size > 9999) {
      size_dim = "MiB";
      size = ((size / 512) + 1) / 2;
      if (size > 9999) {
        size_dim = "GiB";
        size = ((size / 512) + 1) / 2;
      }
    }
  }

  std::array<char, 32> tmp{};
  snprintf(tmp.data(), tmp.size(), "%4" PRId64 " %s", size, size_dim.c_str());
  return tmp.data();
}

static int32_t dp_shift_{14};

static std::array<std::array<int32_t, 256>, 12> smt_;
static std::array<uint32_t, 5> hh_{{0, 0, 0, 0, 0}};

static constexpr std::array<std::array<uint8_t, 256>, 6> state_table_y0_                  //
    {{{{1,   3,   4,   7,   8,   9,   11,  15,  16,  17,  18,  20,  21,  22,  26,  31,    // 00-0F . . . . . . . . . . . . . . . .
        32,  32,  32,  32,  34,  34,  34,  34,  34,  34,  36,  36,  36,  36,  38,  41,    // 10-1F . . . . . . . . . . . . . . . .
        42,  42,  44,  44,  46,  46,  48,  48,  50,  53,  54,  54,  56,  56,  58,  58,    // 20-2F   ! " # $ % & ' ( ) * + , - . /
        60,  60,  62,  62,  50,  67,  68,  68,  70,  70,  72,  72,  74,  74,  76,  76,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        62,  62,  64,  83,  84,  84,  86,  86,  44,  44,  58,  58,  60,  60,  76,  76,    // 40-4F @ A B C D E F G H I J K L M N O
        78,  78,  80,  93,  94,  94,  96,  96,  48,  48,  88,  88,  80,  103, 104, 104,   // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        106, 106, 62,  62,  88,  88,  80,  113, 114, 114, 116, 116, 62,  62,  88,  88,    // 60-6F ` a b c d e f g h i j k l m n o
        90,  123, 124, 124, 126, 126, 62,  62,  98,  98,  90,  133, 134, 134, 136, 136,   // 70-7F p q r s t u v w x y z { | } ~ .
        62,  62,  98,  98,  90,  143, 144, 144, 68,  68,  62,  62,  98,  98,  100, 149,   // 80-8F . . . . . . . . . . . . . . . .
        150, 150, 108, 108, 100, 153, 154, 108, 100, 157, 158, 108, 100, 161, 162, 108,   // 90-9F . . . . . . . . . . . . . . . .
        110, 165, 166, 118, 110, 169, 170, 118, 110, 173, 174, 118, 110, 177, 178, 118,   // A0-AF . . . . . . . . . . . . . . . .
        110, 181, 182, 118, 120, 185, 186, 128, 120, 189, 190, 128, 120, 193, 194, 128,   // B0-BF . . . . . . . . . . . . . . . .
        120, 197, 198, 128, 120, 201, 202, 128, 120, 205, 206, 128, 120, 209, 210, 128,   // C0-CF . . . . . . . . . . . . . . . .
        130, 213, 214, 138, 130, 217, 218, 138, 130, 221, 222, 138, 130, 225, 226, 138,   // D0-DF . . . . . . . . . . . . . . . .
        130, 229, 230, 138, 130, 233, 234, 138, 130, 237, 238, 138, 130, 241, 242, 138,   // E0-EF . . . . . . . . . . . . . . . .
        130, 245, 246, 138, 140, 249, 250, 80,  140, 253, 254, 80,  140, 253, 254, 80}},  // F0-FF . . . . . . . . . . . . . . . .

      {{2,   2,   6,   5,   9,   13,  14,  11,  17,  25,  21,  27,  19,  29,  30,  23,     // 00-0F . . . . . . . . . . . . . . . .
        33,  49,  37,  51,  41,  53,  45,  55,  35,  57,  43,  59,  39,  61,  62,  47,     // 10-1F . . . . . . . . . . . . . . . .
        65,  97,  69,  99,  73,  101, 77,  103, 81,  105, 85,  107, 89,  109, 93,  111,    // 20-2F   ! " # $ % & ' ( ) * + , - . /
        67,  113, 75,  115, 83,  117, 91,  119, 71,  121, 87,  123, 79,  125, 126, 95,     // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        65,  97,  69,  99,  73,  101, 77,  103, 81,  105, 85,  107, 89,  109, 93,  111,    // 40-4F @ A B C D E F G H I J K L M N O
        65,  97,  69,  99,  73,  101, 77,  103, 81,  105, 85,  107, 89,  109, 93,  111,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        67,  113, 75,  115, 83,  117, 91,  119, 67,  113, 75,  115, 83,  117, 91,  119,    // 60-6F ` a b c d e f g h i j k l m n o
        71,  121, 87,  123, 71,  121, 87,  123, 79,  125, 79,  125, 79,  130, 128, 95,     // 70-7F p q r s t u v w x y z { | } ~ .
        132, 95,  134, 79,  136, 95,  138, 79,  140, 95,  142, 79,  144, 95,  146, 79,     // 80-8F . . . . . . . . . . . . . . . .
        148, 95,  150, 79,  152, 95,  154, 79,  156, 95,  158, 79,  156, 95,  160, 79,     // 90-9F . . . . . . . . . . . . . . . .
        162, 103, 164, 103, 166, 103, 168, 103, 170, 103, 172, 103, 174, 103, 176, 103,    // A0-AF . . . . . . . . . . . . . . . .
        178, 103, 180, 103, 182, 103, 184, 103, 186, 103, 188, 103, 190, 103, 192, 103,    // B0-BF . . . . . . . . . . . . . . . .
        194, 103, 196, 103, 198, 103, 200, 103, 202, 115, 204, 115, 206, 115, 208, 115,    // C0-CF . . . . . . . . . . . . . . . .
        210, 115, 212, 115, 214, 115, 216, 115, 218, 115, 220, 115, 222, 115, 224, 115,    // D0-DF . . . . . . . . . . . . . . . .
        226, 115, 228, 115, 230, 115, 232, 115, 234, 115, 236, 115, 238, 115, 240, 115,    // E0-EF . . . . . . . . . . . . . . . .
        242, 115, 244, 115, 246, 115, 248, 115, 250, 115, 252, 115, 254, 115, 254, 115}},  // F0-FF . . . . . . . . . . . . . . . .

      {{1,   3,   5,   7,   9,   11,  13,  15,  17,  19,  21,  23,  25,  27,  29,  31,     // 00-0F . . . . . . . . . . . . . . . .
        33,  35,  37,  39,  41,  43,  45,  47,  49,  51,  53,  55,  57,  59,  61,  63,     // 10-1F . . . . . . . . . . . . . . . .
        65,  67,  69,  71,  73,  75,  77,  79,  81,  83,  85,  87,  89,  91,  93,  95,     // 20-2F   ! " # $ % & ' ( ) * + , - . /
        97,  99,  101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159,    // 40-4F @ A B C D E F G H I J K L M N O
        161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223,    // 60-6F ` a b c d e f g h i j k l m n o
        225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 127,    // 70-7F p q r s t u v w x y z { | } ~ .
        129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159,    // 80-8F . . . . . . . . . . . . . . . .
        161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191,    // 90-9F . . . . . . . . . . . . . . . .
        193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223,    // A0-AF . . . . . . . . . . . . . . . .
        225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 189, 255,    // B0-BF . . . . . . . . . . . . . . . .
        129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159,    // C0-CF . . . . . . . . . . . . . . . .
        161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191,    // D0-DF . . . . . . . . . . . . . . . .
        193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223,    // E0-EF . . . . . . . . . . . . . . . .
        225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255}},  // F0-FF . . . . . . . . . . . . . . . .

      {{1,   3,   5,   6,   9,   8,   10,  13,  12,  14,  15,  18,  17,  20,  19,  21,     // 00-0F . . . . . . . . . . . . . . . .
        24,  23,  26,  25,  27,  28,  31,  30,  33,  32,  35,  34,  36,  39,  38,  41,     // 10-1F . . . . . . . . . . . . . . . .
        40,  43,  42,  44,  45,  48,  47,  50,  49,  52,  51,  54,  53,  55,  58,  57,     // 20-2F   ! " # $ % & ' ( ) * + , - . /
        60,  59,  62,  61,  64,  63,  65,  66,  69,  68,  71,  70,  73,  72,  75,  74,     // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        77,  76,  78,  81,  80,  83,  82,  85,  84,  87,  86,  89,  88,  90,  91,  94,     // 40-4F @ A B C D E F G H I J K L M N O
        93,  96,  95,  98,  97,  100, 99,  102, 101, 104, 103, 105, 108, 107, 110, 109,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        112, 111, 114, 113, 116, 115, 118, 117, 119, 105, 121, 120, 123, 122, 125, 124,    // 60-6F ` a b c d e f g h i j k l m n o
        127, 126, 129, 128, 131, 130, 133, 132, 134, 137, 38,  139, 138, 141, 140, 143,    // 70-7F p q r s t u v w x y z { | } ~ .
        142, 145, 144, 147, 146, 148, 149, 39,  47,  152, 151, 154, 153, 156, 155, 158,    // 80-8F . . . . . . . . . . . . . . . .
        157, 160, 159, 162, 161, 163, 48,  59,  166, 49,  168, 167, 170, 169, 172, 171,    // 90-9F . . . . . . . . . . . . . . . .
        174, 173, 175, 176, 48,  59,  179, 178, 181, 180, 183, 182, 185, 184, 187, 186,    // A0-AF . . . . . . . . . . . . . . . .
        188, 58,  72,  191, 190, 193, 192, 195, 194, 197, 196, 198, 199, 58,  72,  202,    // B0-BF . . . . . . . . . . . . . . . .
        201, 204, 203, 206, 205, 208, 207, 209, 69,  86,  212, 211, 214, 213, 216, 215,    // C0-CF . . . . . . . . . . . . . . . .
        217, 218, 69,  86,  221, 220, 223, 222, 225, 224, 226, 81,  101, 229, 228, 231,    // D0-DF . . . . . . . . . . . . . . . .
        230, 232, 233, 81,  101, 236, 235, 238, 237, 239, 94,  117, 242, 241, 243, 244,    // E0-EF . . . . . . . . . . . . . . . .
        94,  117, 247, 246, 248, 108, 132, 250, 251, 108, 246, 253, 121, 255, 121, 255}},  // F0-FF . . . . . . . . . . . . . . . .

      {{1,   4,   3,   6,   8,   7,   11,  10,  13,  12,  15,  17,  16,  19,  18,  22,     // 00-0F . . . . . . . . . . . . . . . .
        21,  24,  23,  26,  25,  28,  30,  29,  32,  31,  34,  33,  37,  36,  39,  38,     // 10-1F . . . . . . . . . . . . . . . .
        41,  40,  43,  42,  45,  47,  46,  49,  48,  51,  50,  53,  52,  56,  55,  58,     // 20-2F   ! " # $ % & ' ( ) * + , - . /
        57,  60,  59,  62,  61,  64,  63,  66,  68,  67,  70,  69,  72,  71,  74,  73,     // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        76,  75,  79,  78,  81,  80,  83,  82,  85,  84,  87,  86,  89,  88,  91,  93,     // 40-4F @ A B C D E F G H I J K L M N O
        92,  95,  94,  97,  96,  99,  98,  101, 100, 103, 102, 106, 105, 108, 107, 110,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        109, 112, 111, 114, 113, 116, 115, 118, 117, 120, 122, 121, 124, 123, 126, 125,    // 60-6F ` a b c d e f g h i j k l m n o
        128, 127, 130, 129, 132, 131, 118, 133, 135, 134, 137, 136, 139, 138, 141, 140,    // 70-7F p q r s t u v w x y z { | } ~ .
        143, 142, 41,  144, 147, 146, 149, 151, 150, 153, 152, 155, 154, 157, 156, 159,    // 80-8F . . . . . . . . . . . . . . . .
        158, 74,  160, 161, 52,  164, 163, 166, 165, 168, 167, 170, 169, 172, 171, 85,     // 90-9F . . . . . . . . . . . . . . . .
        173, 174, 52,  176, 178, 177, 180, 179, 182, 181, 184, 183, 97,  185, 186, 63,     // A0-AF . . . . . . . . . . . . . . . .
        189, 188, 191, 190, 193, 192, 195, 194, 97,  196, 197, 63,  199, 201, 200, 203,    // B0-BF . . . . . . . . . . . . . . . .
        202, 205, 204, 110, 206, 207, 75,  210, 209, 212, 211, 214, 213, 124, 215, 216,    // C0-CF . . . . . . . . . . . . . . . .
        75,  218, 220, 219, 222, 221, 124, 223, 224, 88,  227, 226, 229, 228, 137, 230,    // D0-DF . . . . . . . . . . . . . . . .
        231, 88,  233, 235, 234, 151, 236, 237, 102, 240, 239, 151, 241, 242, 102, 244,    // E0-EF . . . . . . . . . . . . . . . .
        164, 245, 246, 117, 176, 248, 249, 117, 244, 251, 133, 253, 133, 255, 148, 255}},  // F0-FF . . . . . . . . . . . . . . . .

      {{10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 14, 68, 70, 70, 70,      // 00-0F . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 10-1F . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 20-2F   ! " # $ % & ' ( ) * + , - . /
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        10, 10, 10, 10, 68, 70, 70, 70, 10, 10, 10, 10, 10, 10, 10, 10,      // 40-4F @ A B C D E F G H I J K L M N O
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 60-6F ` a b c d e f g h i j k l m n o
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 70-7F p q r s t u v w x y z { | } ~ .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 80-8F . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // 90-9F . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // A0-AF . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // B0-BF . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // C0-CF . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // D0-DF . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,      // E0-EF . . . . . . . . . . . . . . . .
        10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10}}}};  // F0-FF . . . . . . . . . . . . . . . .

static constexpr std::array<std::array<uint8_t, 256>, 6> state_table_y1_                   //
    {{{{2,   5,   6,   10,  12,  13,  14,  19,  23,  24,  25,  27,  28,  29,  30,  33,     // 00-0F . . . . . . . . . . . . . . . .
        35,  35,  35,  35,  37,  37,  37,  37,  37,  37,  39,  39,  39,  39,  40,  43,     // 10-1F . . . . . . . . . . . . . . . .
        45,  45,  47,  47,  49,  49,  51,  51,  52,  43,  57,  57,  59,  59,  61,  61,     // 20-2F   ! " # $ % & ' ( ) * + , - . /
        63,  63,  65,  65,  66,  55,  57,  57,  73,  73,  75,  75,  77,  77,  79,  79,     // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        81,  81,  82,  69,  71,  71,  73,  73,  59,  59,  61,  61,  49,  49,  89,  89,     // 40-4F @ A B C D E F G H I J K L M N O
        91,  91,  92,  69,  87,  87,  45,  45,  99,  99,  101, 101, 102, 69,  87,  87,     // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        57,  57,  109, 109, 111, 111, 112, 85,  87,  87,  57,  57,  119, 119, 121, 121,    // 60-6F ` a b c d e f g h i j k l m n o
        122, 85,  97,  97,  57,  57,  129, 129, 131, 131, 132, 85,  97,  97,  57,  57,     // 70-7F p q r s t u v w x y z { | } ~ .
        139, 139, 141, 141, 142, 95,  97,  97,  57,  57,  81,  81,  147, 147, 148, 95,     // 80-8F . . . . . . . . . . . . . . . .
        107, 107, 151, 151, 152, 95,  107, 155, 156, 95,  107, 159, 160, 105, 107, 163,    // 90-9F . . . . . . . . . . . . . . . .
        164, 105, 117, 167, 168, 105, 117, 171, 172, 105, 117, 175, 176, 105, 117, 179,    // A0-AF . . . . . . . . . . . . . . . .
        180, 115, 117, 183, 184, 115, 127, 187, 188, 115, 127, 191, 192, 115, 127, 195,    // B0-BF . . . . . . . . . . . . . . . .
        196, 115, 127, 199, 200, 115, 127, 203, 204, 115, 127, 207, 208, 125, 127, 211,    // C0-CF . . . . . . . . . . . . . . . .
        212, 125, 137, 215, 216, 125, 137, 219, 220, 125, 137, 223, 224, 125, 137, 227,    // D0-DF . . . . . . . . . . . . . . . .
        228, 125, 137, 231, 232, 125, 137, 235, 236, 125, 137, 239, 240, 125, 137, 243,    // E0-EF . . . . . . . . . . . . . . . .
        244, 135, 137, 247, 248, 135, 69,  251, 252, 135, 69,  255, 252, 135, 69,  255}},  // F0-FF . . . . . . . . . . . . . . . .

      {{3,   3,   4,   7,   12,  10,  8,   15,  24,  18,  26,  22,  28,  20,  16,  31,     // 00-0F . . . . . . . . . . . . . . . .
        48,  34,  50,  38,  52,  42,  54,  46,  56,  36,  58,  44,  60,  40,  32,  63,     // 10-1F . . . . . . . . . . . . . . . .
        96,  66,  98,  70,  100, 74,  102, 78,  104, 82,  106, 86,  108, 90,  110, 94,     // 20-2F   ! " # $ % & ' ( ) * + , - . /
        112, 68,  114, 76,  116, 84,  118, 92,  120, 72,  122, 88,  124, 80,  64,  127,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        96,  66,  98,  70,  100, 74,  102, 78,  104, 82,  106, 86,  108, 90,  110, 94,     // 40-4F @ A B C D E F G H I J K L M N O
        96,  66,  98,  70,  100, 74,  102, 78,  104, 82,  106, 86,  108, 90,  110, 94,     // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        112, 68,  114, 76,  116, 84,  118, 92,  112, 68,  114, 76,  116, 84,  118, 92,     // 60-6F ` a b c d e f g h i j k l m n o
        120, 72,  122, 88,  120, 72,  122, 88,  124, 80,  124, 80,  131, 80,  64,  129,    // 70-7F p q r s t u v w x y z { | } ~ .
        64,  133, 80,  135, 64,  137, 80,  139, 64,  141, 80,  143, 64,  145, 80,  147,    // 80-8F . . . . . . . . . . . . . . . .
        64,  149, 80,  151, 64,  153, 80,  155, 64,  157, 80,  159, 64,  157, 80,  161,    // 90-9F . . . . . . . . . . . . . . . .
        104, 163, 104, 165, 104, 167, 104, 169, 104, 171, 104, 173, 104, 175, 104, 177,    // A0-AF . . . . . . . . . . . . . . . .
        104, 179, 104, 181, 104, 183, 104, 185, 104, 187, 104, 189, 104, 191, 104, 193,    // B0-BF . . . . . . . . . . . . . . . .
        104, 195, 104, 197, 104, 199, 104, 201, 116, 203, 116, 205, 116, 207, 116, 209,    // C0-CF . . . . . . . . . . . . . . . .
        116, 211, 116, 213, 116, 215, 116, 217, 116, 219, 116, 221, 116, 223, 116, 225,    // D0-DF . . . . . . . . . . . . . . . .
        116, 227, 116, 229, 116, 231, 116, 233, 116, 235, 116, 237, 116, 239, 116, 241,    // E0-EF . . . . . . . . . . . . . . . .
        116, 243, 116, 245, 116, 247, 116, 249, 116, 251, 116, 253, 116, 255, 116, 255}},  // F0-FF . . . . . . . . . . . . . . . .

      {{2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24,  26,  28,  30,  32,     // 00-0F . . . . . . . . . . . . . . . .
        34,  36,  38,  40,  42,  44,  46,  48,  50,  52,  54,  56,  58,  60,  62,  64,     // 10-1F . . . . . . . . . . . . . . . .
        66,  68,  70,  72,  74,  76,  78,  80,  82,  84,  86,  88,  90,  92,  94,  96,     // 20-2F   ! " # $ % & ' ( ) * + , - . /
        98,  100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160,    // 40-4F @ A B C D E F G H I J K L M N O
        162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,    // 60-6F ` a b c d e f g h i j k l m n o
        226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 128,    // 70-7F p q r s t u v w x y z { | } ~ .
        130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160,    // 80-8F . . . . . . . . . . . . . . . .
        162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,    // 90-9F . . . . . . . . . . . . . . . .
        194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,    // A0-AF . . . . . . . . . . . . . . . .
        226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 190, 192,    // B0-BF . . . . . . . . . . . . . . . .
        130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160,    // C0-CF . . . . . . . . . . . . . . . .
        162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,    // D0-DF . . . . . . . . . . . . . . . .
        194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,    // E0-EF . . . . . . . . . . . . . . . .
        226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 192}},  // F0-FF . . . . . . . . . . . . . . . .

      {{2,   5,   4,   8,   7,   9,   12,  11,  14,  13,  17,  16,  19,  18,  20,  23,     // 00-0F . . . . . . . . . . . . . . . .
        22,  25,  24,  27,  26,  30,  29,  32,  31,  34,  33,  35,  38,  37,  40,  39,     // 10-1F . . . . . . . . . . . . . . . .
        42,  41,  44,  43,  47,  46,  49,  48,  51,  50,  53,  52,  54,  57,  56,  59,     // 20-2F   ! " # $ % & ' ( ) * + , - . /
        58,  61,  60,  63,  62,  65,  64,  68,  67,  70,  69,  72,  71,  74,  73,  76,     // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        75,  77,  80,  79,  82,  81,  84,  83,  86,  85,  88,  87,  90,  89,  93,  92,     // 40-4F @ A B C D E F G H I J K L M N O
        95,  94,  97,  96,  99,  98,  101, 100, 103, 102, 104, 107, 106, 109, 108, 111,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        110, 113, 112, 115, 114, 117, 116, 119, 118, 120, 106, 122, 121, 124, 123, 126,    // 60-6F ` a b c d e f g h i j k l m n o
        125, 128, 127, 130, 129, 132, 131, 133, 136, 135, 138, 39,  140, 139, 142, 141,    // 70-7F p q r s t u v w x y z { | } ~ .
        144, 143, 146, 145, 148, 147, 38,  150, 151, 48,  153, 152, 155, 154, 157, 156,    // 80-8F . . . . . . . . . . . . . . . .
        159, 158, 161, 160, 162, 47,  164, 165, 60,  167, 50,  169, 168, 171, 170, 173,    // 90-9F . . . . . . . . . . . . . . . .
        172, 175, 174, 47,  177, 178, 60,  180, 179, 182, 181, 184, 183, 186, 185, 187,    // A0-AF . . . . . . . . . . . . . . . .
        57,  189, 190, 73,  192, 191, 194, 193, 196, 195, 198, 197, 57,  200, 201, 73,     // B0-BF . . . . . . . . . . . . . . . .
        203, 202, 205, 204, 207, 206, 208, 68,  210, 211, 87,  213, 212, 215, 214, 217,    // C0-CF . . . . . . . . . . . . . . . .
        216, 68,  219, 220, 87,  222, 221, 224, 223, 225, 80,  227, 228, 102, 230, 229,    // D0-DF . . . . . . . . . . . . . . . .
        232, 231, 80,  234, 235, 102, 237, 236, 238, 93,  240, 241, 118, 243, 242, 93,     // E0-EF . . . . . . . . . . . . . . . .
        245, 246, 118, 247, 107, 249, 250, 133, 107, 252, 247, 120, 254, 120, 254, 134}},  // F0-FF . . . . . . . . . . . . . . . .

      {{2,   3,   5,   7,   6,   9,   10,  12,  11,  14,  16,  15,  18,  17,  20,  21,     // 00-0F . . . . . . . . . . . . . . . .
        23,  22,  25,  24,  27,  29,  28,  31,  30,  33,  32,  35,  36,  38,  37,  40,     // 10-1F . . . . . . . . . . . . . . . .
        39,  42,  41,  44,  46,  45,  48,  47,  50,  49,  52,  51,  54,  55,  57,  56,     // 20-2F   ! " # $ % & ' ( ) * + , - . /
        59,  58,  61,  60,  63,  62,  65,  67,  66,  69,  68,  71,  70,  73,  72,  75,     // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        74,  77,  78,  80,  79,  82,  81,  84,  83,  86,  85,  88,  87,  90,  92,  91,     // 40-4F @ A B C D E F G H I J K L M N O
        94,  93,  96,  95,  98,  97,  100, 99,  102, 101, 104, 105, 107, 106, 109, 108,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        111, 110, 113, 112, 115, 114, 117, 116, 119, 121, 120, 123, 122, 125, 124, 127,    // 60-6F ` a b c d e f g h i j k l m n o
        126, 129, 128, 131, 130, 133, 132, 119, 134, 136, 135, 138, 137, 140, 139, 142,    // 70-7F p q r s t u v w x y z { | } ~ .
        141, 144, 143, 42,  145, 148, 150, 149, 152, 151, 154, 153, 156, 155, 158, 157,    // 80-8F . . . . . . . . . . . . . . . .
        160, 159, 75,  51,  162, 163, 165, 164, 167, 166, 169, 168, 171, 170, 173, 172,    // 90-9F . . . . . . . . . . . . . . . .
        86,  51,  175, 177, 176, 179, 178, 181, 180, 183, 182, 185, 184, 98,  62,  187,    // A0-AF . . . . . . . . . . . . . . . .
        188, 190, 189, 192, 191, 194, 193, 196, 195, 98,  62,  198, 200, 199, 202, 201,    // B0-BF . . . . . . . . . . . . . . . .
        204, 203, 206, 205, 111, 74,  208, 209, 211, 210, 213, 212, 215, 214, 125, 74,     // C0-CF . . . . . . . . . . . . . . . .
        217, 219, 218, 221, 220, 223, 222, 125, 87,  225, 226, 228, 227, 230, 229, 138,    // D0-DF . . . . . . . . . . . . . . . .
        87,  232, 234, 233, 236, 235, 152, 101, 238, 239, 241, 240, 152, 101, 243, 245,    // E0-EF . . . . . . . . . . . . . . . .
        244, 165, 116, 247, 248, 177, 116, 250, 245, 132, 252, 132, 254, 147, 254, 147}},  // F0-FF . . . . . . . . . . . . . . . .

      {{11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 13, 15, 69, 69, 69, 71,      // 00-0F . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 10-1F . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 20-2F   ! " # $ % & ' ( ) * + , - . /
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        11, 11, 11, 11, 69, 69, 69, 71, 11, 11, 11, 11, 11, 11, 11, 11,      // 40-4F @ A B C D E F G H I J K L M N O
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 60-6F ` a b c d e f g h i j k l m n o
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 70-7F p q r s t u v w x y z { | } ~ .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 80-8F . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // 90-9F . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // A0-AF . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // B0-BF . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // C0-CF . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // D0-DF . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,      // E0-EF . . . . . . . . . . . . . . . .
        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11}}}};  // F0-FF . . . . . . . . . . . . . . . .

static constexpr std::array<uint8_t, 256> wrt_mxr_                       //
    {{0,  0,  0,  0,  0,  0,  10, 20, 0,  4,  28, 0,  0,  0,  0,  0,     // 00-0F . . . . . . . . . . . . . . . .
      0,  0,  0,  0,  0,  0,  0,  0,  10, 0,  0,  0,  0,  0,  0,  0,     // 10-1F . . . . . . . . . . . . . . . .
      4,  20, 26, 20, 22, 28, 26, 22, 30, 6,  28, 30, 6,  30, 24, 30,    // 20-2F   ! " # $ % & ' ( ) * + , - . /
      2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  20, 30, 26, 22, 0,  30,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
      18, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,    // 40-4F @ A B C D E F G H I J K L M N O
      10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 8,  20, 6,  28, 30,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
      20, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,    // 60-6F ` a b c d e f g h i j k l m n o
      10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 30, 20, 22, 30, 20,    // 70-7F p q r s t u v w x y z { | } ~ .
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,    // 80-8F . . . . . . . . . . . . . . . .
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,    // 90-9F . . . . . . . . . . . . . . . .
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,    // A0-AF . . . . . . . . . . . . . . . .
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,    // B0-BF . . . . . . . . . . . . . . . .
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,    // C0-CF . . . . . . . . . . . . . . . .
      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,    // D0-DF . . . . . . . . . . . . . . . .
      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,    // E0-EF . . . . . . . . . . . . . . . .
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16}};  // F0-FF . . . . . . . . . . . . . . . .

static constexpr std::array<uint8_t, 256> limits_15a_             //
    {{0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 24, 24, 16, 16, 16, 16,   // 00-0F . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 10-1F . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 20-2F   ! " # $ % & ' ( ) * + , - . /
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
      0, 0, 0, 0, 2, 176, 176, 2, 0, 0, 0,  0,  0,  0,  0,  0,    // 40-4F @ A B C D E F G H I J K L M N O
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 60-6F ` a b c d e f g h i j k l m n o
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 70-7F p q r s t u v w x y z { | } ~ .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 80-8F . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 90-9F . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // A0-AF . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // B0-BF . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // C0-CF . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // D0-DF . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // E0-EF . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0}};  // F0-FF . . . . . . . . . . . . . . . .

static constexpr std::array<uint8_t, 256> limits_15b_             //
    {{0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 18, 18, 12, 12, 12, 12,   // 00-0F . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 10-1F . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 20-2F   ! " # $ % & ' ( ) * + , - . /
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
      0, 0, 0, 0, 1, 168, 168, 1, 0, 0, 0,  0,  0,  0,  0,  0,    // 40-4F @ A B C D E F G H I J K L M N O
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 60-6F ` a b c d e f g h i j k l m n o
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 70-7F p q r s t u v w x y z { | } ~ .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 80-8F . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // 90-9F . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // A0-AF . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // B0-BF . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // C0-CF . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // D0-DF . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0,    // E0-EF . . . . . . . . . . . . . . . .
      0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0,  0,  0,  0,  0,  0}};  // F0-FF . . . . . . . . . . . . . . . .

/**
 * @class APM_t
 * Adaptive Probability Maps
 */
class APM_t final {
public:
  explicit APM_t(const uint64_t n, const uint32_t start = 8) noexcept
      : N{(n * 24) + 1},  //
        _mask{static_cast<uint32_t>(n - 1)},
        _map{static_cast<Map_t*>(std::calloc(N, sizeof(Map_t)))} {
    assert(ISPOWEROF2(n));
    if (verbose_) {
      fprintf(stdout, "%s for APM_t\n", getDimension(N * sizeof(Map_t)).c_str());
    }
    for (auto i{N}; i--;) {
      const auto pr{(8 == start) ? (((((i % 24) * 2) + 1) * 4096) / (24 * 2)) : (((i % 24) * 4096) / (24 - 1))};
      const auto prediction{Squash(static_cast<int32_t>(pr) - 2048) * (UINT32_C(1) << 10)};  // Conversion from -2048..2047 (clamped) into 0..4095
      _map[i].prediction = 0x3FFFFF & prediction;
      _map[i].count = 0x3FF & start;

      assert((_map[i].value >> 10) == prediction);
      assert((_map[i].value & 0x3FF) == start);
    }
  }
  virtual ~APM_t() noexcept;

  APM_t() = delete;
  APM_t(const APM_t&) = delete;
  APM_t(APM_t&&) = delete;
  auto operator=(const APM_t&) -> APM_t& = delete;
  auto operator=(APM_t&&) -> APM_t& = delete;

  [[nodiscard]] auto p1(const bool bit, const int32_t pr, const uint32_t cx) noexcept -> uint16_t {
    Update(bit, _dta);
    return Predict(pr, cx);
  }

  [[nodiscard]] auto p2(const bool bit, const int32_t pr, const uint32_t cx) noexcept -> uint16_t {
    Update(bit, _dtb);
    return Predict(pr, cx);
  }

  [[nodiscard]] auto p3(const bool bit, const uint32_t pr, const uint32_t cx) noexcept -> uint16_t {
    Update(bit, _dtc);
    return Predict(Stretch(pr), cx);
  }

private:
  void Update(const bool bit, const std::array<int16_t, 0x400>& dt) noexcept {
    auto& map{_map[_ctx]};
    const auto prediction{static_cast<int32_t>(map.prediction)};
    const auto count{map.count};
    const auto err{((bit << 22) - prediction) >> 3};
    map.value += (static_cast<uint32_t>(err * dt[count]) & -0x400U) + (count < 0x3FF);
  }

  [[nodiscard]] auto Predict(int32_t pr, uint32_t cx) noexcept -> uint16_t {
    assert((pr >= -2048) && (pr < 2048));
    assert((cx & _mask) < (N / 24));
    pr = (24 - 1) * (pr + 2048);                       // Conversion from -2048..2047 into 0..94185
    const auto wt{static_cast<uint32_t>(0xFFF & pr)};  // interpolation weight of next element
    cx = (24 * (cx & _mask)) + static_cast<uint32_t>(pr >> 12);
    assert(cx < (N - 1));
    _ctx = cx + (wt >> 11);
    assert(_ctx < N);
    const uint64_t vx{_map[cx + 0].value};                  // Prediction is needed, count is shifted out later on
    const uint64_t vy{_map[cx + 1].value};                  // Prediction is needed, count is shifted out later on
    const auto py{((vx * 4096) - ((vx - vy) * wt)) >> 32};  // Calculate new prediction, lose count
    assert(py < 0x1000);
    return static_cast<uint16_t>(py);
  }

  // (72 * 128) / (i+4)
  static constexpr std::array<int16_t, 0x400> _dta{{2304, 1843, 1536, 1316, 1152, 1024, 921, 837, 768, 708, 658, 614, 576, 542, 512, 485,  // 000-00F
                                                    460,  438,  418,  400,  384,  368,  354, 341, 329, 317, 307, 297, 288, 279, 271, 263,  // 010-01F
                                                    256,  249,  242,  236,  230,  224,  219, 214, 209, 204, 200, 196, 192, 188, 184, 180,  // 020-02F
                                                    177,  173,  170,  167,  164,  161,  158, 156, 153, 151, 148, 146, 144, 141, 139, 137,  // 030-03F
                                                    135,  133,  131,  129,  128,  126,  124, 122, 121, 119, 118, 116, 115, 113, 112, 111,  // 040-04F
                                                    109,  108,  107,  105,  104,  103,  102, 101, 100, 99,  98,  97,  96,  95,  94,  93,   // 050-05F
                                                    92,   91,   90,   89,   88,   87,   86,  86,  85,  84,  83,  83,  82,  81,  80,  80,   // 060-06F
                                                    79,   78,   78,   77,   76,   76,   75,  74,  74,  73,  73,  72,  72,  71,  70,  70,   // 070-07F
                                                    69,   69,   68,   68,   67,   67,   66,  66,  65,  65,  64,  64,  64,  63,  63,  62,   // 080-08F
                                                    62,   61,   61,   61,   60,   60,   59,  59,  59,  58,  58,  57,  57,  57,  56,  56,   // 090-09F
                                                    56,   55,   55,   55,   54,   54,   54,  53,  53,  53,  52,  52,  52,  52,  51,  51,   // 0A0-0AF
                                                    51,   50,   50,   50,   50,   49,   49,  49,  49,  48,  48,  48,  48,  47,  47,  47,   // 0B0-0BF
                                                    47,   46,   46,   46,   46,   45,   45,  45,  45,  44,  44,  44,  44,  44,  43,  43,   // 0C0-0CF
                                                    43,   43,   43,   42,   42,   42,   42,  42,  41,  41,  41,  41,  41,  40,  40,  40,   // 0D0-0DF
                                                    40,   40,   40,   39,   39,   39,   39,  39,  39,  38,  38,  38,  38,  38,  38,  37,   // 0E0-0EF
                                                    37,   37,   37,   37,   37,   37,   36,  36,  36,  36,  36,  36,  36,  35,  35,  35,   // 0F0-0FF
                                                    35,   35,   35,   35,   34,   34,   34,  34,  34,  34,  34,  34,  33,  33,  33,  33,   // 100-10F
                                                    33,   33,   33,   33,   32,   32,   32,  32,  32,  32,  32,  32,  32,  31,  31,  31,   // 110-11F
                                                    31,   31,   31,   31,   31,   31,   30,  30,  30,  30,  30,  30,  30,  30,  30,  30,   // 120-12F
                                                    29,   29,   29,   29,   29,   29,   29,  29,  29,  29,  28,  28,  28,  28,  28,  28,   // 130-13F
                                                    28,   28,   28,   28,   28,   28,   27,  27,  27,  27,  27,  27,  27,  27,  27,  27,   // 140-14F
                                                    27,   27,   26,   26,   26,   26,   26,  26,  26,  26,  26,  26,  26,  26,  26,  25,   // 150-15F
                                                    25,   25,   25,   25,   25,   25,   25,  25,  25,  25,  25,  25,  25,  24,  24,  24,   // 160-16F
                                                    24,   24,   24,   24,   24,   24,   24,  24,  24,  24,  24,  24,  24,  23,  23,  23,   // 170-17F
                                                    23,   23,   23,   23,   23,   23,   23,  23,  23,  23,  23,  23,  23,  22,  22,  22,   // 180-18F
                                                    22,   22,   22,   22,   22,   22,   22,  22,  22,  22,  22,  22,  22,  22,  22,  21,   // 190-19F
                                                    21,   21,   21,   21,   21,   21,   21,  21,  21,  21,  21,  21,  21,  21,  21,  21,   // 1A0-1AF
                                                    21,   21,   21,   20,   20,   20,   20,  20,  20,  20,  20,  20,  20,  20,  20,  20,   // 1B0-1BF
                                                    20,   20,   20,   20,   20,   20,   20,  20,  20,  19,  19,  19,  19,  19,  19,  19,   // 1C0-1CF
                                                    19,   19,   19,   19,   19,   19,   19,  19,  19,  19,  19,  19,  19,  19,  19,  19,   // 1D0-1DF
                                                    19,   19,   18,   18,   18,   18,   18,  18,  18,  18,  18,  18,  18,  18,  18,  18,   // 1E0-1EF
                                                    18,   18,   18,   18,   18,   18,   18,  18,  18,  18,  18,  18,  18,  17,  17,  17,   // 1F0-1FF
                                                    17,   17,   17,   17,   17,   17,   17,  17,  17,  17,  17,  17,  17,  17,  17,  17,   // 200-20F
                                                    17,   17,   17,   17,   17,   17,   17,  17,  17,  17,  17,  16,  16,  16,  16,  16,   // 210-21F
                                                    16,   16,   16,   16,   16,   16,   16,  16,  16,  16,  16,  16,  16,  16,  16,  16,   // 220-22F
                                                    16,   16,   16,   16,   16,   16,   16,  16,  16,  16,  16,  16,  16,  15,  15,  15,   // 230-23F
                                                    15,   15,   15,   15,   15,   15,   15,  15,  15,  15,  15,  15,  15,  15,  15,  15,   // 240-24F
                                                    15,   15,   15,   15,   15,   15,   15,  15,  15,  15,  15,  15,  15,  15,  15,  15,   // 250-25F
                                                    15,   15,   15,   14,   14,   14,   14,  14,  14,  14,  14,  14,  14,  14,  14,  14,   // 260-26F
                                                    14,   14,   14,   14,   14,   14,   14,  14,  14,  14,  14,  14,  14,  14,  14,  14,   // 270-27F
                                                    14,   14,   14,   14,   14,   14,   14,  14,  14,  14,  14,  14,  14,  14,  14,  13,   // 280-28F
                                                    13,   13,   13,   13,   13,   13,   13,  13,  13,  13,  13,  13,  13,  13,  13,  13,   // 290-29F
                                                    13,   13,   13,   13,   13,   13,   13,  13,  13,  13,  13,  13,  13,  13,  13,  13,   // 2A0-2AF
                                                    13,   13,   13,   13,   13,   13,   13,  13,  13,  13,  13,  13,  13,  13,  13,  13,   // 2B0-2BF
                                                    13,   12,   12,   12,   12,   12,   12,  12,  12,  12,  12,  12,  12,  12,  12,  12,   // 2C0-2CF
                                                    12,   12,   12,   12,   12,   12,   12,  12,  12,  12,  12,  12,  12,  12,  12,  12,   // 2D0-2DF
                                                    12,   12,   12,   12,   12,   12,   12,  12,  12,  12,  12,  12,  12,  12,  12,  12,   // 2E0-2EF
                                                    12,   12,   12,   12,   12,   12,   12,  12,  12,  12,  12,  12,  12,  11,  11,  11,   // 2F0-2FF
                                                    11,   11,   11,   11,   11,   11,   11,  11,  11,  11,  11,  11,  11,  11,  11,  11,   // 300-30F
                                                    11,   11,   11,   11,   11,   11,   11,  11,  11,  11,  11,  11,  11,  11,  11,  11,   // 310-31F
                                                    11,   11,   11,   11,   11,   11,   11,  11,  11,  11,  11,  11,  11,  11,  11,  11,   // 320-32F
                                                    11,   11,   11,   11,   11,   11,   11,  11,  11,  11,  11,  11,  11,  11,  11,  11,   // 330-33F
                                                    11,   11,   10,   10,   10,   10,   10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 340-34F
                                                    10,   10,   10,   10,   10,   10,   10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 350-35F
                                                    10,   10,   10,   10,   10,   10,   10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 360-36F
                                                    10,   10,   10,   10,   10,   10,   10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 370-37F
                                                    10,   10,   10,   10,   10,   10,   10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 380-38F
                                                    10,   10,   10,   10,   10,   10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 390-39F
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 3A0-3AF
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 3B0-3BF
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 3C0-3CF
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 3D0-3DF
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 3E0-3EF
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   8,   8,   8}};  // 3F0-3FF

  // 3722 / (i+4)--> is about (29 * 128) / (i+4)
  static constexpr std::array<int16_t, 0x400> _dtb{{930, 744, 620, 531, 465, 413, 372, 338, 310, 286, 265, 248, 232, 218, 206, 195,  // 000-00F
                                                    186, 177, 169, 161, 155, 148, 143, 137, 132, 128, 124, 120, 116, 112, 109, 106,  // 010-01F
                                                    103, 100, 97,  95,  93,  90,  88,  86,  84,  82,  80,  79,  77,  75,  74,  72,   // 020-02F
                                                    71,  70,  68,  67,  66,  65,  64,  63,  62,  61,  60,  59,  58,  57,  56,  55,   // 030-03F
                                                    54,  53,  53,  52,  51,  50,  50,  49,  48,  48,  47,  47,  46,  45,  45,  44,   // 040-04F
                                                    44,  43,  43,  42,  42,  41,  41,  40,  40,  40,  39,  39,  38,  38,  37,  37,   // 050-05F
                                                    37,  36,  36,  36,  35,  35,  35,  34,  34,  34,  33,  33,  33,  32,  32,  32,   // 060-06F
                                                    32,  31,  31,  31,  31,  30,  30,  30,  30,  29,  29,  29,  29,  28,  28,  28,   // 070-07F
                                                    28,  27,  27,  27,  27,  27,  26,  26,  26,  26,  26,  26,  25,  25,  25,  25,   // 080-08F
                                                    25,  24,  24,  24,  24,  24,  24,  24,  23,  23,  23,  23,  23,  23,  22,  22,   // 090-09F
                                                    22,  22,  22,  22,  22,  22,  21,  21,  21,  21,  21,  21,  21,  21,  20,  20,   // 0A0-0AF
                                                    20,  20,  20,  20,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  19,  19,   // 0B0-0BF
                                                    18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,   // 0C0-0CF
                                                    17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,   // 0D0-0DF
                                                    16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,   // 0E0-0EF
                                                    15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,   // 0F0-0FF
                                                    14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,   // 100-10F
                                                    13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,   // 110-11F
                                                    12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,   // 120-12F
                                                    12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,   // 130-13F
                                                    11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,   // 140-14F
                                                    10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 150-15F
                                                    10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 160-16F
                                                    10,  9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 170-17F
                                                    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 180-18F
                                                    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,    // 190-19F
                                                    8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,    // 1A0-1AF
                                                    8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,    // 1B0-1BF
                                                    8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,    // 1C0-1CF
                                                    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,    // 1D0-1DF
                                                    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,    // 1E0-1EF
                                                    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,    // 1F0-1FF
                                                    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,    // 200-20F
                                                    6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,    // 210-21F
                                                    6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,    // 220-22F
                                                    6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,    // 230-23F
                                                    6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,    // 240-24F
                                                    6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,    // 250-25F
                                                    6,   6,   6,   6,   6,   6,   6,   6,   6,   5,   5,   5,   5,   5,   5,   5,    // 260-26F
                                                    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,    // 270-27F
                                                    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,    // 280-28F
                                                    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,    // 290-29F
                                                    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,    // 2A0-2AF
                                                    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,    // 2B0-2BF
                                                    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,    // 2C0-2CF
                                                    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,    // 2D0-2DF
                                                    5,   5,   5,   5,   5,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 2E0-2EF
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 2F0-2FF
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 300-30F
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 310-31F
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 320-32F
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 330-33F
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 340-34F
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 350-35F
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 360-36F
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 370-37F
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,    // 380-38F
                                                    4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   3,    // 390-39F
                                                    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,    // 3A0-3AF
                                                    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,    // 3B0-3BF
                                                    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,    // 3C0-3CF
                                                    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,    // 3D0-3DF
                                                    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,    // 3E0-3EF
                                                    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3}};  // 3F0-3FF

  // 9238 / (i+4) --> is about (72 * 128) / (i+4)
  static constexpr std::array<int16_t, 0x400> _dtc{{2309, 1847, 1539, 1319, 1154, 1026, 923, 839, 769, 710, 659, 615, 577, 543, 513, 486,  // 000-00F
                                                    461,  439,  419,  401,  384,  369,  355, 342, 329, 318, 307, 298, 288, 279, 271, 263,  // 010-01F
                                                    256,  249,  243,  236,  230,  225,  219, 214, 209, 205, 200, 196, 192, 188, 184, 181,  // 020-02F
                                                    177,  174,  171,  167,  164,  162,  159, 156, 153, 151, 149, 146, 144, 142, 139, 137,  // 030-03F
                                                    135,  133,  131,  130,  128,  126,  124, 123, 121, 119, 118, 116, 115, 114, 112, 111,  // 040-04F
                                                    109,  108,  107,  106,  104,  103,  102, 101, 100, 99,  98,  97,  96,  95,  94,  93,   // 050-05F
                                                    92,   91,   90,   89,   88,   87,   87,  86,  85,  84,  83,  83,  82,  81,  81,  80,   // 060-06F
                                                    79,   78,   78,   77,   76,   76,   75,  75,  74,  73,  73,  72,  72,  71,  71,  70,   // 070-07F
                                                    69,   69,   68,   68,   67,   67,   66,  66,  65,  65,  65,  64,  64,  63,  63,  62,   // 080-08F
                                                    62,   62,   61,   61,   60,   60,   59,  59,  59,  58,  58,  58,  57,  57,  57,  56,   // 090-09F
                                                    56,   55,   55,   55,   54,   54,   54,  54,  53,  53,  53,  52,  52,  52,  51,  51,   // 0A0-0AF
                                                    51,   51,   50,   50,   50,   49,   49,  49,  49,  48,  48,  48,  48,  47,  47,  47,   // 0B0-0BF
                                                    47,   46,   46,   46,   46,   45,   45,  45,  45,  45,  44,  44,  44,  44,  43,  43,   // 0C0-0CF
                                                    43,   43,   43,   42,   42,   42,   42,  42,  41,  41,  41,  41,  41,  41,  40,  40,   // 0D0-0DF
                                                    40,   40,   40,   39,   39,   39,   39,  39,  39,  38,  38,  38,  38,  38,  38,  38,   // 0E0-0EF
                                                    37,   37,   37,   37,   37,   37,   36,  36,  36,  36,  36,  36,  36,  35,  35,  35,   // 0F0-0FF
                                                    35,   35,   35,   35,   34,   34,   34,  34,  34,  34,  34,  34,  33,  33,  33,  33,   // 100-10F
                                                    33,   33,   33,   33,   32,   32,   32,  32,  32,  32,  32,  32,  32,  31,  31,  31,   // 110-11F
                                                    31,   31,   31,   31,   31,   31,   31,  30,  30,  30,  30,  30,  30,  30,  30,  30,   // 120-12F
                                                    29,   29,   29,   29,   29,   29,   29,  29,  29,  29,  29,  28,  28,  28,  28,  28,   // 130-13F
                                                    28,   28,   28,   28,   28,   28,   27,  27,  27,  27,  27,  27,  27,  27,  27,  27,   // 140-14F
                                                    27,   27,   27,   26,   26,   26,   26,  26,  26,  26,  26,  26,  26,  26,  26,  26,   // 150-15F
                                                    25,   25,   25,   25,   25,   25,   25,  25,  25,  25,  25,  25,  25,  25,  24,  24,   // 160-16F
                                                    24,   24,   24,   24,   24,   24,   24,  24,  24,  24,  24,  24,  24,  23,  23,  23,   // 170-17F
                                                    23,   23,   23,   23,   23,   23,   23,  23,  23,  23,  23,  23,  23,  23,  22,  22,   // 180-18F
                                                    22,   22,   22,   22,   22,   22,   22,  22,  22,  22,  22,  22,  22,  22,  22,  22,   // 190-19F
                                                    21,   21,   21,   21,   21,   21,   21,  21,  21,  21,  21,  21,  21,  21,  21,  21,   // 1A0-1AF
                                                    21,   21,   21,   21,   20,   20,   20,  20,  20,  20,  20,  20,  20,  20,  20,  20,   // 1B0-1BF
                                                    20,   20,   20,   20,   20,   20,   20,  20,  20,  20,  19,  19,  19,  19,  19,  19,   // 1C0-1CF
                                                    19,   19,   19,   19,   19,   19,   19,  19,  19,  19,  19,  19,  19,  19,  19,  19,   // 1D0-1DF
                                                    19,   19,   19,   18,   18,   18,   18,  18,  18,  18,  18,  18,  18,  18,  18,  18,   // 1E0-1EF
                                                    18,   18,   18,   18,   18,   18,   18,  18,  18,  18,  18,  18,  18,  18,  17,  17,   // 1F0-1FF
                                                    17,   17,   17,   17,   17,   17,   17,  17,  17,  17,  17,  17,  17,  17,  17,  17,   // 200-20F
                                                    17,   17,   17,   17,   17,   17,   17,  17,  17,  17,  17,  17,  16,  16,  16,  16,   // 210-21F
                                                    16,   16,   16,   16,   16,   16,   16,  16,  16,  16,  16,  16,  16,  16,  16,  16,   // 220-22F
                                                    16,   16,   16,   16,   16,   16,   16,  16,  16,  16,  16,  16,  16,  16,  15,  15,   // 230-23F
                                                    15,   15,   15,   15,   15,   15,   15,  15,  15,  15,  15,  15,  15,  15,  15,  15,   // 240-24F
                                                    15,   15,   15,   15,   15,   15,   15,  15,  15,  15,  15,  15,  15,  15,  15,  15,   // 250-25F
                                                    15,   15,   15,   15,   14,   14,   14,  14,  14,  14,  14,  14,  14,  14,  14,  14,   // 260-26F
                                                    14,   14,   14,   14,   14,   14,   14,  14,  14,  14,  14,  14,  14,  14,  14,  14,   // 270-27F
                                                    14,   14,   14,   14,   14,   14,   14,  14,  14,  14,  14,  14,  14,  14,  14,  14,   // 280-28F
                                                    13,   13,   13,   13,   13,   13,   13,  13,  13,  13,  13,  13,  13,  13,  13,  13,   // 290-29F
                                                    13,   13,   13,   13,   13,   13,   13,  13,  13,  13,  13,  13,  13,  13,  13,  13,   // 2A0-2AF
                                                    13,   13,   13,   13,   13,   13,   13,  13,  13,  13,  13,  13,  13,  13,  13,  13,   // 2B0-2BF
                                                    13,   13,   13,   12,   12,   12,   12,  12,  12,  12,  12,  12,  12,  12,  12,  12,   // 2C0-2CF
                                                    12,   12,   12,   12,   12,   12,   12,  12,  12,  12,  12,  12,  12,  12,  12,  12,   // 2D0-2DF
                                                    12,   12,   12,   12,   12,   12,   12,  12,  12,  12,  12,  12,  12,  12,  12,  12,   // 2E0-2EF
                                                    12,   12,   12,   12,   12,   12,   12,  12,  12,  12,  12,  12,  12,  12,  11,  11,   // 2F0-2FF
                                                    11,   11,   11,   11,   11,   11,   11,  11,  11,  11,  11,  11,  11,  11,  11,  11,   // 300-30F
                                                    11,   11,   11,   11,   11,   11,   11,  11,  11,  11,  11,  11,  11,  11,  11,  11,   // 310-31F
                                                    11,   11,   11,   11,   11,   11,   11,  11,  11,  11,  11,  11,  11,  11,  11,  11,   // 320-32F
                                                    11,   11,   11,   11,   11,   11,   11,  11,  11,  11,  11,  11,  11,  11,  11,  11,   // 330-33F
                                                    11,   11,   11,   11,   10,   10,   10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 340-34F
                                                    10,   10,   10,   10,   10,   10,   10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 350-35F
                                                    10,   10,   10,   10,   10,   10,   10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 360-36F
                                                    10,   10,   10,   10,   10,   10,   10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 370-37F
                                                    10,   10,   10,   10,   10,   10,   10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   // 380-38F
                                                    10,   10,   10,   10,   10,   10,   10,  10,  9,   9,   9,   9,   9,   9,   9,   9,    // 390-39F
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 3A0-3AF
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 3B0-3BF
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 3C0-3CF
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 3D0-3DF
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,    // 3E0-3EF
                                                    9,    9,    9,    9,    9,    9,    9,   9,   9,   9,   9,   9,   9,   9,   9,   8}};  // 3F0-3FF

  union Map_t {
    struct {
      uint32_t count : 10;
      uint32_t prediction : 22;
    };
    uint32_t value;
  };
  static_assert(4 == sizeof(Map_t), "Alignment issue in Map_t");

  const uint64_t N;              // Number of contexts
  const uint32_t _mask;          // ctx limit
  uint32_t _ctx{0};              // Context of last prediction
  Map_t* const __restrict _map;  // ctx -> prediction
};
APM_t::~APM_t() noexcept {
  std::free(_map);
}

[[nodiscard]] static auto safe_add(const int32_t a, const int32_t b) noexcept -> int32_t {
  if (a >= 0) {
    if (b > (INT_MAX - a)) {
      return INT_MAX;  // handle overflow
    }
  } else {
    if (b < (INT_MIN - a)) {
      return INT_MIN;  // handle underflow
    }
  }
  return a + b;
}

/**
 * @class Mixer_t
 * Combines models using neural networks
 */
class Mixer_t final {
public:
  static constexpr uint32_t N_LAYERS{9};  // Number of neurons in the input layer

  static std::array<int16_t, N_LAYERS> tx_;

  Mixer_t() noexcept {
    tx_.fill(0);
    wx_.fill(0xA00);
  }

  ~Mixer_t() noexcept = default;

  Mixer_t(const Mixer_t&) = delete;
  Mixer_t(Mixer_t&&) = delete;
  auto operator=(const Mixer_t&) -> Mixer_t& = delete;
  auto operator=(Mixer_t&&) -> Mixer_t& = delete;

  void Update(const int32_t err) noexcept {  // train ...
    assert((err + 4096) < 8192);
    auto* const __restrict wx{&wx_[ctx_]};
    for (auto n{N_LAYERS}; n--;) {
      wx[n] += (((tx_[n] * err) >> 13) + 1) >> 1;
    }
  }

  [[nodiscard]] auto Predict() noexcept -> int16_t {  // dot product ...
    const auto* const __restrict wx{&wx_[ctx_]};
    auto sum{0};
    for (auto n{N_LAYERS}; n--;) {
      sum += wx[n] * tx_[n];
    }
    const auto pr{sum / (1 << dp_shift_)};
    return clamp12(pr);
  }

  void Context(uint32_t ctx) noexcept {
    ctx_ = ctx;
  }

  void ScaleUp() noexcept {
    for (size_t n{wx_.size()}; n--;) {
      wx_[n] = safe_add(wx_[n], wx_[n]);
    }
  }

private:
  uint32_t ctx_{0};
  int32_t : 32;  // Padding
  int32_t : 32;  // Padding
  int32_t : 32;  // Padding
  alignas(16) std::array<int32_t, N_LAYERS * 1280> wx_{};
};

alignas(16) std::array<int16_t, Mixer_t::N_LAYERS> Mixer_t::tx_;

/**
 * @class Blend_t
 * Combines predictions using a neural network
 */
template <const uint32_t N_LAYERS, const int32_t RATE>
class Blend_t final {
  static_assert(ISPOWEROF2(N_LAYERS), "Number of layers must be a power of two");
  static_assert(RATE > 0, "Rate must be a positive value which is larger then zero");

public:
  explicit Blend_t(const uint32_t n, const int16_t weight) noexcept
      : _mask{n - 1},  //
        _weights{static_cast<int16_t*>(std::calloc(n * N_LAYERS, sizeof(int16_t)))} {
    assert(ISPOWEROF2(n));
    assert((2 * N_LAYERS) < _pi.size());
    _pi.fill(0);
    if (verbose_) {
      fprintf(stdout, "%s for Blend_t\n", getDimension(n * N_LAYERS * sizeof(int16_t)).c_str());
    }
    for (auto i{n * N_LAYERS}; i--;) {
      _weights[i] = weight;
    }
  }

  virtual ~Blend_t() noexcept {
    std::free(_weights);
  }

  Blend_t() = delete;
  Blend_t(const Blend_t&) = delete;
  Blend_t(Blend_t&&) = delete;
  auto operator=(const Blend_t&) -> Blend_t& = delete;
  auto operator=(Blend_t&&) -> Blend_t& = delete;

  [[nodiscard]] auto Get() noexcept -> int16_t* {
    return _new;
  }

  [[nodiscard]] auto Predict(const int32_t err, const uint32_t ctx) noexcept -> int16_t {
    train(_prev, &_weights[_ctx], err);
    _ctx = (ctx & _mask) * N_LAYERS;
    const int32_t sum{dot_product(_new, &_weights[_ctx])};
    std::swap(_new, _prev);
    return static_cast<int16_t>(sum >> 14);
  }

private:
  const uint32_t _mask;                       // n-1
  uint32_t _ctx{0};                           // Context of last prediction
  int16_t* const __restrict _weights;         // Weights
  int32_t : 32;                               // Padding
  int32_t : 32;                               // Padding
  alignas(16) std::array<int16_t, 64> _pi{};  // Prediction inputs
  int16_t* __restrict _new{&_pi[0]};          // New Inputs (alternating between _pi[0] and _pi[32])
  int16_t* __restrict _prev{&_pi[32]};        // Previous Inputs (alternating between _pi[0] and _pi[32])

  ALWAYS_INLINE void train(const int16_t* const __restrict t, int16_t* const __restrict w, const int32_t err) noexcept {
    for (auto n{N_LAYERS}; n--;) {
      const int32_t wt{w[n] + ((((t[n] * err) >> RATE) + 1) >> 1)};
      w[n] = static_cast<int16_t>(std::clamp(wt, -32768, 32767));
    }
  }

  [[nodiscard]] ALWAYS_INLINE auto dot_product(const int16_t* const __restrict t, const int16_t* const __restrict w) noexcept -> int32_t {
    int32_t sum{0};
    for (auto n{N_LAYERS}; n--;) {
      sum += w[n] * t[n];
    }
    return sum;
  }
};

class HashTable_t final {
public:
  explicit HashTable_t(const uint64_t max_size) noexcept
      : N{(max_size > MEM_LIMIT) ? MEM_LIMIT : max_size},  //
        _hashtable{static_cast<Elements_t*>(calloc(N, sizeof(uint8_t)))},
        _mask{static_cast<uint32_t>((N / UINT64_C(4)) - 1)} {  // 4 is search limit
    assert(ISPOWEROF2(N));
    assert(_hashtable);
    if (verbose_) {
      fprintf(stdout, "%s for HashTable_t\n", getDimension(N).c_str());
    }
  }

  virtual ~HashTable_t() noexcept;

  HashTable_t(const HashTable_t&) = delete;
  HashTable_t(HashTable_t&&) = delete;
  auto operator=(const HashTable_t&) -> HashTable_t& = delete;
  auto operator=(HashTable_t&&) -> HashTable_t& = delete;

  // o --> 0,1,2,3,4,5,6,7
  [[nodiscard]] auto get1x(const uint32_t o, const uint32_t i) const noexcept -> uint8_t* {
    const auto chk{static_cast<uint8_t>(o | (i >> 27))};  // 3 + 5 bits
    const auto idx{i & _mask};

    // +-----+-----+-----+-----+
    // | chk | val | val | val | -1 (second)
    // +-----+-----+-----+-----+
    // | chk | val | val | val |  0 (first)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | +1 (second)
    // +-----+-----+-----+-----+

    auto* __restrict p{&_hashtable[idx]};  // first
    if (chk == p->checksum) {              // idx + 0 ?
      return p->count.data();
    }
    auto* const __restrict q{&_hashtable[idx ^ 1]};  // second
    if (chk == q->checksum) {                        // idx +/- 1 ?
      return q->count.data();
    }

    // clang-format off
    if (p->count[0] > q->count[0]) { p = q; }
    // clang-format on

    *p = Elements_t{.checksum = chk, .count{{0, 0, 0}}};
    return p->count.data();
  }

  // o --> 0,3,4,7
  [[nodiscard]] auto get3a(const uint32_t o, const uint32_t i) const noexcept -> uint8_t* {
    const auto chk{static_cast<uint8_t>(o | (i >> 27))};  // 3 + 5 bits
    const auto idx{i & _mask};

    // +-----+-----+-----+-----+
    // | chk | val | val | val | -3 (second)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | -2 (third)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | -1 (fourth)
    // +-----+-----+-----+-----+
    // | chk | val | val | val |  0 (first)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | +1 (fourth)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | +2 (third)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | +3 (second)
    // +-----+-----+-----+-----+

    auto* __restrict p{&_hashtable[idx]};  // first
    if (chk == p->checksum) {              // idx + 0 ?
      return p->count.data();
    }
    auto* const __restrict q{&_hashtable[idx ^ 3]};  // second
    if (chk == q->checksum) {                        // idx +/- 3 ?
      return q->count.data();
    }
    auto* const __restrict r{&_hashtable[idx ^ 2]};  // third
    if (chk == r->checksum) {                        // idx +/- 2 ?
      return r->count.data();
    }
    auto* const __restrict s{&_hashtable[idx ^ 1]};  // fourth
    if (chk == s->checksum) {                        // idx +/- 1 ?
      return s->count.data();
    }

    // clang-format off
    if (p->count[0] > q->count[0]) { p = q; }
    if (p->count[0] > r->count[0]) { p = r; }
    if (p->count[0] > s->count[0]) { p = s; }
    // clang-format on

    *p = Elements_t{.checksum = chk, .count{{0, 0, 0}}};
    return p->count.data();
  }

  // o --> 1,2,5,6
  [[nodiscard]] auto get3b(const uint32_t o, const uint32_t i) const noexcept -> uint8_t* {
    const auto chk{static_cast<uint8_t>(o | (i >> 27))};  // 3 + 5 bits
    const auto idx{i & _mask};

    // +-----+-----+-----+-----+
    // | chk | val | val | val | -3 (third)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | -2 (second)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | -1 (fourth)
    // +-----+-----+-----+-----+
    // | chk | val | val | val |  0 (first)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | +1 (fourth)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | +2 (second)
    // +-----+-----+-----+-----+
    // | chk | val | val | val | +3 (third)
    // +-----+-----+-----+-----+

    auto* __restrict p{&_hashtable[idx]};  // first
    if (chk == p->checksum) {              // idx + 0 ?
      return p->count.data();
    }
    auto* const __restrict q{&_hashtable[idx ^ 2]};  // second
    if (chk == q->checksum) {                        // idx +/- 2 ?
      return q->count.data();
    }
    auto* const __restrict r{&_hashtable[idx ^ 3]};  // third
    if (chk == r->checksum) {                        // idx +/- 3 ?
      return r->count.data();
    }
    auto* const __restrict s{&_hashtable[idx ^ 1]};  // fourth
    if (chk == s->checksum) {                        // idx +/- 1 ?
      return s->count.data();
    }

    // clang-format off
    if (p->count[0] > q->count[0]) { p = q; }
    if (p->count[0] > r->count[0]) { p = r; }
    if (p->count[0] > s->count[0]) { p = s; }
    // clang-format on

    *p = Elements_t{.checksum = chk, .count{{0, 0, 0}}};
    return p->count.data();
  }

private:
  static constexpr auto MEM_LIMIT{UINT64_C(0x400000000)};  // 16 GiB

  struct Elements_t final {
    uint8_t checksum;
    std::array<uint8_t, 3> count;
  };
  static_assert(0 == offsetof(Elements_t, checksum), "Alignment failure in HashTable_t::Elements_t");
  static_assert(1 == offsetof(Elements_t, count), "Alignment failure in HashTable_t::Elements_t");
  static_assert(4 == sizeof(Elements_t), "Alignment failure in HashTable_t::Elements_t");

  const uint64_t N;
  Elements_t* const __restrict _hashtable;
  const uint32_t _mask;
  int32_t : 32;  // Padding
};
HashTable_t::~HashTable_t() noexcept {
  std::free(_hashtable);
}

static std::array<uint8_t* __restrict, 5> cp_{{nullptr, nullptr, nullptr, nullptr, nullptr}};

// Some more arbitrary magic (prime) numbers
static constexpr auto MUL64_01{UINT64_C(0x993DDEFFB1462949)};
static constexpr auto MUL64_02{UINT64_C(0xE9C91DC159AB0D2D)};
// static constexpr auto MUL64_03{UINT64_C(0x83D6A14F1B0CED73)};
// static constexpr auto MUL64_04{UINT64_C(0xA14F1B0CED5A841F)};
// static constexpr auto MUL64_05{UINT64_C(0xC0E51314A614F4EF)};
// static constexpr auto MUL64_06{UINT64_C(0xDA9CC2600AE45A27)};
// static constexpr auto MUL64_07{UINT64_C(0x826797AA04A65737)};
// static constexpr auto MUL64_08{UINT64_C(0x2375BE54C41A08ED)};
// static constexpr auto MUL64_09{UINT64_C(0xD39104E950564B37)};
// static constexpr auto MUL64_10{UINT64_C(0x3091697D5E685623)};
// static constexpr auto MUL64_11{UINT64_C(0x20EB84EE04A3C7E1)};
// static constexpr auto MUL64_12{UINT64_C(0xF501F1D0944B2383)};
// static constexpr auto MUL64_13{UINT64_C(0xE3E4E8AA829AB9B5)};

[[nodiscard]] ALWAYS_INLINE static constexpr auto hash(const uint64_t x0) noexcept -> uint64_t {
  const uint64_t ctx{(x0 + 1) * Utilities::PHI64};
  return ((ctx << 32) | (ctx >> 32));
}

[[nodiscard]] ALWAYS_INLINE static constexpr auto hash(const uint64_t x0, const uint64_t x1) noexcept -> uint64_t {
  const uint64_t ctx{hash(x0) + ((x1 + 1) * MUL64_01)};
  return (ctx << 32) | (ctx >> 32);
}

[[nodiscard]] ALWAYS_INLINE static constexpr auto hash(const uint64_t x0, const uint64_t x1, const uint64_t x2) noexcept -> uint64_t {
  const uint64_t ctx{hash(x0, x1) + ((x2 + 1) * MUL64_02)};
  return (ctx << 32) | (ctx >> 32);
}

[[nodiscard]] ALWAYS_INLINE static constexpr auto combine64(const uint64_t seed, const uint64_t x) noexcept -> uint64_t {
  return hash(seed + x);
}

[[nodiscard]] ALWAYS_INLINE static constexpr auto finalise64(const uint64_t hash, const uint32_t hashbits) noexcept -> uint32_t {
  assert(hashbits <= 64);
  return static_cast<uint32_t>(hash >> (64 - hashbits));
}

template <const uint32_t SIZE, const int32_t RATE>
class StateMap_t final {
  static_assert(ISPOWEROF2(SIZE), "Size of state map must a power of two");
  static_assert(RATE >= 0, "Speed of state map must be positive");

public:
  StateMap_t() noexcept {
    _smt.fill(0x7FFF);  // No prediction
    if (verbose_) {
      fprintf(stdout, "%s for StateMap_t\n", getDimension(_smt.size() * sizeof(_smt[0])).c_str());
    }
  }
  virtual ~StateMap_t() noexcept = default;

  StateMap_t(const StateMap_t&) = delete;
  StateMap_t(StateMap_t&&) = delete;
  auto operator=(const StateMap_t&) -> StateMap_t& = delete;
  auto operator=(StateMap_t&&) -> StateMap_t& = delete;

  [[nodiscard]] constexpr auto operator[](const uint32_t i) noexcept -> uint16_t& {
    return _smt[i];
  }

  [[nodiscard]] auto Update(const bool bit, const uint32_t ctx) noexcept -> int16_t {
    uint16_t& balz{_smt[_ctx]};
    balz = static_cast<uint16_t>(bit ? (balz + (static_cast<uint16_t>(~balz) >> RATE)) : (balz - (balz >> RATE)));
    _ctx = ctx & (SIZE - 1);
    return Stretch(_smt[_ctx] / 16);  // Conversion from 0..4095 into -2048..2047
  }

  [[nodiscard]] auto Update(const bool bit, const uint32_t ctx, const int32_t rate) noexcept -> int16_t {
    uint16_t& balz{_smt[_ctx]};
    balz = static_cast<uint16_t>(bit ? (balz + (static_cast<uint16_t>(~balz) >> rate)) : (balz - (balz >> rate)));
    _ctx = ctx & (SIZE - 1);
    return Stretch(_smt[_ctx] / 16);  // Conversion from 0..4095 into -2048..2047
  }

private:
  uint32_t _ctx{0};  // Context of last prediction
  int32_t : 32;      // Padding
  alignas(16) std::array<uint16_t, SIZE> _smt{};
};

template <const uint32_t SIZE, const int32_t RATE0, const int32_t RATE1, const int32_t RATE2>
class ContextMap_t final {
  static_assert(ISPOWEROF2(SIZE), "Size of context map must a power of two");
  static_assert(RATE0 > 0, "Speed(s) of context map must be positive");
  static_assert(RATE1 > 0, "Speed(s) of context map must be positive");
  static_assert(RATE2 >= 0, "Speed(s) of context map must be positive (0 is switch off)");

public:
  explicit ContextMap_t() noexcept = default;
  virtual ~ContextMap_t() noexcept = default;

  ContextMap_t(const ContextMap_t&) = delete;
  ContextMap_t(ContextMap_t&&) = delete;
  auto operator=(const ContextMap_t&) -> ContextMap_t& = delete;
  auto operator=(ContextMap_t&&) -> ContextMap_t& = delete;

  void Set(const uint32_t ctx) noexcept {
    _ctx_new = ctx << 8;
  }

  auto Predict(const bool bit) noexcept -> std::array<int16_t, 3> {
    const auto& state_table{bit ? state_table_y1_ : state_table_y0_};

    uint8_t* const __restrict st{&_state[_ctx_last_prediction][0]};
    st[0] = state_table[0][st[0]];
    st[1] = state_table[1][st[1]];
    st[2] = state_table[2][st[2]];

    const auto ctx{(7 == bcount_) ? static_cast<uint32_t>(0xFF & cx_) : c0_};
    _ctx_last_prediction = (_ctx_new | ctx) & _mask;

    if constexpr (0 == RATE2) {
      return {{_sm0.Update(bit, _state[_ctx_last_prediction][0]),  //
               _sm1.Update(bit, _state[_ctx_last_prediction][1]),  //
               0}};
    } else {
      return {{_sm0.Update(bit, _state[_ctx_last_prediction][0]),  //
               _sm1.Update(bit, _state[_ctx_last_prediction][1]),  //
               _sm2.Update(bit, _state[_ctx_last_prediction][2])}};
    }
  }

private:
  std::array<std::array<uint8_t, 3>, (SIZE * 256)> _state{};
  int32_t : 32;                     // Padding
  int32_t : 32;                     // Padding
  StateMap_t<0x100, RATE0> _sm0{};  // State to prediction
  StateMap_t<0x100, RATE1> _sm1{};  // State to prediction
  StateMap_t<0x100, RATE2> _sm2{};  // State to prediction

  const uint32_t _mask{(SIZE * 256) - 1};
  uint32_t _ctx_new{0};
  uint32_t _ctx_last_prediction{0};
  int32_t : 32;  // Padding
};

/**
 * @class HashMap_t
 * HashMap_t maps a 32 bit hash to an array of 4 bytes (checksum and two byte values)
 *
 * HashMap_t{N}; creates N elements table with 4 bytes each.
 *   N must be a power of 2.
 *   The first 16 bits of each element is reserved for a checksum to detect collisions.
 *   The remaining bytes are values, prioritised by the first value (named count).
 *   This byte is 0 to mark an unused element.
 */
class HashMap_t final {
public:
  explicit HashMap_t(const uint32_t elements) noexcept
      : _hashmap{static_cast<Elements_t*>(calloc(elements + M, sizeof(Elements_t)))},  //
        _mask{elements - 1} {
    assert(ISPOWEROF2(elements));
    assert(_hashmap);
  }

  virtual ~HashMap_t() noexcept;

  HashMap_t(const HashMap_t&) = delete;
  HashMap_t(HashMap_t&&) = delete;
  auto operator=(const HashMap_t&) -> HashMap_t& = delete;
  auto operator=(HashMap_t&&) -> HashMap_t& = delete;

  struct Node_t final {
    uint8_t count;
    uint8_t value;
  };
  static_assert(0 == offsetof(Node_t, count), "Alignment failure in Node_t");
  static_assert(1 == offsetof(Node_t, value), "Alignment failure in Node_t");
  static_assert(2 == sizeof(Node_t), "Alignment failure in Node_t");

  /**
   * Returns a pointer to the i'th element,
   * such that bh[i].chk is a checksum of i,
   * bh[i].count used as priority and bh[i].value.
   * If a collision is detected,
   * up to M nearby locations in the same cache line are tested and
   * the first matching checksum or empty element is returned.
   * If no match or empty element is found,
   * then the lowest priority element is replaced.
   *
   * @param i Seek for the i'th element
   * @return Reference to count/value location (as byte)
   */
  [[nodiscard]] auto operator[](const uint32_t i) noexcept -> Node_t* {
    const auto checksum{static_cast<uint16_t>((i >> 16) ^ i)};
    const uint32_t index{(i * M) & _mask};
    Elements_t* const __restrict front{&_hashmap[index]};
    Elements_t* __restrict slot;
    uint32_t offset{0};
    do {
      slot = &front[offset];
      if (0 == slot->node.count) {  // priority/state byte is zero -> empty slot
        slot->checksum = checksum;  // occupy
        break;
      }
      if (slot->checksum == checksum) {
        break;  // found
      }
    } while (++offset < M);
    if (0 == offset) {
      return &slot->node;  // we are already at the front -> nothing to do
    }
    Elements_t store;
    if (offset == M) {  // element was not found
      store = Elements_t{.checksum = checksum, .node{.count = 0, .value = 0}};
      // candidate to overwrite is the last one (M - 1) or the one before that (M - 2)
      offset = (front[M - 1].node.count > front[M - 2].node.count) ? (M - 2) : (M - 1);
    } else {  // element was found or empty slot occupied
      store = *slot;
    }
    // move to front
    memmove(&front[1], front, offset * sizeof(Elements_t));
    *front = store;
    return &front->node;
  }

private:
  static constexpr auto M{UINT32_C(7)};  // search limit

  struct Elements_t final {
    uint16_t checksum;
    Node_t node;
  };
  static_assert(0 == offsetof(Elements_t, checksum), "Alignment failure in HashMap_t::Elements_t");
  static_assert(2 == offsetof(Elements_t, node), "Alignment failure in HashMap_t::Elements_t");
  static_assert(4 == sizeof(Elements_t), "Alignment failure in HashMap_t::Elements_t");

  Elements_t* const __restrict _hashmap;
  const uint32_t _mask;
  int32_t : 32;  // Padding
};
HashMap_t::~HashMap_t() noexcept {
  std::free(_hashmap);
}

template <const int32_t SCALE>
class RunContextMap_t final {
public:
  explicit RunContextMap_t(const int32_t max_size) noexcept
      : _hashmap{UINT32_C(1) << max_size},  //
        _cp{_hashmap[0]} {}
  virtual ~RunContextMap_t() noexcept = default;

  RunContextMap_t() = delete;
  RunContextMap_t(const RunContextMap_t&) = delete;
  RunContextMap_t(RunContextMap_t&&) = delete;
  auto operator=(const RunContextMap_t&) -> RunContextMap_t& = delete;
  auto operator=(RunContextMap_t&&) -> RunContextMap_t& = delete;

  void Set(const uint32_t cx) noexcept {  // update count
    if (const auto expected_byte{static_cast<uint8_t>(cx_)}; (0 == _cp->count) || (expected_byte != _cp->value)) {
      *_cp = HashMap_t::Node_t{.count = 1, .value = expected_byte};  // Reset count, set expected byte
    } else if (_cp->count < 255) {
      ++_cp->count;
    }
    _cp = _hashmap[cx];
  }

  [[nodiscard]] auto Predict() noexcept -> int16_t {  // predict next bit
    if (const uint8_t expected_byte{_cp->value}; (expected_byte | 0x100u) >> (1 + bcount_) == c0_) {
      const int32_t expected_bit{1 & (expected_byte >> bcount_)};
      return static_cast<int16_t>(((expected_bit * 2) - 1) * ilog[_cp->count] * SCALE);
    }
    return 0;  // No or misprediction
  }

private:
  static constexpr std::array<uint8_t, 256> ilog{{0,   16,  25,  32,  37,  41,  45,  48,  51,  53,  55,  57,  59,  61,  63,  64,     //   0- 15
                                                  65,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  79,  80,     //  16- 31
                                                  81,  81,  82,  83,  83,  84,  85,  85,  86,  86,  87,  87,  88,  88,  89,  89,     //  32- 47
                                                  90,  90,  91,  91,  92,  92,  93,  93,  93,  94,  94,  95,  95,  95,  96,  96,     //  48- 63
                                                  96,  97,  97,  97,  98,  98,  98,  99,  99,  99,  100, 100, 100, 101, 101, 101,    //  64- 79
                                                  101, 102, 102, 102, 103, 103, 103, 103, 104, 104, 104, 104, 105, 105, 105, 105,    //  80- 95
                                                  106, 106, 106, 106, 107, 107, 107, 107, 107, 108, 108, 108, 108, 109, 109, 109,    //  96-111
                                                  109, 109, 110, 110, 110, 110, 110, 111, 111, 111, 111, 111, 111, 112, 112, 112,    // 112-127
                                                  112, 112, 113, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114, 114, 115, 115,    // 128-143
                                                  115, 115, 115, 115, 116, 116, 116, 116, 116, 116, 116, 117, 117, 117, 117, 117,    // 144-159
                                                  117, 117, 118, 118, 118, 118, 118, 118, 118, 119, 119, 119, 119, 119, 119, 119,    // 160-175
                                                  119, 120, 120, 120, 120, 120, 120, 120, 121, 121, 121, 121, 121, 121, 121, 121,    // 176-191
                                                  121, 122, 122, 122, 122, 122, 122, 122, 122, 123, 123, 123, 123, 123, 123, 123,    // 192-207
                                                  123, 123, 124, 124, 124, 124, 124, 124, 124, 124, 124, 125, 125, 125, 125, 125,    // 208-223
                                                  125, 125, 125, 125, 125, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 127,    // 224-239
                                                  127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 128, 128, 128, 128, 128, 128}};  // 240-255
  HashMap_t _hashmap;
  HashMap_t::Node_t* __restrict _cp;
};

class DynamicMarkovModel_t final {
public:
  explicit DynamicMarkovModel_t(const uint64_t max_size) noexcept
      : _max_size_bytes{(max_size > MEM_LIMIT) ? MEM_LIMIT : max_size},
        _max_nodes{static_cast<uint32_t>((_max_size_bytes / sizeof(Node)) - 1)},
        _nodes{reinterpret_cast<Node*>(std::calloc(_max_size_bytes + sizeof(Node), sizeof(int8_t)))} {
    assert(0 == (_max_nodes >> 28));  // the top 4 bits must be unused by nx0 and nx1 for storing the 4+4 bits of the bit history state byte
    if (verbose_) {
      fprintf(stdout, "%s for DMC_t\n", getDimension(_max_size_bytes + sizeof(Node)).c_str());
    }
    Flush();
  }
  ~DynamicMarkovModel_t() noexcept;
  DynamicMarkovModel_t() = delete;
  DynamicMarkovModel_t(const DynamicMarkovModel_t&) = delete;
  DynamicMarkovModel_t(DynamicMarkovModel_t&&) = delete;
  auto operator=(const DynamicMarkovModel_t&) -> DynamicMarkovModel_t& = delete;
  auto operator=(DynamicMarkovModel_t&&) -> DynamicMarkovModel_t& = delete;

  void Update() noexcept {
    _cm.Set(tt_);
  }

  // Adaptively increment a counter
  template <typename T>
  [[nodiscard]] ALWAYS_INLINE constexpr auto increment_counter(const T x, const T increment) const noexcept -> T {
    constexpr uint16_t RATE{6};
    return T((((x << RATE) - x) >> RATE) + (increment << (16 - RATE)));
  }

  void Predict(const bool bit) noexcept {
    Node& curr{_nodes[_curr]};

    const auto n{curr.count[bit]};

    if (bit) {
      curr.count[0] = increment_counter(curr.count[0], ZERO);
      curr.count[1] = increment_counter(curr.count[1], ONE);

      curr.state = state_table_y1_[0][curr.state];
    } else {
      curr.count[0] = increment_counter(curr.count[0], ONE);
      curr.count[1] = increment_counter(curr.count[1], ZERO);

      curr.state = state_table_y0_[0][curr.state];
    }

    if (n > _threshold) {
      const auto next{static_cast<uint32_t>(bit ? curr.nx1 : curr.nx0)};
      int32_t n0{_nodes[next].count[0]};
      int32_t n1{_nodes[next].count[1]};

      if (const auto nn{static_cast<uint32_t>(n0 + n1)}; nn > (n + _threshold)) {
        const auto top_count0{MulDiv(static_cast<uint32_t>(n0), n, nn)};  // 16+16-16
        assert(n0 >= top_count0);

        const auto top_count1{MulDiv(static_cast<uint32_t>(n1), n, nn)};
        assert(n1 >= top_count1);

        n0 -= top_count0;
        n1 -= top_count1;

        assert((n0 + n1) > 0);

        _nodes[_top].count[0] = top_count0;
        _nodes[_top].count[1] = top_count1;

        _nodes[next].count[0] = static_cast<uint16_t>(n0);
        _nodes[next].count[1] = static_cast<uint16_t>(n1);

        _nodes[_top].all = _nodes[next].all;  // Clone nx0,nx1 and state

        if (bit) {
          curr.nx1 = MASK_28_BITS & _top;
        } else {
          curr.nx0 = MASK_28_BITS & _top;
        }

        if (++_top > _max_nodes) {
          Flush();
        }

        if (_threshold < (47 * 256)) {  // Threshold of 47 is based on enwik9
          _threshold = ++_threshold_fine >> 11;
        }
      }
    }

    _curr = static_cast<uint32_t>(bit ? curr.nx1 : curr.nx0);

    auto* const __restrict pr{_blend.Get()};
    pr[0] = Predict();  // DMC prediction -2048..2047
    pr[1] = _sm2.Update(bit, _nodes[_curr].state);

    // Little improvements of DMC predictions
    pr[2] = _sm3.Update(bit, (tt_ << 8) | c0_);
    pr[3] = _sm4.Update(bit, (finalise64(word_, 32) << 8) | c0_);
    pr[4] = _sm5.Update(bit, (x5_ << 8) | c0_);

    const auto pm{_cm.Predict(bit)};
    pr[5] = pm[0];
    pr[6] = pm[1];
    pr[7] = pm[2];

    const auto last_pr{Squash(Mixer_t::tx_[7])};  // Conversion from -2048..2047 (clamped) into 0..4095
    const auto ctx{(w5_ << 3) | bcount_};
    const int32_t err{((bit << 12) - last_pr) * 14};
    const auto px{_blend.Predict(err, ctx)};
    Mixer_t::tx_[7] = clamp12(px);
  }

private:
  [[nodiscard]] auto Predict() const noexcept -> int16_t {
    const auto n0{_nodes[_curr].count[0]};
    if (!n0) {
      return 0x7FF;
    }
    const auto n1{_nodes[_curr].count[1]};
    if (!n1) {
      return ~0x7FF;
    }
    const auto pr{MulDiv(0xFFF, n1, n0 + n1)};  // (0xFFF * n1) / (n0 + n1)
    return Stretch(pr);                         // Conversion from 0..4095 into -2048..2047
  }

  struct Node {
#pragma pack(push, 1)
    union {
      uint64_t all;
      struct {
        uint64_t nx0 : 28;
        uint64_t nx1 : 28;
        uint64_t state : 8;
      };
    };
#pragma pack(pop)
    std::array<uint16_t, 2> count;
  };
  static_assert(0 == offsetof(Node, all), "Alignment failure in DMC node");
  static_assert(8 == offsetof(Node, count), "Alignment failure in DMC node");
  static_assert(12 == sizeof(Node), "Alignment failure in DMC node");

  static constexpr auto MEM_LIMIT{(UINT64_C(1) << 28) * sizeof(Node)};  // 3 GiB
  static constexpr auto MASK_28_BITS{(UINT32_C(1) << 28) - 1};

  static constexpr uint32_t INIT_COUNT{509};  // Initial value of counter, preferably a prime number
  static constexpr uint32_t THRESHOLD{1205};  // Threshold of when to clone (based on enwik9 with INIT_COUNT=509)

  static constexpr uint16_t ZERO{0};
  static constexpr uint16_t ONE{1};

  /**
   * '(x * y) / z' with rounding
   * @param x Input 'x'
   * @param y Input 'y'
   * @param z Input 'z' can not be zero
   * @return (x * y) / z
   */
  [[nodiscard]] ALWAYS_INLINE constexpr auto MulDiv(const uint32_t x, const uint32_t y, const uint32_t z) const noexcept -> uint16_t {
    assert(z > 0);
    return static_cast<uint16_t>(((2 * x * y) + z) / (2 * z));
  }

  void Flush() noexcept {
    _threshold = THRESHOLD;
    _threshold_fine = THRESHOLD << 11;
    _top = 0;
    _curr = 0;
    for (uint32_t j{0}; j < 256; ++j) {                                 // 256 trees
      for (uint32_t i{0}; i < 255; ++i) {                               // 255 nodes in each tree
        if (i < 127) {                                                  // Internal tree nodes
          _nodes[_top].nx0 = MASK_28_BITS & (_top + i + 1);             // Left node
          _nodes[_top].nx1 = MASK_28_BITS & (_top + i + 2);             // Right node
        } else {                                                        // 128 leaf nodes - they each references a root node of tree(i)
          const uint32_t linked_tree_root{(i - 127) * 2 * 255};         //
          _nodes[_top].nx0 = MASK_28_BITS & linked_tree_root;           // Left node -> root of tree 0,2,4,...
          _nodes[_top].nx1 = MASK_28_BITS & (linked_tree_root + 255u);  // Right node -> root of tree 1,3,5,...
        }
        _nodes[_top].state = 0;
        _nodes[_top].count[0] = INIT_COUNT;
        _nodes[_top].count[1] = INIT_COUNT;
        _top++;
      }
    }
  }

  const uint64_t _max_size_bytes;
  const uint32_t _max_nodes;
  uint32_t _top{0};
  Node* const __restrict _nodes;
  uint32_t _curr{0};
  uint32_t _threshold{0};
  uint32_t _threshold_fine{0};
  int32_t : 32;                                   // Padding
  int32_t : 32;                                   // Padding
  int32_t : 32;                                   // Padding
  StateMap_t<0x100, 6> _sm2{};                    // state   | Rate of 6 is based on enwik9
  StateMap_t<0x4000, 1> _sm3{};                   // tt_     | Rate of 1 is based on enwik9         | not part of DynamicMarkovModel, just an improvement
  StateMap_t<0x10000, 1> _sm4{};                  // word_   | Rate of 1 is based on enwik9         | not part of DynamicMarkovModel, just an improvement
  StateMap_t<0x40000, 2> _sm5{};                  // x5_     | Rate of 2 is based on enwik9         | not part of DynamicMarkovModel, just an improvement
  ContextMap_t<0x4000, 0xE, 0xD, 0x7> _cm{};      // tt_|c0_ | Rate of 14/13/ 7 are based on enwik9 | not part of DynamicMarkovModel, just an improvement
  Blend_t<8, 16> _blend{UINT32_C(1) << 19, 512};  // w5_     | Rate of 16 is based on enwik9
};
DynamicMarkovModel_t::~DynamicMarkovModel_t() noexcept {
  std::free(_nodes);
}

class LempelZivPredict_t final {  // MatchModel
public:
  explicit LempelZivPredict_t(const Buffer_t& __restrict buf, const uint64_t max_size) noexcept
      : _buf{buf},  //
        _hashbits{countbits(((max_size > MEM_LIMIT) ? MEM_LIMIT : max_size) - UINT64_C(1))},
        _ht{static_cast<uint32_t*>(std::calloc((UINT64_C(1) << _hashbits) + UINT64_C(1), sizeof(uint32_t)))} {
    assert(ISPOWEROF2(max_size));
    if (verbose_) {
      fprintf(stdout, "%s for LZP_t\n", getDimension(((UINT64_C(1) << _hashbits) + UINT64_C(1)) * sizeof(uint32_t)).c_str());
    }
  }

  virtual ~LempelZivPredict_t() noexcept;

  LempelZivPredict_t() = delete;
  LempelZivPredict_t(const LempelZivPredict_t&) = delete;
  LempelZivPredict_t(LempelZivPredict_t&&) = delete;
  auto operator=(const LempelZivPredict_t&) -> LempelZivPredict_t& = delete;
  auto operator=(LempelZivPredict_t&&) -> LempelZivPredict_t& = delete;

  void Update() noexcept {
    uint64_t h{0};
    for (auto n{MINLEN + 2}; n--;) {
      h = combine64(h, _buf(n + 1));
    }
    const auto idx{finalise64(h, _hashbits)};

    if (_match_length >= MINLEN) {
      _match_length += _match_length < MAXLEN;
      ++_match;
    } else {
      _match_length = 0;
      _match = _ht[idx];
      if (_match) {
        while ((_match_length < MAXLEN) && (_buf(_match_length + 1) == _buf[_match - _match_length - 1])) {
          ++_match_length;
        }
      }
    }
    _ht[idx] = _buf.Pos();

    _expected_byte = _buf[_match];

    _rc0.Set((_match_length << 8) | c1_);  // 6+8 bits
    _rc1.Set(w5_);
    _rc2.Set(x5_);
    _rc3.Set(tt_);
    _rc4.Set(finalise64(word_, 32));
  }

  [[nodiscard]] auto Predict(const bool bit) noexcept -> uint32_t {
    auto* const __restrict pr{_blend.Get()};

    uint32_t ctx0{0};
    uint32_t order;

    if ((_match_length >= MINLEN) && (((_expected_byte | 0x100) >> (1 + bcount_)) == c0_)) {
      const auto length{_match_length - MINLEN};
      const auto expected_bit{UINT32_C(1) & (_expected_byte >> bcount_)};

      const auto sign{static_cast<int32_t>(2 * expected_bit) - 1};
      pr[0] = static_cast<int16_t>(sign * static_cast<int32_t>(length) * 32);

      if (length > 0) {
        if (length <= 16) {
          ctx0 = (2 * (length - 1)) + expected_bit;  // 0..31
        } else {
          ctx0 = 24 + (2 * ((length - 1) / 4)) + expected_bit;  // 32..55
        }
      }

      const auto ctx1{(length << 9) | (expected_bit << 8) | c1_};  // 6+1+8=15 bits
      pr[1] = _ltp0.Update(bit, ctx1);

      // Length to order, based on enwik9 (value must start with 9 and end with 4)
      const auto l2o{(7 == bcount_) ? UINT64_C(0x9999988888776654) : UINT64_C(0x9999998888776654)};
      order = static_cast<uint32_t>(0xF & (l2o >> (4 * (length / 4))));
    } else {
      _match_length = 0;  // Misprediction, reset!
      pr[0] = 0;
      pr[1] = _ltp0.Update(bit, c0_, 2) / 2;  // Rate of 2 is based on enwik9

      order = 0;
      if (*cp_[1]) {
        order = 1;
        if (*cp_[2]) {
          order = 2;
          if (*cp_[3]) {
            order = 3;
          }
        }
      }
    }

    const auto py{_ltp1.Update(bit, (ctx0 << 8) | c0_)};  // 6+8=14 bits
    pr[2] = ctx0 ? py : 0;
    pr[3] = _rc0.Predict();
    pr[4] = _rc1.Predict();
    pr[5] = _rc2.Predict();
    pr[6] = _rc3.Predict();
    pr[7] = _rc4.Predict();

    const auto last_pr{Squash(Mixer_t::tx_[0])};  // Conversion from -2048..2047 (clamped) into 0..4095
    const auto ctx{(w5_ << 3) | bcount_};
    const int32_t err{((bit << 12) - last_pr) * 14};
    const auto px{_blend.Predict(err, ctx)};
    Mixer_t::tx_[0] = clamp12(px);

    return order;
  }

private:
  static constexpr uint32_t MINLEN{7};                     // Minimum required match length
  static constexpr uint32_t MAXLEN{MINLEN + 63};           // Longest allowed match (max 6 bits, after subtraction of minimum length)
  static constexpr auto MEM_LIMIT{UINT64_C(0x100000000)};  // 4 GiB

  [[nodiscard]] auto countbits(uint64_t x) const noexcept -> uint32_t {
    uint32_t n{0};
    while (x) {
      ++n;
      x >>= 1;
    }
    return n;
  }

  const Buffer_t& __restrict _buf;
  const uint32_t _hashbits;
  int32_t : 32;  // Padding
  uint32_t* const __restrict _ht;
  uint32_t _match{0};
  uint32_t _match_length{0};
  uint32_t _expected_byte{0};
  int32_t : 32;                           // Padding
  StateMap_t<0x8000, 5> _ltp0{};          // Length to prediction          | Rate of 5 is based on enwik9
  StateMap_t<0x4000, 8> _ltp1{};          // (curved) Length to prediction | Rate of 8 is based on enwik9
  RunContextMap_t<16> _rc0{14};           // match_length | c1_            |
  RunContextMap_t<20> _rc1{16 + level_};  // w5_                           | not part of LempelZivPredict, just an improvement
  RunContextMap_t<20> _rc2{16 + level_};  // x5_                           | not part of LempelZivPredict, just an improvement
  RunContextMap_t<20> _rc3{16 + level_};  // tt_                           | not part of LempelZivPredict, just an improvement
  RunContextMap_t<20> _rc4{16 + level_};  // word_                         | not part of LempelZivPredict, just an improvement
  int32_t : 32;                           // Padding
  int32_t : 32;                           // Padding
  Blend_t<8, 16> _blend{1u << 19, 4096};  // w5_                           | Rate of 16 is based on enwik9
};
LempelZivPredict_t::~LempelZivPredict_t() noexcept {
  std::free(_ht);
}

class SparseMatchModel_t final {
public:
  explicit SparseMatchModel_t(const Buffer_t& __restrict buf) noexcept
      : _buf{buf},  //
        _ht{static_cast<uint32_t*>(std::calloc((UINT64_C(1) << NBITS) + UINT64_C(1), sizeof(uint32_t)))} {
    if (verbose_) {
      fprintf(stdout, "%s for SparseMatchModel_t\n", getDimension(((UINT64_C(1) << NBITS) + UINT64_C(1)) * sizeof(uint32_t)).c_str());
    }
  }
  virtual ~SparseMatchModel_t() noexcept;

  SparseMatchModel_t() = delete;
  SparseMatchModel_t(const SparseMatchModel_t&) = delete;
  SparseMatchModel_t(SparseMatchModel_t&&) = delete;
  auto operator=(const SparseMatchModel_t&) -> SparseMatchModel_t& = delete;
  auto operator=(SparseMatchModel_t&&) -> SparseMatchModel_t& = delete;

  void Update() noexcept {
    const auto idx{((UINT64_C(1) << NBITS) - 1) & cx_};

    if (_match_length >= MINLEN) {
      _match_length += _match_length < MAXLEN;
      ++_match;
    } else {
      _match_length = 0;
      _match = _ht[idx];
      if (_match) {
        while ((_match_length < MAXLEN) && (_buf(_match_length + 1) == _buf[_match - _match_length - 1])) {
          ++_match_length;
        }
      }
    }
    _ht[idx] = _buf.Pos();

    _expected_byte = _buf[_match];

    _cm0.Set(0);
    _cm1.Set(x5_);
  }

  void Predict(const bool bit) noexcept {
    auto* const __restrict pr{_blend.Get()};

    if ((_match_length >= MINLEN) && (((_expected_byte | 0x100) >> (1 + bcount_)) == c0_)) {
      const auto expected_bit{UINT32_C(1) & (_expected_byte >> bcount_)};

      const auto sign{static_cast<int32_t>(2 * expected_bit) - 1};
      pr[0x0] = static_cast<int16_t>(sign * static_cast<int32_t>(_match_length) * 32);

      const auto ctx0{(_match_length << 9) | (expected_bit << 8) | c1_};  // 6+1+8=15 bits
      pr[0x1] = _ltp.Update(bit, ctx0);

      const auto ctx1{(_expected_byte << 11) | (bcount_ << 8) | _buf(1)};  // 8+3+8=19 bits
      pr[0x2] = _sm1.Update(bit, ctx1);
    } else {
      _match_length = 0;  // Misprediction, reset!
      pr[0] = 0;
      pr[1] = _ltp.Update(bit, c1_) / 4;
      pr[2] = _sm1.Update(bit, _buf(1), 4) / 8;  // Rate of 4, division of 8 are based on enwik9
    }

    const auto pm0{_cm0.Predict(bit)};
    pr[3] = pm0[0];
    pr[4] = pm0[1];
    pr[5] = pm0[2];

    const auto pm1{_cm1.Predict(bit)};
    pr[6] = pm1[0];
    pr[7] = pm1[1];
#if 0  // Disabled, to have length of 8 for blend
    pr[8] = pm1[2];
#endif

    const auto last_pr{Squash(Mixer_t::tx_[8])};  // Conversion from -2048..2047 (clamped) into 0..4095
    const auto ctx{(w5_ << 3) | bcount_};
    const int32_t err{((bit << 12) - last_pr) * 9};
    const auto px{_blend.Predict(err, ctx)};
    Mixer_t::tx_[8] = clamp12(px);
  }

private:
  static constexpr uint32_t NBITS{15};            // Size of look-up table (< 32) default 15 based on enwik9
  static constexpr uint32_t MINLEN{2};            // Minimum required match length
  static constexpr uint32_t MAXLEN{MINLEN + 63};  // Longest allowed match (max 6 bits, after subtraction of minimum length)

  const Buffer_t& __restrict _buf;
  uint32_t* const __restrict _ht;
  uint32_t _match{0};
  uint32_t _match_length{0};
  uint32_t _expected_byte{0};
  int32_t : 32;                                    // Padding
  int32_t : 32;                                    // Padding
  int32_t : 32;                                    // Padding
  ContextMap_t<0x001, 0xC, 0xA, 0xD> _cm0{};       //     c0_                     | Rate of 12/10/13 are based on enwik9 | not part of SparseMatchModel, just an improvement
  ContextMap_t<0x100, 0xC, 0x6, 0> _cm1{};         // x5_|c0_                     | Rate of 12/ 6/14 are based on enwik9 | not part of SparseMatchModel, just an improvement
  StateMap_t<0x8000, 5> _ltp{};                    // length|expected_bit|c1      | Rate of 5 is based on enwik9
  StateMap_t<0x80000, 9> _sm1{};                   // expected_byte|bcount|buf(1) | Rate of 9 is based on enwik9
  Blend_t<8, 16> _blend{UINT32_C(1) << 19, 4096};  // w5_                         | Rate of 17 is based on enwik9
};
SparseMatchModel_t::~SparseMatchModel_t() noexcept {
  std::free(_ht);
}

/**
 * @class Txt_t
 * This is not really a prediction model. It is more of a state machine that
 * can follow the sequence of text or value preparation.
 * If the text preparation fails or is ineffective, this model does nothing.
 * If the text preparation is successful, it can follow the byte order of the
 * text preparation. It can predict single bits with 100% accuracy.
 * When a debug version is created, this accuracy is tested by means of an assert.
 * Therefore the function 'Predict' has a parameter 'bit',
 * normally (release build) it is not used.
 * This model is not "super" effective, but does not claim memory or heavy CPU usage.
 * If the model is active, it predicts a few bits (2,5 or 10), in line with text preparation,
 * and it predicts a few bits (6,8,10,12,14,16,18,20 and 22), in line with value preparation.
 */
class Txt_t final {
public:
  explicit Txt_t() noexcept = default;
  ~Txt_t() noexcept = default;

  Txt_t(const Txt_t&) = delete;
  Txt_t(Txt_t&&) = delete;
  auto operator=(const Txt_t&) -> Txt_t& = delete;
  auto operator=(Txt_t&&) -> Txt_t& = delete;

  /**
   * Skip a few bytes till the text-preparation sequence starts.
   */
  void Update() noexcept {
    if (_skip_bytes > 0) {
      --_skip_bytes;
    }
  }

  /**
   * Forecast a few bits with 100% accuracy
   * @param bit List bit seen
   * @return True when there is a forecast otherwise false
   */
  [[nodiscard]] auto Predict(const bool bit) noexcept -> std::pair<bool, uint16_t> {
    //    (No prediction) || (          1 predicted) || (           0 predicted)
    assert((0x7FF == _pr) || (bit && (0xFFF == _pr)) || (!bit && (0x000 == _pr)));
    (void)bit;  // bit is only used for verification

    if (!_start || (_skip_bytes > 0)) {
      return {false, _pr = 0x7FF};  // No prediction
    }

    if (_value) {
      Shift();

      const bool has_value{(_value >> 127) ? true : false};
      if (has_value) {
        const bool prediction{(_prdct >> 127) ? true : false};
        return {true, _pr = prediction ? 0xFFF : 0x000};  // Prediction
      }
    } else {
      // Detect dictionary indexes
      if ((3 == bcount_) && (ESCAPE_CHAR != (0xFF & cx_)) && (0xC == (0xC & c0_))) {
        if (0xC == (0xE & c0_)) {
          // < MID
          //         C0      80 --> 2 bits prediction
          //       0b110xxxxx10xxxxxx
          _prdct = 0b11000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
          _value = 0b00000000110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
          //         ^^^     pp
          //
        } else if (0xE == (0xF & c0_)) {
          // < HIGH
          //         E0      C0      80 --> 5 bits prediction
          //       0b1110xxxx110xxxxx10xxxxxx
          _prdct = 0b11100000110000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
          _value = 0b00000000111000001100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
          //         ^^^^    ppp     pp
          //
        } else if (0xF == (0xF & c0_)) {
          // >= HIGH
          //         F0      E0      C0      80 --> 10 bits prediction
          //       0b11110xxx1110xxxx110xxxxx10xxxxxx
          _prdct = 0b11110000111000001100000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
          _value = 0b00001000111100001110000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
          //         ^^^^p   pppp    ppp     pp
          //
        }

        Shift();  // Get in sync
        Shift();
        Shift();
        Shift();
      }

      // Detect value transformation <escape><0xFx><0x8x>...<0x0x>
      if ((5 == bcount_) && (ESCAPE_CHAR == (0xFF & (cx_ >> 8))) && (0xF0 == (0xF0 & cx_)) && (0x06 == c0_)) {
        const auto costs{0x0F & cx_};
        // clang-format off
        switch (costs) {
          case 0x4: // 80      80      80      00 --> 6 bits prediction
            //       0b10xxxxxx10xxxxxx10xxxxxx00xxxxxx
            _prdct = 0b10000000100000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            _value = 0b11000000110000001100000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            break;  // ^^      pp      pp      pp

          case 0x5: // 80      80      80      80      00 --> 8 bits prediction
            //       0b10xxxxxx10xxxxxx10xxxxxx10xxxxxx00xxxxxx
            _prdct = 0b10000000100000001000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            _value = 0b11000000110000001100000011000000110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            break;  // ^^      pp      pp      pp      pp

          case 0x6: // 80      80      80      80      80      00 --> 10 bits prediction
            //       0b10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx00xxxxxx
            _prdct = 0b10000000100000001000000010000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            _value = 0b11000000110000001100000011000000110000001100000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            break;  // ^^      pp      pp      pp      pp      pp

          case 0x7: // 80      80      80      80      80      80      00 --> 12 bits prediction
            //       0b10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx00xxxxxx
            _prdct = 0b10000000100000001000000010000000100000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            _value = 0b11000000110000001100000011000000110000001100000011000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            break;  // ^^      pp      pp      pp      pp      pp      pp

          case 0x8: // 80      80      80      80      80      80      80      00 --> 14 bits prediction
            //       0b10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx00xxxxxx
            _prdct = 0b10000000100000001000000010000000100000001000000010000000000000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            _value = 0b11000000110000001100000011000000110000001100000011000000110000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            break;  // ^^      pp      pp      pp      pp      pp      pp      pp

          case 0x9: // 80      80      80      80      80      80      80      80      00 --> 16 bits prediction
            //       0b10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx00xxxxxx
            _prdct = 0b10000000100000001000000010000000100000001000000010000000100000000000000000000000000000000000000000000000000000000000000000000000_xxl;
            _value = 0b11000000110000001100000011000000110000001100000011000000110000001100000000000000000000000000000000000000000000000000000000000000_xxl;
            break;  // ^^      pp      pp      pp      pp      pp      pp      pp      pp

          case 0xA: // 80      80      80      80      80      80      80      80      80      00 --> 18 bits prediction
            //       0b10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx00xxxxxx
            _prdct = 0b10000000100000001000000010000000100000001000000010000000100000001000000000000000000000000000000000000000000000000000000000000000_xxl;
            _value = 0b11000000110000001100000011000000110000001100000011000000110000001100000011000000000000000000000000000000000000000000000000000000_xxl;
            break;  // ^^      pp      pp      pp      pp      pp      pp      pp      pp      pp

          case 0xB: // 80      80      80      80      80      80      80      80      80      80      00 --> 20 bits prediction
            //       0b10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx00xxxxxx
            _prdct = 0b10000000100000001000000010000000100000001000000010000000100000001000000010000000000000000000000000000000000000000000000000000000_xxl;
            _value = 0b11000000110000001100000011000000110000001100000011000000110000001100000011000000110000000000000000000000000000000000000000000000_xxl;
            break;  // ^^      pp      pp      pp      pp      pp      pp      pp      pp      pp      pp

          case 0xC: // 80      80      80      80      80      80      80      80      80      80      80      00 --> 22 bits prediction
            //       0b10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx00xxxxxx
            _prdct = 0b10000000100000001000000010000000100000001000000010000000100000001000000010000000100000000000000000000000000000000000000000000000_xxl;
            _value = 0b11000000110000001100000011000000110000001100000011000000110000001100000011000000110000001100000000000000000000000000000000000000_xxl;
            break;  // ^^      pp      pp      pp      pp      pp      pp      pp      pp      pp      pp      pp

          case 0x00:
          case 0x01:
          case 0x02:
          case 0x03:
          case 0x0D:
          case 0x0E:
          case 0x0F:
          default: // Ignore the not used costs
            break;
        }
        // clang-format on

        Shift();  // Get in sync
        Shift();
      }
    }

    return {false, _pr = 0x7FF};  // No prediction
  }

  void SetDataPos(const int64_t data_pos) noexcept {
    _skip_bytes = data_pos;
  }

  void SetStart(const bool state) noexcept {
    _start = state;
  }

private:
  static constexpr int32_t ESCAPE_CHAR{4};  // 0x04

  void Shift() noexcept {
    _prdct += _prdct;
    _value += _value;
  }

  uint128_t _prdct{0};
  uint128_t _value{0};
  int64_t _skip_bytes{0};
  uint16_t _pr{0x7FF};  // Prediction 0..4095
  bool _start{false};
  int32_t : 8;   // Padding
  int32_t : 32;  // Padding
};

// 2 bits markers at 0x0F, 0x66 and 0x67
[[nodiscard]] static constexpr auto pref(uint8_t c) noexcept -> uint32_t {
  // clang-format off
  if (0x0F == c) { return 1; }
  if (0x66 == c) { return 2; }
  if (0x67 == c) { return 3; }
  return 0;
  // clang-format on
}

// Get context relevant to parsing 32-bit x86 code
[[nodiscard]] static auto exectx(const Buffer_t& buf) noexcept -> uint32_t {
  auto ctx{0xC7u & buf(2)};          // Mod and r/m fields
  ctx = (ctx * 256) | buf(3);        // Opcode
  ctx = (ctx * 256) | pref(buf(4));  // Prefix
  ctx = (ctx * 4) | pref(buf(5));    // Prefix
  return ctx;
}

template <typename T>
[[nodiscard]] constexpr auto Balance(const T weight, const T px, const T py) noexcept -> T {
  return T((((16 * px) - ((16 - weight) * (px - py))) + 8) / 16);
}

/**
 * @class SSE_t
 * Secondary Symbol Estimation
 */
class SSE_t final {
public:
  SSE_t() noexcept {
    for (uint32_t pr{0x000}; pr <= 0xFFF; ++pr) {
      const uint32_t n0{0xFFF - pr};
      const uint32_t n1{pr};
      _n0[pr] = n0;
      _n1[pr] = n1;
      assert(pr == ((0xFFF * n1) / (n0 + n1)));
    }
  }
  ~SSE_t() noexcept = default;
  SSE_t(const SSE_t&) = delete;
  SSE_t(SSE_t&&) = delete;
  auto operator=(const SSE_t&) -> SSE_t& = delete;
  auto operator=(SSE_t&&) -> SSE_t& = delete;

  [[nodiscard]] auto Predict16(const uint32_t pr12, const bool bit) noexcept -> uint32_t {
    assert(pr12 < 0x1000);

    // Update
    if (bit) {
      ++_n1[_sse];
    } else {
      ++_n0[_sse];
    }
    if ((_n0[_sse] | _n1[_sse]) >> (dp_shift_ + 1)) {  // shift needed
      _n0[_sse] >>= 1;
      _n1[_sse] >>= 1;
    }

    // Predict
    _sse = pr12;
    if (!_n0[_sse]) {
      return 0xFFFF;
    }
    if (!_n1[_sse]) {
      return 1;
    }
    const uint32_t pr{MulDiv(0xFFFF, _n1[_sse], _n0[_sse] + _n1[_sse])};
    return pr + (pr < 32768);
  }

private:
  std::array<uint32_t, 4096> _n0{};
  std::array<uint32_t, 4096> _n1{};
  uint32_t _sse{0};

  /**
   * '(x * y) / z' with rounding
   * @param x Input 'x'
   * @param y Input 'y'
   * @param z Input 'z' can not be zero
   * @return (x * y) / z
   */
  [[nodiscard]] ALWAYS_INLINE constexpr auto MulDiv(const uint64_t x, const uint64_t y, const uint64_t z) const noexcept -> uint32_t {
    assert(z > 0);
    return static_cast<uint32_t>(((2 * x * y) + z) / (2 * z));
  }
};

// Main model - predicts next bit probability from previous data
class Predict_t final {
public:
  explicit Predict_t(Buffer_t& __restrict buf) noexcept : _buf{buf} {
    cp_[0] = cp_[1] = cp_[2] = cp_[3] = cp_[4] = _t0.data();

    for (uint32_t i{0}; i < 8192; ++i) {
      uint8_t v;
      const auto e{(std::abs)(static_cast<int32_t>(i) - 4096)};
      // clang-format off
      v = 0; if (e > (50*32)) { v = 1; } if (e > ( 97*32)) { v = 3; } _calcfails[0][i] = v; // 013: 50  97
      v = 0; if (e > (39*32)) { v = 1; } if (e > ( 80*32)) { v = 3; } _calcfails[1][i] = v; // 013: 39  80
      v = 0; if (e > (47*32)) { v = 1; }                              _calcfails[2][i] = v; // 01 : 47
      v = 0; if (e > ( 3*32)) { v = 1; } if (e > ( 51*32)) { v = 3; } _calcfails[3][i] = v; // 013:  3  51
      v = 0; if (e > (52*32)) { v = 1; } if (e > (104*32)) { v = 3; } _calcfails[4][i] = v; // 013: 52 104
      v = 0; if (e > (30*32)) { v = 1; } if (e > ( 98*32)) { v = 3; } _calcfails[5][i] = v; // 013: 30  98
                                v = 1;   if (e > ( 11*32)) { v = 3; } _calcfails[6][i] = v; //  13:     11
      v = 0; if (e > (45*32)) { v = 1; } if (e > ( 79*32)) { v = 3; } _calcfails[7][i] = v; // 013: 45  79
      // clang-format on
    }
  }

  virtual ~Predict_t() noexcept;

  Predict_t() = delete;
  Predict_t(const Predict_t&) = delete;
  Predict_t(Predict_t&&) = delete;
  auto operator=(const Predict_t&) -> Predict_t& = delete;
  auto operator=(Predict_t&&) -> Predict_t& = delete;

  [[nodiscard]] auto Next(const bool bit) noexcept -> uint32_t {
    if (_fails & 0x80) {
      --_failcount;  // 0..8
    }
    _fails += _fails;
    _failz += _failz;
    const auto pr16{bit ? (_pr16 ^ 0xFFFF) : _pr16};  // Previous prediction 0..65535
    if (pr16 >= (375 * 32)) {
      ++_failz;
      if (pr16 >= (975 * 32)) {
        ++_fails;
        ++_failcount;  // 0..8
      }
    }

    // Filter the context model with APMs
    const auto p0{Predict(bit)};
    const auto p1{Balance(static_cast<uint16_t>(3), _a1.p3(bit, p0, c0_), p0)};  // Weight of 3 is based on enwik9

    uint32_t cz{(1 & _fails) ? UINT32_C(9) : UINT32_C(1)};
    cz += 0xF & (0x7340 >> (4 * (3 & (_fails >> 5))));
    cz += 0xF & (0xC660 >> (4 * (3 & (_fails >> 3))));
    cz += 0xF & (0xFC60 >> (4 * (3 & (_fails >> 1))));
    cz = (std::min)(UINT32_C(9), (_failcount + cz) / 2);

    // clang-format off
    const auto p2{_a2.p3(bit, p0,           finalise64(hash(  8*c0_, 0x7FF & _failz                         ), 27))}; // hash bits of 27 is based on enwik9
    const auto p3{_a3.p3(bit, p0,           finalise64(hash( 32*c0_, 0x80FFFF & x5_                         ), 25))}; // hash bits of 25 is based on enwik9
    const auto p4{_a4.p3(bit, p1, (2*c0_) ^ finalise64(hash(_buf(1), 0xFF & (x5_ >> 8), 0x80FF & (x5_ >> 16)), 57))}; // hash bits of 57 is based on enwik9
    const auto p5{_a5.p3(bit, p2,           finalise64(hash(    c0_, w5_                                    ), 24))}; // hash bits of 24 is based on enwik9
    const auto p6{_a6.p3(bit, p4, (4*c0_) ^ finalise64(hash(    cz, 0x0080FF & x5_                          ), 57))}; // hash bits of 57 is based on enwik9
    // clang-format on

    auto* const __restrict px{_blend.Get()};
    px[0] = Stretch(p3);  // Conversions from 0..4095 into -2048..2047
    px[1] = Stretch(p4);
    px[2] = Stretch(p5);
    px[3] = Stretch(p6);

    const auto ctx{(w5_ << 1) | ((0xFF & _fails) ? 1 : 0)};
    const int32_t err{((bit << 16) - static_cast<int32_t>(_pr16)) / 8};
    const auto pr12{_blend.Predict(err, ctx)};

    uint16_t p7;
    if (0x7FF != _pt) {
      assert((0x000 == _pt) || (0xFFF == _pt));  // Predicts only 0 or 1 with certainty of 100%
      p7 = _pt;
    } else {
      p7 = Squash(pr12);  // Conversion from -2048..2047 (clamped) into 0..4095
    }

    _pr16 = _sse.Predict16(p7, bit);
    if (0x7FF != _pt) {
      _pr16 = _pt ? 0xFFFF : 0x0000;
    }
    return _pr16;
  }

  void SetBinary(const bool is_binary) noexcept {
    _is_binary = is_binary;
  }

  void SetDataPos(const int64_t data_pos) noexcept {
    _txt.SetDataPos(data_pos);
  }

  void SetStart(const bool state) noexcept {
    _txt.SetStart(state);
  }

private:
  Buffer_t& __restrict _buf;
  Mixer_t _mixer{};
  uint32_t _add2order{0};
  uint32_t _fails{0};
  uint32_t _failz{0};
  uint32_t _failcount{0};
  DynamicMarkovModel_t _dmc{MEM()};
  LempelZivPredict_t _lzp{_buf, MEM(20)};
  SparseMatchModel_t _smm{_buf};
  Txt_t _txt{};
  APM_t _ax1{0x10000, 7};  // Fixed 16 bit context | Offset 7 is based on enwik9
  APM_t _ax2{0x4000, 31};  //                      | Offset 31 is based on enwik9
  APM_t _a1{0x100};        // Fixed 8 bit context
  APM_t _a2{MEM(9)};       // 5
  APM_t _a3{MEM(12)};      // 3
  APM_t _a4{MEM(14)};      // 1
  APM_t _a5{MEM(12)};      // 2
  APM_t _a6{MEM(9)};       // 4
  uint16_t _mxr_pr{0x7FF};
  uint16_t _pt{0x7FF};
  uint32_t _pr16{0x7FFF};  // Prediction 0..65535
  HashTable_t _t4a{MEM(23)};
  HashTable_t _t4b{MEM(23)};
  bool _is_binary{false};
  int32_t : 24;                                    // Padding
  int32_t : 32;                                    // Padding
  Blend_t<4, 16> _blend{UINT32_C(1) << 19, 4096};  // w5_ | Rate of 16 is based on enwik9
  std::array<std::array<uint8_t, 8192>, 8> _calcfails{};
  std::array<uint8_t, 0x10000> _t0{};
  uint8_t* __restrict _t0c1{_t0.data()};
  uint32_t _ctx1{0};
  uint32_t _ctx2{0};
  uint32_t _ctx3{0};
  uint32_t _ctx4{0};
  uint32_t _ctx5{0};
  uint32_t _pw{0};
  int32_t* _ctx6{&smt_[0][0]};
  uint32_t _bc4cp0{0};  // Range 0,1,2 or 3
  SSE_t _sse{};

  [[nodiscard]] auto Predict_not32(const bool bit) noexcept -> uint16_t {
    auto y2o{(bit << 20) - bit};

    const auto len{_lzp.Predict(bit)};        // len --> 0..9
    _mixer.Context(_add2order + (64 * len));  // len --> 0..576 --> 10800+576+(9*8)
    _ctx6[0] += (y2o - _ctx6[0]) >> 6;        // (6) 6 is based on enwik9 (little influence)
    _ctx6 = &smt_[_bc4cp0][_t0c1[c0_]];       // smt[0,1,2 or 3][...]

    smt_[0x5][_ctx5] += (y2o - smt_[0x5][_ctx5]) * limits_15a_[_ctx5] >> 9;  // P5
    y2o += 384;                                                              //
    smt_[0x4][_ctx1] += (y2o - smt_[0x4][_ctx1]) >> 9;                       // P1
    smt_[0x6][_ctx2] += (y2o - smt_[0x6][_ctx2]) >> 9;                       // P2
    smt_[0x8][_ctx3] += (y2o - smt_[0x8][_ctx3]) >> 10;                      // P3
    smt_[0xA][_ctx4] += (y2o - smt_[0xA][_ctx4]) >> 10;                      // P4

    _ctx1 = *cp_[0x0];
    _ctx2 = *cp_[0x1];
    _ctx3 = *cp_[0x2];
    _ctx4 = *cp_[0x3];
    _ctx5 = *cp_[0x4];

    Mixer_t::tx_[1] = Stretch256(smt_[0x4][_ctx1]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[2] = Stretch256(smt_[0x6][_ctx2]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[3] = Stretch256(smt_[0x8][_ctx3]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[4] = Stretch256(smt_[0xA][_ctx4]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[5] = Stretch256(smt_[0x5][_ctx5]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[6] = Stretch256(_ctx6[0]);          // Conversion from 0..1048575 into -2048..2047

    const auto pr{_mixer.Predict()};
    _mxr_pr = _ax1.p1(bit, pr, c2_ | c0_);
    const auto px{Balance(static_cast<uint16_t>(3), Squash(pr), _mxr_pr)};  // Conversion from -2048..2047 (clamped) into 0..4095, Weight of 3 is based on enwik9

    const auto py{_ax2.p2(bit, Stretch(px), (fails_ * 8) + bcount_)};  // Conversion from 0..4095 into -2048..2047
    const auto pz{Balance(static_cast<uint16_t>(4), _mxr_pr, py)};     // Weight of 4 is based on enwik9
    assert(pz < 0x1000);
    return pz;
  }

  [[nodiscard]] auto Predict_not32s(const bool bit) noexcept -> uint16_t {
    auto y2o{(bit << 20) - bit};

    const auto len{_lzp.Predict(bit)};        // len --> 0..9
    _mixer.Context(_add2order + (64 * len));  // len --> 0..576 --> 10800+576+(9*8)
    _ctx6[0] += (y2o - _ctx6[0]) >> 6;        // (6) 6 is based on enwik9 (little influence)
    _ctx6 = &smt_[_bc4cp0][_t0c1[1]];         // smt[0,1,2 or 3][...] with c0_=1

    smt_[0x4][_ctx1] += (y2o - smt_[0x4][_ctx1]) >> 9;                       // P1
    smt_[0x5][_ctx5] += (y2o - smt_[0x5][_ctx5]) * limits_15a_[_ctx5] >> 9;  // P5

    if (0x2000 == (0xFF00 & cx_)) {
      y2o += 768;
      smt_[0x7][_ctx2] += (y2o - smt_[0x7][_ctx2]) >> 10;  // P2
      smt_[0x9][_ctx3] += (y2o - smt_[0x9][_ctx3]) >> 11;  // P3
      smt_[0xB][_ctx4] += (y2o - smt_[0xB][_ctx4]) >> 11;  // P4
    } else {
      y2o += 384;
      smt_[0x6][_ctx2] += (y2o - smt_[0x6][_ctx2]) >> 9;   // P2
      smt_[0x8][_ctx3] += (y2o - smt_[0x8][_ctx3]) >> 10;  // P3
      smt_[0xA][_ctx4] += (y2o - smt_[0xA][_ctx4]) >> 9;   // P4
    }

    _ctx1 = *cp_[0x0];
    _ctx2 = *cp_[0x1];
    _ctx3 = *cp_[0x2];
    _ctx4 = *cp_[0x3];
    _ctx5 = *cp_[0x4];

    Mixer_t::tx_[1] = Stretch256(smt_[0x4][_ctx1]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[2] = Stretch256(smt_[0x6][_ctx2]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[3] = Stretch256(smt_[0x8][_ctx3]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[4] = Stretch256(smt_[0xA][_ctx4]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[5] = Stretch256(smt_[0x5][_ctx5]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[6] = Stretch256(_ctx6[0]);          // Conversion from 0..1048575 into -2048..2047

    const auto pr{_mixer.Predict()};
    const auto px{_ax1.p1(bit, pr, c2_ | c0_)};
    _mxr_pr = Balance(static_cast<uint16_t>(2), Squash(pr), px);  // Conversion from -2048..2047 (clamped) into 0..4095, Weight of 2 is based on enwik9

    const auto py{_ax2.p2(bit, Stretch(px), (fails_ * 8) + 7)};     // Conversion from 0..4095 into -2048..2047
    const auto pz{Balance(static_cast<uint16_t>(8), _mxr_pr, py)};  // Weight of 8 is based on enwik9
    assert(pz < 0x1000);
    return pz;
  }

  [[nodiscard]] auto Predict_was32(const bool bit) noexcept -> uint16_t {
    auto y2o{(bit << 20) - bit};

    const auto len{_lzp.Predict(bit)};        // len --> 0..9
    _mixer.Context(_add2order + (64 * len));  // len --> 0..576 --> 10800+576+(9*8)
    _ctx6[0] += (y2o - _ctx6[0]) >> 7;        // (8) 7 is based on enwik9 (little influence)
    _ctx6 = &smt_[1][_t0c1[c0_]];

    smt_[0x5][_ctx5] += (y2o - smt_[0x5][_ctx5]) * limits_15b_[_ctx5] >> 10;  // P5
    y2o += 768;                                                               //
    smt_[0x4][_ctx1] += (y2o - smt_[0x4][_ctx1]) >> 14;                       // P1
    smt_[0x7][_ctx2] += (y2o - smt_[0x7][_ctx2]) >> 10;                       // P2
    smt_[0x9][_ctx3] += (y2o - smt_[0x9][_ctx3]) >> 11;                       // P3
    smt_[0xB][_ctx4] += (y2o - smt_[0xB][_ctx4]) >> 10;                       // P4

    _ctx1 = *cp_[0x0];
    _ctx2 = *cp_[0x1];
    _ctx3 = *cp_[0x2];
    _ctx4 = *cp_[0x3];
    _ctx5 = *cp_[0x4];

    Mixer_t::tx_[1] = Stretch256(smt_[0x4][_ctx1]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[2] = Stretch256(smt_[0x7][_ctx2]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[3] = Stretch256(smt_[0x9][_ctx3]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[4] = Stretch256(smt_[0xB][_ctx4]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[5] = Stretch256(smt_[0x5][_ctx5]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[6] = Stretch256(_ctx6[0]);          // Conversion from 0..1048575 into -2048..2047

    const auto pr{_mixer.Predict()};
    _mxr_pr = _ax1.p1(bit, pr, c2_ | c0_);
    const auto px{Balance(static_cast<uint16_t>(12), Squash(pr), _mxr_pr)};  // Conversion from -2048..2047 (clamped) into 0..4095, Weight of 12 is based on enwik9
    const auto py{_ax2.p2(bit, Stretch(_mxr_pr), (fails_ * 8) + bcount_)};   // Conversion from 0..4095 into -2048..2047
    const auto pz{Balance(static_cast<uint16_t>(6), px, py)};                // Weight of 6 is based on enwik9
    assert(pz < 0x1000);
    return pz;
  }

  [[nodiscard]] auto Predict_was32s(const bool bit) noexcept -> uint16_t {
    auto y2o{(bit << 20) - bit};

    const auto len{_lzp.Predict(bit)};        // len --> 0..9
    _mixer.Context(_add2order + (64 * len));  // len --> 0..576 --> 10800+576+(9*8)
    _ctx6[0] += (y2o - _ctx6[0]) >> 13;       // (12) 13 is based on enwik9 (little influence)
    _ctx6 = &smt_[1][_t0c1[1]];               // c0_=1

    smt_[0x5][_ctx5] += (y2o - smt_[0x5][_ctx5]) * limits_15b_[_ctx5] >> 14;  // P5
    y2o += 6144;                                                              //
    smt_[4][_ctx1] += (y2o - smt_[4][_ctx1]) >> 14;                           // P1

    if (0x2000 == (0xFF00 & cx_)) {
      smt_[0x7][_ctx2] += (y2o - smt_[0x7][_ctx2]) >> 13;  // P2
      smt_[0x9][_ctx3] += (y2o - smt_[0x9][_ctx3]) >> 14;  // P3
      smt_[0xB][_ctx4] += (y2o - smt_[0xB][_ctx4]) >> 13;  // P4
    } else {
      smt_[0x6][_ctx2] += (y2o - smt_[0x6][_ctx2]) >> 13;  // P2
      smt_[0x8][_ctx3] += (y2o - smt_[0x8][_ctx3]) >> 14;  // P3
      smt_[0xA][_ctx4] += (y2o - smt_[0xA][_ctx4]) >> 13;  // P4
    }

    _ctx1 = *cp_[0x0];
    _ctx2 = *cp_[0x1];
    _ctx3 = *cp_[0x2];
    _ctx4 = *cp_[0x3];
    _ctx5 = *cp_[0x4];

    Mixer_t::tx_[1] = Stretch256(smt_[0x4][_ctx1]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[2] = Stretch256(smt_[0x6][_ctx2]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[3] = Stretch256(smt_[0x8][_ctx3]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[4] = Stretch256(smt_[0xA][_ctx4]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[5] = Stretch256(smt_[0x5][_ctx5]);  // Conversion from 0..1048575 into -2048..2047
    Mixer_t::tx_[6] = Stretch256(_ctx6[0]);          // Conversion from 0..1048575 into -2048..2047

    const auto pr{_mixer.Predict()};
    const auto px{_ax1.p1(bit, pr, c2_ | c0_)};
    _mxr_pr = Balance(static_cast<uint16_t>(6), Squash(pr), px);  // Conversion from -2048..2047 (clamped) into 0..4095, Weight of 6 is based on enwik9

    const auto py{_ax2.p2(bit, Stretch(px), (fails_ * 8) + 7)};      // Conversion from 0..4095 into -2048..2047
    const auto pz{Balance(static_cast<uint16_t>(12), _mxr_pr, py)};  // Weight of 12 is based on enwik9
    assert(pz < 0x1000);
    return pz;
  }

  void UpdateStates(const bool bit, int32_t cx) noexcept {
    const auto& p{bit ? state_table_y1_ : state_table_y0_};
    int32_t j{1 & cx};
    const auto& q{j ? state_table_y1_ : state_table_y0_};

    auto* const __restrict toc{_t0c1};
    toc[cx] = p[2][toc[cx]];
    cx >>= 1;
    toc[cx] = q[2][toc[cx]];
    j = j ^ ~0;  // 0 --> -1    1 --> -2

    auto* const __restrict cp0{cp_[0]};
    cp0[0] = p[1][cp0[0]];
    cp0[j] = q[1][cp0[j]];

    auto* const __restrict cp1{cp_[1]};
    cp1[0] = p[0][cp1[0]];  // in lpaq9m 4 for was32
    cp1[j] = q[0][cp1[j]];

    auto* const __restrict cp2{cp_[2]};
    cp2[0] = p[3][cp2[0]];
    cp2[j] = q[3][cp2[j]];

    auto* const __restrict cp3{cp_[3]};
    cp3[0] = p[4][cp3[0]];
    cp3[j] = q[4][cp3[j]];

    auto* const __restrict cp4{cp_[4]};
    cp4[0] = p[5][cp4[0]];  // in lpaq9m cycles between 5,3,1,5,..
    cp4[j] = q[5][cp4[j]];
  }

  [[nodiscard]] auto Predict(const bool bit) noexcept -> uint16_t {
    fails_ += fails_;
#if 1
    // const auto MU{static_cast<int8_t>(INT64_C(0x091A1B14181C232E) >> (8 * bcount_))};  // based on lpaq9m
    // const auto MU{static_cast<int8_t>(INT64_C(0x0117081224254D3B) >> (8 * bcount_))};  // based on enwik8
    const auto MU{static_cast<int8_t>(INT64_C(0x01190E131717261C) >> (8 * bcount_))};  // based on enwik9
#else
    //                                 2E  23  1C  18  14  1B  1A  9
    // static constexpr int8_t flaw[8]{46, 35, 28, 24, 20, 27, 26, 9};  // based on lpaq9m

    //                                 3B  4D  25  24  12  8  17  1
    // static constexpr int8_t flaw[8]{59, 77, 37, 36, 18, 8, 23, 1};  // based on enwik8

    //                              1C  26  17  17  13  0E  19  1
    static constexpr int8_t flaw[8]{28, 38, 23, 23, 19, 14, 25, 1};  // based on enwik9
    const int8_t MU{flaw[bcount_]};
#endif
    if (const auto err{(bit << 12) - static_cast<int32_t>(_mxr_pr) - bit}; (err <= -MU) || (err >= MU)) {
      assert((err + 4096) < 8192);
      fails_ |= _calcfails[(bcount_ - 1) & 7][static_cast<uint16_t>(err + 4096)];
      _mixer.Update(err);
    }
    const auto cx{static_cast<int32_t>(c0_)};
    c0_ += c0_ + static_cast<uint32_t>(bit);
    bcount_ = 7 & (bcount_ - 1);
    // bpos_ = (bpos_ + 1) & 7;
    _add2order += Mixer_t::N_LAYERS;

    switch (bcount_) {
      case 6:    // c0_ contains 1 bit
      case 4:    // c0_ contains 3 bits
      case 2:    // c0_ contains 5 bits
      case 0: {  // c0_ contains 7 bits
        const auto z{bit ? 2 : 1};
        cp_[0] += z;
        cp_[1] += z;
        cp_[2] += z;
        cp_[3] += z;
        cp_[4] += z;
      } break;

      case 5: {  // c0_ contains 2 bits
        UpdateStates(bit, cx);
        auto zq{2 + (c0_ & 0x03) * 2};
        cp_[0] = _t4b.get1x(0x00, zq + hh_[0]);  // 000 (0)
        cp_[1] = _t4a.get1x(0x80, zq + hh_[1]);  // 100 (4)
        cp_[4] = _t4b.get1x(0x00, zq + hh_[4]);  // 000 (0)
        zq *= 2;
        cp_[2] = _t4a.get3a(0x00, zq + hh_[2]);  // 000 (0)
        cp_[3] = _t4b.get3a(0x80, zq + hh_[3]);  // 100 (4)
      } break;

      case 1: {  // c0_ contains 6 bits
        UpdateStates(bit, cx);
        auto zq{2 + (c0_ & 0x3F) * 2};
        cp_[0] = _t4b.get1x(0xC0, zq + hh_[0]);  // 110 (6)
        cp_[1] = _t4a.get1x(0x40, zq + hh_[1]);  // 010 (2)
        cp_[4] = _t4b.get1x(0xC0, zq + hh_[4]);  // 110 (6)
        zq *= 2;
        cp_[2] = _t4a.get3b(0xC0, zq + hh_[2]);  // 110 (6)
        cp_[3] = _t4b.get3b(0x40, zq + hh_[3]);  // 010 (2)
      } break;

      case 3: {  // c0_ contains 4 bits
        UpdateStates(bit, cx);
        const auto zq{2 + (c0_ & 0x0F) * 2};
        const auto blur{Utilities::PHI32 * zq};
        const auto c4{cx_ & 0xFFFFFFFF};
        const auto c8{cx_ >> 32};
        hh_[0] = finalise64(hash(zq - hh_[0]), 32);
        hh_[1] ^= blur;
        hh_[2] = finalise64(hash(zq, c4, c8 & 0x000080FF), 32);
        hh_[3] = finalise64(hash(zq, c4, c8 & 0x00FFFFFF), 32);
        hh_[4] ^= blur;
        cp_[0] = _t4b.get1x(0xA0, hh_[0]);  // 101 (5)
        cp_[1] = _t4a.get1x(0x20, hh_[1]);  // 001 (1)
        cp_[2] = _t4a.get3b(0xA0, hh_[2]);  // 101 (5)
        cp_[3] = _t4b.get3b(0x20, hh_[3]);  // 001 (1)
        cp_[4] = _t4b.get1x(0xA0, hh_[4]);  // 101 (5)
      } break;

      case 7:
      default: {  // c0_ contains 8 bits (from previous cycle) --> Reset to 1 for new cycle
        UpdateStates(bit, cx);
        const auto ch{static_cast<uint8_t>(c0_)};
        c0_ = ch;
        const auto idx{Mixer_t::N_LAYERS * 10u * 4u * wrt_mxr_[ch]};  // 9*10*4*(0..30) --> 10800
        _add2order = idx;

        static constexpr std::array<uint8_t, 256> WRT_mtt{{0, 4, 4, 5, 0, 5, 3, 7, 0, 2, 4, 0, 0, 0, 0, 0,    // 00-0F . . . . . . . . . . . . . . . .
                                                           0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,    // 10-1F . . . . . . . . . . . . . . . .
                                                           2, 4, 3, 3, 4, 6, 6, 7, 5, 4, 0, 4, 3, 4, 0, 1,    // 20-2F   ! " # $ % & ' ( ) * + , - . /
                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 3, 3, 4, 3, 4,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
                                                           0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,    // 40-4F @ A B C D E F G H I J K L M N O
                                                           5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 4, 3, 4, 4,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
                                                           0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,    // 60-6F ` a b c d e f g h i j k l m n o
                                                           5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4,    // 70-7F p q r s t u v w x y z { | } ~ .
                                                           6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,    // 80-8F . . . . . . . . . . . . . . . .
                                                           6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,    // 90-9F . . . . . . . . . . . . . . . .
                                                           6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,    // A0-AF . . . . . . . . . . . . . . . .
                                                           6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,    // B0-BF . . . . . . . . . . . . . . . .
                                                           6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,    // C0-CF . . . . . . . . . . . . . . . .
                                                           7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,    // D0-DF . . . . . . . . . . . . . . . .
                                                           7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,    // E0-EF . . . . . . . . . . . . . . . .
                                                           7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7}};  // F0-FF . . . . . . . . . . . . . . . .
        if (!(0xFF & _pw)) {
          c1_ = (static_cast<uint32_t>(WRT_mtt[ch]) << 2) + 33u;  // 0..61
        } else {
          c1_ = (static_cast<uint32_t>(WRT_mtt[ch]) << 5) | (0x1F & _pw);
          if (c1_ < 64) {
            static constexpr std::array<uint8_t, 64> WRT_chc1{{0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,    // 00-0F . . . . . . . . . . . . . . . .
                                                               16, 1,  18, 19, 20, 5,  22, 23, 24, 9,  26, 27, 28, 13, 30, 31,    // 10-1F . . . . . . . . . . . . . . . .
                                                               32, 17, 34, 35, 36, 21, 38, 39, 40, 25, 42, 43, 44, 29, 46, 47,    // 20-2F   ! " # $ % & ' ( ) * + , - . /
                                                               48, 17, 50, 51, 52, 21, 54, 55, 56, 25, 58, 59, 60, 29, 62, 63}};  // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
            c1_ = WRT_chc1[c1_];
          }
        }
        c2_ = c1_ * 256;

        _buf.Add(ch);
        cx_ = (cx_ << 8) | ch;
        _t0c1 = &_t0[ch * 256];

        if (!(ch & 0x80)) {
#if 1
          static constexpr auto TxtFilter{0x28000001D00000000000C14000000400_xxl};
          static constexpr auto ExeFilter{0x00000000000000000000000000008002_xxl};

          if (const auto filter{_is_binary ? ExeFilter : TxtFilter}; 1 & (filter >> ch)) {
#else
          // \n & ( . / \ ^ _ ' { }                            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F              0 1 2 3 4 5 6 7 8 9 A B C D E F
          static constexpr std::array<uint8_t, 128> TxtFilter{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,    // 00-0F . . . . . . . . . . . . . . . .
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 10-1F . . . . . . . . . . . . . . . .
                                                               0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1,    // 20-2F   ! " # $ % & ' ( ) * + , - . /
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 40-4F @ A B C D E F G H I J K L M N O
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
                                                               1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 60-6F ` a b c d e f g h i j k l m n o
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0}};  // 70-7F p q r s t u v w x y z { | } ~ .

          // 01 0F                                             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F              0 1 2 3 4 5 6 7 8 9 A B C D E F
          static constexpr std::array<uint8_t, 128> ExeFilter{{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,    // 00-0F . . . . . . . . . . . . . . . .
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 10-1F . . . . . . . . . . . . . . . .
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 20-2F   ! " # $ % & ' ( ) * + , - . /
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 40-4F @ A B C D E F G H I J K L M N O
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 60-6F ` a b c d e f g h i j k l m n o
                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};  // 70-7F p q r s t u v w x y z { | } ~ .

          if (const auto& filter{_is_binary ? ExeFilter : TxtFilter}; filter[ch]) {
#endif
            tt_ = (tt_ & UINT32_C(-8)) + 1;
            w5_ = (w5_ << 8) | 0x3FF;
            x5_ = (x5_ << 8) + ch;
          }
        }

        tt_ = (tt_ * 8) + WRT_mtt[ch];
        w5_ = (w5_ * 4) + static_cast<uint32_t>(0xFU & (UINT64_C(0x0000111111233444) >> (4 * (ch >> 4))));  // WRT_mpw
        x5_ = (x5_ << 8) + ch;

        //                                                 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F              0 1 2 3 4 5 6 7 8 9 A B C D E F
        static constexpr std::array<uint8_t, 256> WRT_wrd{{0, 0, 0, 1, 0, 1, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0,    // 00-0F . . . . . . . . . . . . . . . .
                                                           0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,    // 10-1F . . . . . . . . . . . . . . . .
                                                           0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,    // 20-2F   ! " # $ % & ' ( ) * + , - . /
                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 2, 0, 2, 0,    // 30-3F 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
                                                           0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    // 40-4F @ A B C D E F G H I J K L M N O
                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 3, 0, 0, 0,    // 50-5F P Q R S T U V W X Y Z [ \ ] ^ _
                                                           0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    // 60-6F ` a b c d e f g h i j k l m n o
                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,    // 70-7F p q r s t u v w x y z { | } ~ .
                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,    // 80-8F . . . . . . . . . . . . . . . .
                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,    // 90-9F . . . . . . . . . . . . . . . .
                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,    // A0-AF . . . . . . . . . . . . . . . .
                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,    // B0-BF . . . . . . . . . . . . . . . .
                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,    // C0-CF . . . . . . . . . . . . . . . .
                                                           3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,    // D0-DF . . . . . . . . . . . . . . . .
                                                           3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,    // E0-EF . . . . . . . . . . . . . . . .
                                                           3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3}};  // F0-FF . . . . . . . . . . . . . . . .
        _bc4cp0 = WRT_wrd[ch];
        _pw += _pw + (_bc4cp0 ? 1 : 0);

        if (const auto pc{static_cast<uint8_t>(cx_ >> 8)}; (ch > 127) ||                    //
                                                           ((ch >= 'a') && (ch <= 'z')) ||  //
                                                           ((ch >= '0') && (ch <= '9')) ||  //
                                                           ((pc >= '0') && (pc <= '9') && ('.' == ch))) {
          word_ = combine64(word_, ch);
        } else if ((ch >= 'A') && (ch <= 'Z')) {
          word_ = combine64(word_, ch + 'a' - 'A');
        } else {
          word_ = 0;
        }

        const auto c4{cx_ & 0xFFFFFFFF};
        const auto c8{cx_ >> 32};
        const auto ctx{_is_binary ? exectx(_buf) : (cx_ & 0x0080FFFF)};
        hh_[0] = finalise64(hash(ctx), 32);
        hh_[1] = finalise64(hash(c4, wrt_mxr_[(cx_ >> 24) & 0xFF]), 32);
        hh_[2] = finalise64(hash(c4, c8 & 0x0000C0FF), 32);
        hh_[3] = finalise64(hash(c4, c8 & 0x00FEFFFF, wrt_mxr_[cx_ >> 56]), 32);
        hh_[4] = finalise64(combine64(word_, wrt_mxr_[ch]), 32);
        cp_[0] = _t4b.get1x(0xE0, hh_[0]);  // 111 (7)
        cp_[1] = _t4a.get1x(0x60, hh_[1]);  // 011 (3)
        cp_[2] = _t4a.get3a(0xE0, hh_[2]);  // 111 (7)
        cp_[3] = _t4b.get3a(0x60, hh_[3]);  // 011 (3)
        cp_[4] = _t4b.get1x(0xE0, hh_[4]);  // 111 (7)

        _dmc.Update();
        _lzp.Update();
        _smm.Update();
        _txt.Update();

        if (const auto pos{_buf.Pos()}; 0 == (pos & (256 * 1024 - 1))) {
          if (((16 == dp_shift_) && (pos == (25 * 256 * 1024))) ||  // 22 or 25 based on enwik9 (little influence)
              ((15 == dp_shift_) && (pos == (4 * 256 * 1024))) ||   // 2 or 4 based on enwik9 (little influence)
              (14 == dp_shift_)) {
            ++dp_shift_;
            _mixer.ScaleUp();
          }
        }

        c0_ = 1;
      } break;
    }

    _dmc.Predict(bit);
    _smm.Predict(bit);

    uint16_t pr;

    if (32 == _buf(1)) {
      pr = (7 == bcount_) ? Predict_was32s(bit) : Predict_was32(bit);
    } else {
      pr = (7 == bcount_) ? Predict_not32s(bit) : Predict_not32(bit);
    }

    if (const auto no_model{_txt.Predict(bit)}; no_model.first) {
      assert((0x000 == no_model.second) || (0xFFF == no_model.second));  // Predicts only 0 or 1 with certainty of 100%
      _pt = pr = no_model.second;
    } else {
      _pt = 0x7FF;  // No prediction
    }
    assert(pr < 0x1000);
    return pr;
  }
};
Predict_t::~Predict_t() noexcept = default;

// Encoder - Arithmetic coding
class Encoder_t final : public iEncoder_t {
public:
  explicit Encoder_t(Buffer_t& __restrict buf, bool encode, File_t& file) noexcept
      : _stream{file},  //
        _predict{std::make_unique<Predict_t>(buf)} {
    if (!encode) {
      _x = _stream.get32();
    }

    std::fill(&smt_[0][0], &smt_[0][0] + sizeof(smt_) / sizeof(smt_[0][0]), 0x07FFFF);

    for (uint32_t i{6}; i--;) {
      int32_t* j{&smt_[0xF & (0x578046 >> (i * 4))][0]};
      uint8_t p1{state_table_y0_[i][0]};
      uint8_t p2{state_table_y0_[i][0]};
      uint8_t p3{state_table_y1_[i][0]};
      uint8_t p4{state_table_y1_[i][0]};
      p1 = state_table_y0_[i][p1];
      j[p1] = (0xFFFFF * 1) / 4;
      p2 = state_table_y1_[i][p2];
      j[p2] = (0xFFFFF * 2) / 4;
      p3 = state_table_y0_[i][p3];
      j[p3] = (0xFFFFF * 2) / 4;
      p4 = state_table_y1_[i][p4];
      j[p4] = (0xFFFFF * 3) / 4;
      uint8_t p5{p4};
      uint8_t p6{p1};
      for (auto z{5}; z < 70; ++z) {
        uint8_t px;
        // clang-format off
        px = p1; p1 = state_table_y0_[i][p1];                           if (p1 != px) { j[p1] = (0xFFFFF * (    1)) / z; }
        px = p2; p2 = state_table_y1_[i][p2];                           if (p2 != px) { j[p2] = (0xFFFFF * (z - 2)) / z; }
        px = p3; p3 = state_table_y0_[i][p3];                           if (p3 != px) { j[p3] = (0xFFFFF * (    2)) / z; }
        px = p4; p4 = state_table_y1_[i][p4];                           if (p4 != px) { j[p4] = (0xFFFFF * (z - 1)) / z; }
        px = p5; p5 = state_table_y0_[i][p5]; if (p5 < px) { p5 = px; } if (p5 != px) { j[p5] = (0xFFFFF * (    3)) / z; }
        px = p6; p6 = state_table_y1_[i][p6]; if (p6 < px) { p6 = px; } if (p6 != px) { j[p6] = (0xFFFFF * (z - 3)) / z; }
        // clang-format on
      }
    }

    memcpy(&smt_[0x1], &smt_[0x0], smt_[0x0].size());
    memcpy(&smt_[0x2], &smt_[0x0], smt_[0x0].size());
    memcpy(&smt_[0x3], &smt_[0x0], smt_[0x0].size());
    memcpy(&smt_[0x9], &smt_[0x8], smt_[0x8].size());
    memcpy(&smt_[0xA], &smt_[0x7], smt_[0x7].size());
    memcpy(&smt_[0xB], &smt_[0x7], smt_[0x7].size());
  }
  ~Encoder_t() noexcept override;

  Encoder_t() = delete;
  Encoder_t(const Encoder_t&) = delete;
  Encoder_t(Encoder_t&&) = delete;
  auto operator=(const Encoder_t&) -> Encoder_t& = delete;
  auto operator=(Encoder_t&&) -> Encoder_t& = delete;

  void Compress(const int32_t c) noexcept final {
    for (auto n{8}; n--;) {
      Code((c >> n) & 1);
    }
  }

  [[nodiscard]] auto Decompress() noexcept -> int32_t final {
    auto c{0};
    for (auto n{8}; n--;) {
      c += c + Code();
    }
    return c;
  }

  void CompressN(const int32_t N, const int64_t c) noexcept final {
    for (auto n{N}; n--;) {
      Code((c >> n) & 1);
    }
  }

  [[nodiscard]] auto DecompressN(const int32_t N) noexcept -> int64_t final {
    int64_t c{0};
    for (auto n{N}; n--;) {
      c += c + Code();
    }
    return c;
  }

  void CompressVLI(int64_t c) noexcept final {
    while (c > 0x7F) {
      Compress(static_cast<int32_t>(0x80 | (0x7F & c)));
      c >>= 7;
    }
    Compress(static_cast<int32_t>(c));
  }

  [[nodiscard]] auto DecompressVLI() noexcept -> int64_t final {
    int64_t c{0};
    int32_t k{0};
    int32_t b{0};
    do {
      b = Decompress();
      c |= static_cast<int64_t>(0x7F & b) << k;
      k += 7;
    } while ((k < 127) && (0x80 & b));
    return c;
  }

  void Flush() noexcept final {
    // Flush first unequal byte of range
    _stream.putc(static_cast<int32_t>(_low >> 24));
    _stream.Flush();
  }

  void SetBinary(const bool is_binary) noexcept final {
    if (nullptr != _predict) {
      _predict->SetBinary(is_binary);
    }
  }

  void SetDataPos(const int64_t data_pos) noexcept final {
    if (nullptr != _predict) {
      _predict->SetDataPos(data_pos);
    }
  }

  void SetStart(const bool state) noexcept final {
    if (nullptr != _predict) {
      _predict->SetStart(state);
    }
  }

private:
  static constexpr auto _limit{UINT32_C(0x01000000)};
  File_t& _stream;
  std::unique_ptr<Predict_t> _predict;
  uint32_t _high{~0U};
  uint32_t _low{0};
  uint32_t _x{0};
  uint32_t _pr{0x7FFF};  // Prediction 0x0000..0xFFFF

  [[nodiscard]] ALWAYS_INLINE constexpr auto Rescale() const noexcept -> uint32_t {
    assert(_pr < 0x10000);
    assert(_high > _low);
    const uint32_t mid{_low + static_cast<uint32_t>((static_cast<uint64_t>(_pr) * static_cast<uint64_t>(_high - _low)) / 0x10000)};
    assert(_high > mid);
    assert(mid >= _low);
    return mid;
  }

  void Code(const bool bit) noexcept {
    if (const auto mid{Rescale()}; bit) {
      _high = mid;
    } else {
      _low = mid + 1;
    }
    while ((_low ^ _high) < _limit) {  // Shift out identical leading bytes
      _stream.putc(static_cast<int32_t>(_high >> 24));
      _high = (_high << 8) | 0xFF;
      _low <<= 8;
    }
    _pr = _predict->Next(bit);  // Update models and Predict next bit probability
  }

  [[nodiscard]] auto Code() noexcept -> bool {
    bool bit;
    if (const auto mid{Rescale()}; _x <= mid) {
      _high = mid;
      bit = true;
    } else {
      _low = mid + 1;
      bit = false;
    }
    while ((_low ^ _high) < _limit) {  // Shift out identical leading bytes
      _high = (_high << 8) | 0xFF;
      _low <<= 8;
      _x = (_x << 8) | (_stream.getc() & 0xFF);  // EOF is OK
    }
    _pr = _predict->Next(bit);  // Update models and Predict next bit probability
    return bit;
  }
};
Encoder_t::~Encoder_t() noexcept = default;
iEncoder_t::~iEncoder_t() noexcept = default;

class Monitor_t final : public iMonitor_t {
public:
  explicit Monitor_t(const File_t& in, const File_t& out, const int64_t workLength, const int64_t layoutLength) noexcept
      : _in{in},  //
        _out{out},
        _workLength{workLength},
        _layoutLength{layoutLength} {}
  ~Monitor_t() noexcept override;

  Monitor_t(const Monitor_t&) = delete;
  Monitor_t(Monitor_t&&) = delete;
  auto operator=(const Monitor_t&) -> Monitor_t& = delete;
  auto operator=(Monitor_t&&) -> Monitor_t& = delete;

  [[nodiscard]] auto inputLength() const noexcept -> int64_t final {
    return _in.Position();
  }
  [[nodiscard]] auto outputLength() const noexcept -> int64_t final {
    return _out.Position();
  }
  [[nodiscard]] auto workLength() const noexcept -> int64_t final {
    return _workLength;
  }
  [[nodiscard]] auto layoutLength() const noexcept -> int64_t final {
    return _layoutLength;
  }

private:
  const File_t& _in;
  const File_t& _out;
  const int64_t _workLength;
  const int64_t _layoutLength;
};
Monitor_t::~Monitor_t() noexcept = default;

[[nodiscard]] static auto checksum(const uint8_t* __restrict data, size_t len) noexcept -> uint8_t {
  uint8_t sum{0};
  while (len--) {
    sum = static_cast<uint8_t>(sum + *data++);
  }
  return sum;
}

#if 0
//                         ULLONG_MAX 18446744073709551615ULL
static constexpr uint128_t P10_UINT64{10000000000000000000_xxl};  // 19 zeroes

[[nodiscard]] static auto xxltostr(const uint128_t value) noexcept -> std::string {
  std::array<char, 64> str{};
  if (value > ULLONG_MAX) {
    const uint64_t leading{static_cast<uint64_t>(value / P10_UINT64)};
    const uint64_t trailing{static_cast<uint64_t>(value % P10_UINT64)};
    snprintf(str.data(), str.size(), "%" PRIu64 "%.19" PRIu64, leading, trailing);
  } else {
    snprintf(str.data(), str.size(), "%" PRIu64, static_cast<uint64_t>(value));
  }
  return str.data();
}

[[nodiscard]] static auto strtoxxl(const char* __restrict src) noexcept -> uint128_t {
  uint128_t value{0};
  while (*src) {
    value *= 10;
    value += static_cast<uint128_t>(*src - '0');
    ++src;
  }
  return value;
}
#endif

auto main(int32_t argc, char* const argv[]) -> int32_t {
  // clang-format off
  std::set_terminate  ([]() { fprintf(stderr, "\nUnhandled exception");        std::abort(); });
  std::set_new_handler([]() { fprintf(stderr, "\nFailed to allocate memory!"); std::abort(); });
  // clang-format on

#if defined(GENERATE_SQUASH_STRETCH)
  const double value{atof(argv[5])};
  argc--;
  fprintf(stdout, "\nValue : %g\n", value);

  _squash = new Squash_t(/*value*/);
  _stretch = new Stretch_t(/*value*/);
#elif 0
  if ((6 == argc) && !strncasecmp(argv[5], "--XX", 4)) {
    extern uint32_t XX;
    XX = std::strtoul(4 + argv[5], nullptr, 10);
    // XX = strtoxxl(4 + argv[5]);
    argc--;
    // fprintf(stdout, "\nXX : %s\n", xxltostr(XX).c_str());
    fprintf(stdout, "\nXX : %" PRId32 "\n", XX);
  }
#endif

  fprintf(stdout,
          "Moruga compressor (C) 2022, M.W. Hessel.\n"
          "Based on PAQ compressor series by M. Mahoney.\n"
          "Free under GPL, https://www.gnu.org/licenses/\n"
          "https://github.com/the-m-master/Moruga/\n");

  level_ = DEFAULT_OPTION;
  bool compress{false};
  const char* inFileName{nullptr};
  const char* outFileName{nullptr};

  static const std::string verbose_str{"--verbose"};
  static const std::string version_str{"--version"};

  for (auto n{1}; n < argc; ++n) {
    if (!verbose_str.compare(argv[n])) {
      verbose_ = true;
    } else if (!version_str.compare(argv[n])) {
      return EXIT_SUCCESS;
    } else if ((1 == strnlen(argv[n], 3)) && ('c' == argv[n][0])) {
      compress = true;
    } else if ((1 == strnlen(argv[n], 3)) && ('d' == argv[n][0])) {
      compress = false;
    } else if ((2 <= strnlen(argv[n], 3)) && ('-' == argv[n][0])) {
      if ((argv[n][1] >= '0') && (argv[n][1] <= '9')) {
        level_ = std::clamp(std::abs(std::stoi(argv[n], nullptr, 10)), 0, 12);
      }
    } else {
      if (nullptr != inFileName) {
        outFileName = argv[n];
      } else {
        inFileName = argv[n];
      }
    }
  }

  if (!((argc >= 4) && (argc <= 6)) || (nullptr == inFileName) || (nullptr == outFileName)) {
    static constexpr std::array<uint32_t, 11> use{{90, 119, 177, 294, 526, 991, 1921, 3780, 7500, 13912, 25711}};  // TODO verify this
    fprintf(stderr,
            "\n\nUsage: Moruga <command> <infile> <outfile>\n"
            "\n<Commands>\n"
            "  c\t\tTo compress a file\n"
            "  d\t\tTo decompress a file\n"
            "  -0 to -10\tUses %" PRIu32 ",%" PRIu32 ",%" PRIu32 ",%" PRIu32 ",%" PRIu32 ",%" PRIu32 ",%" PRIu32 ",%" PRIu32 ",%" PRIu32 ",%" PRIu32 " or %" PRIu32
            " MiB memory\n\t\tDefault is option %" PRIu32 ", uses %" PRIu32 " MiB of memory\n",
            use[0], use[1], use[2], use[3], use[4], use[5], use[6], use[7], use[8], use[9], use[10], DEFAULT_OPTION, use[DEFAULT_OPTION]);
    return EXIT_FAILURE;
  }

#if defined(__linux__) || defined(_MSC_VER)
  if (!strcmp(inFileName, outFileName)) {
#else
  if (!strcasecmp(inFileName, outFileName)) {
#endif
    fprintf(stderr, "\n<infile> and <outfile> can not be identical!");
    return EXIT_FAILURE;
  }

  File_t infile{inFileName, "rb"};
  File_t outfile{outFileName, "wb+"};  // write/read otherwise decode will fail

  const auto originalLength{infile.Size()};

  const auto start_time{std::chrono::high_resolution_clock::now()};

  if (compress) {
    fprintf(stdout, "\nEncoding file '%s' ... with memory option %d\n", inFileName, level_);

#if 1
    File_t tmp;  // ("_tmp_.txt", "wb+");
    const auto iLen{infile.Size()};
    if (iLen <= 0) {
      fprintf(stderr, "\nFile '%s' has no length, encoding not possible!", inFileName);
      return EXIT_FAILURE;
    }
    const auto data_pos{encode_txt(infile, tmp)};
    assert((data_pos > 0) && (data_pos < 0x07FFFFFF));
    const auto oLen{tmp.Size()};
    // At least 25% reduction, otherwise it will perform worse
    if (oLen < (iLen - (iLen / INT64_C(4)))) {
      infile.Close();
      infile = tmp;
      tmp = nullptr;
    } else {
      fprintf(stdout, "<binary file>\n");
      tmp.Close();
    }
#else
    const auto data_pos{INT64_C(0)};
    const int64_t iLen{infile.Size()};
    if (iLen <= 0) {
      fprintf(stderr, "\nFile '%s' has no length, encoding not possible!", inFileName);
      return EXIT_FAILURE;
    }
#endif
    infile.Rewind();

    assert((level_ >= 0) && (level_ <= 12));
    outfile.putc(level_);  // Write memory level

    Buffer_t _buf{};
    Encoder_t en{_buf, true, outfile};

    // Original file length
    en.CompressVLI(iLen);

    // Increasing the buffer size above the file length is not useful
    _buf.Resize(static_cast<uint64_t>(iLen), MEM());

    // File length after text preparation (successful or not)
    const auto len{infile.Size()};
    en.CompressVLI(len);

    // Start point text preparation (successful or not)
    en.CompressVLI(data_pos);

    const bool is_txtprep{iLen != len};  // Set if there was text preparation done

    uint8_t csum{checksum(reinterpret_cast<const uint8_t*>(&originalLength), sizeof(originalLength))};
    csum = static_cast<uint8_t>(csum + checksum(reinterpret_cast<const uint8_t*>(&len), sizeof(len)));
    en.Compress(csum);

    Monitor_t monitor{infile, outfile, len, iLen};
    Progress_t progress{"ENC", true, monitor};

    en.SetBinary(!is_txtprep);
    en.SetDataPos(data_pos);
    en.SetStart(is_txtprep);

#if defined(DEBUG_WRITE_ANALYSIS_ENCODER)
    File_t analysis("Analysis.csv", "wb");
#endif

    if (is_txtprep) {
#if defined(DEBUG_WRITE_ANALYSIS_ENCODER)
      int64_t pos{0};
#endif
      for (int32_t ch; EOF != (ch = infile.getc());) {
        en.Compress(ch);

#if defined(DEBUG_WRITE_ANALYSIS_ENCODER)
        if (!(++pos % (1 << 12))) {
          fprintf(analysis, "%" PRIi64 ",%" PRIi64 "\n", pos, outfile.Position());
        }
#endif
      }
    } else {
#if defined(DEBUG_WRITE_ANALYSIS_ENCODER)
      int64_t pos{0};
#endif
      Filter_t filter{_buf, len, infile, &en};

      for (int32_t ch; EOF != (ch = infile.getc());) {
        if (filter.Scan(ch)) {
          continue;
        }
        en.Compress(ch);

#if defined(DEBUG_WRITE_ANALYSIS_ENCODER)
        if (!(++pos % (1 << 12))) {
          fprintf(analysis, "%" PRIi64 ",%" PRIi64 "\n", pos, outfile.Position());
        }
#endif
      }
    }
    en.Flush();
  } else {
    if (infile.Size() <= 0) {
      fprintf(stderr, "\nFile '%s' has no length, decoding not possible!", inFileName);
      return EXIT_FAILURE;
    }

    level_ = infile.getc();  // Read memory level
    if (!((level_ >= 0) && (level_ <= 12))) {
      fprintf(stderr, "\nFile '%s' is damaged, decoding not possible!", inFileName);
      return EXIT_FAILURE;
    }

    fprintf(stdout, "\nDecoding file '%s' ... with memory option %d\n", inFileName, level_);

    Buffer_t _buf{};
    Encoder_t en{_buf, false, infile};

    // Original file length
    const auto iLen{en.DecompressVLI()};

    // Increasing the buffer size above the file length is not useful
    _buf.Resize(static_cast<uint64_t>(iLen), MEM());

    // File length after text preparation (successful or not)
    auto len{en.DecompressVLI()};

    // Start point text preparation (successful or not)
    const int64_t data_pos{en.DecompressVLI()};
    assert((data_pos >= 0) && (data_pos < 0x07FFFFFF));

    const bool is_txtprep{iLen != len};  // Set if there was text preparation done

    uint8_t csum{checksum(reinterpret_cast<const uint8_t*>(&iLen), sizeof(iLen))};
    csum = static_cast<uint8_t>(csum + checksum(reinterpret_cast<const uint8_t*>(&len), sizeof(len)));
    const auto valid{static_cast<uint8_t>(en.Decompress())};
    if (csum != valid) {
      fprintf(stderr, "\nFile '%s' is damaged, decoding not possible!", inFileName);
      return EXIT_FAILURE;
    }

    Monitor_t monitor{infile, outfile, len, iLen};

    {
      Progress_t progress{"DEC", false, monitor};

      en.SetBinary(!is_txtprep);
      en.SetDataPos(static_cast<uint32_t>(data_pos));
      en.SetStart(is_txtprep);

      if (is_txtprep) {
        for (int64_t pos{0}; pos < len; ++pos) {
          auto ch{en.Decompress()};
          outfile.putc(ch);
        }
      } else {
        Filter_t filter{_buf, len, outfile, nullptr};

        for (int64_t pos{0}; pos < len; ++pos) {
          auto ch{en.Decompress()};
          if (filter.Scan(ch, pos)) {
            continue;
          }
          assert(outfile.Position() == pos);
          outfile.putc(ch);
        }
      }
    }

#if 1
    if (iLen != len) {
      outfile.Rewind();
      File_t tmp;  // ("_TMP_.txt", "wb+");
      const auto oLen{decode_txt(outfile, tmp)};
      if (oLen > len) {
        tmp.Rewind();
        outfile.Rewind();

        auto i{oLen};
        while (i--) {
          outfile.putc(tmp.getc());
        }
        len = oLen;
      }
      tmp.Close();
    }
#endif
  }

  int64_t bytes_done{0};
  if (compress) {
    bytes_done = originalLength;
    fprintf(stdout, "\nEncoded from %" PRId64 " bytes to %" PRId64 " bytes.", bytes_done, outfile.Size());
#if 1                                             // TODO clean-up
    if (INT64_C(1000000000) == originalLength) {  // enwik9
      const auto improvement{INT64_C(136374429) - outfile.Size()};
      fprintf(stdout, "\nImprovement %" PRId64 " bytes\n", improvement);
    } else if (INT64_C(100000000) == originalLength) {  // enwik8
      const auto improvement{INT64_C(17308785) - outfile.Size()};
      fprintf(stdout, "\nImprovement %" PRId64 " bytes\n", improvement);
    }
#endif
  } else {
    bytes_done = outfile.Size();
    fprintf(stdout, "\nDecoded from %" PRId64 " bytes to %" PRId64 " bytes.", originalLength, bytes_done);
  }
  fprintf(stdout, "\nMaximum memory used: %" PRIu32 " KiB", Progress_t::PeakMemoryUse());

  const auto end_time{std::chrono::high_resolution_clock::now()};
  const std::chrono::high_resolution_clock::time_point delta_time{end_time - start_time};
  const auto duration_ns = double(std::chrono::duration_cast<std::chrono::nanoseconds>(delta_time.time_since_epoch()).count());

  fprintf(stdout, "\nTotal time %3.1f sec (%3.0f ns/byte)\n\n", duration_ns / 1e9, round(duration_ns / double(bytes_done)));

  return EXIT_SUCCESS;
}
